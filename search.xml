<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android自定义AsyncTaskLoader</title>
    <url>/20161020/android/11b89789/</url>
    <content><![CDATA[<p>Android3.0以后推出了Loader,用来异步加载数据的,配合ListView或者GridView等用Adapter作为数据源的来使用，非常方便。<br>下面是我自己封装的一个自定义的AsyncTaskLoader,可以异步加载List数据，留作以后备用。</p>
<a id="more"></a>

<h2 id="自定义AsyncTaskLoader"><a href="#自定义AsyncTaskLoader" class="headerlink" title="自定义AsyncTaskLoader"></a>自定义AsyncTaskLoader</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.support.v4.content.AsyncTaskLoader;</span><br><span class="line"></span><br><span class="line">public class CustomListAsyncTaskLoader extends AsyncTaskLoader&lt;List&gt; &#123;</span><br><span class="line">    private List list;</span><br><span class="line">    private LoadListener listener;</span><br><span class="line">    public CustomListAsyncTaskLoader(Context context, LoadListener listener) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.listener &#x3D; listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onStartLoading() &#123;</span><br><span class="line">        &#x2F;&#x2F; just make sure if we already have content to deliver</span><br><span class="line">        if (list !&#x3D; null)&#123;</span><br><span class="line">            deliverResult(list);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     &#x2F;&#x2F; otherwise if something has been changed or first try</span><br><span class="line">        if(takeContentChanged() || list &#x3D;&#x3D; null)&#123;</span><br><span class="line">            forceLoad();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onStopLoading() &#123;</span><br><span class="line">        cancelLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onReset() &#123;</span><br><span class="line">        super.onReset();</span><br><span class="line">        onStopLoading();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; clear reference to object</span><br><span class="line">        &#x2F;&#x2F; it&#39;s necessary to allow GC to collect the object</span><br><span class="line">        &#x2F;&#x2F; to avoid memory leaking</span><br><span class="line">        list &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List loadInBackground() &#123;</span><br><span class="line">        &#x2F;&#x2F; even if fail return empty list and print exception stack trace</span><br><span class="line">        list &#x3D; Collections.unmodifiableList((List) listener.loading());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public interface LoadListener &#123;</span><br><span class="line">        List loading();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private LoaderManager.LoaderCallbacks&lt;List&gt; loaderCallbacks &#x3D; new LoaderManager.LoaderCallbacks&lt;List&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">       public Loader&lt;List&gt; onCreateLoader(int i, Bundle bundle) &#123;</span><br><span class="line">    progress_bar.setVisibility(View.VISITIY);</span><br><span class="line">           return new CustomListAsyncTaskLoader(getActivity(), new LoadListener() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            public List loading() &#123;</span><br><span class="line">                return getDataList();&#x2F;&#x2F;这里可以写自己的耗时的操作，如获取网络数据，获取数据库数据等</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onLoadFinished(Loader&lt;List&gt; listLoader, List list) &#123;</span><br><span class="line">           progress_bar.setVisibility(View.GONE);</span><br><span class="line">           mAdapter.setData(list);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onLoaderReset(Loader&lt;List&gt; listLoader) &#123;</span><br><span class="line">           mAdapter.clear();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个是自定义Adapter中的setData方法</span><br><span class="line">public void setData(List&lt;T&gt; dataList)&#123;</span><br><span class="line">        this.clear();</span><br><span class="line">        if(Build.VERSION.SDK_INT &gt;&#x3D; 11)&#123;</span><br><span class="line">            this.addAll(dataList);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(T data : dataList)&#123;</span><br><span class="line">                this.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于Loader的使用如下"><a href="#关于Loader的使用如下" class="headerlink" title="关于Loader的使用如下"></a>关于Loader的使用如下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(loaderManager.getLoader(001) &#x3D;&#x3D; null)&#123;</span><br><span class="line">    loaderManager.initLoader(001, bundle1, loaderCallbacks); &#x2F;&#x2F;bundle1是传递的数据，可以为空</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    loaderManager.restartLoader(001, bundle1, loaderCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间原因，就不上传源码了。如果大家有兴趣交流，欢迎发邮箱<a href="mailto:&#115;&#x75;&#110;&#x72;&#57;&#x32;&#x32;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#115;&#x75;&#110;&#x72;&#57;&#x32;&#x32;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a>。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>jonesun</tag>
      </tags>
  </entry>
  <entry>
    <title>Github图片无法查看问题解决</title>
    <url>/20200522/uncategorized/3db93ce5/</url>
    <content><![CDATA[<p>经常访问github, 最近发现github上的图片无法显示，按照以下步骤后，顺利解决</p>
<ol>
<li>使用文本编辑器或其他编辑器打开host文件</li>
</ol>
<p>路径为: C:\Windows\System32\drivers\etc\host</p>
<p><img src="https://github.com/jonesun/blog/blob/master/source/image/other/github-cannot-show-pic.png?raw=true" alt="image"> </p>
<ol start="2">
<li><p>填入host github代理</p>
<a id="more"></a>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">140.82.113.3      github.com</span><br><span class="line">140.82.114.20     gist.github.com</span><br><span class="line"></span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars0.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars8.githubusercontent.com</span><br><span class="line"></span><br><span class="line"># GitHub End</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>保存后重启电脑(某些情况下需重启), 即可</li>
</ol>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Github-Hexo创建博客</title>
    <url>/20160808/hexo/b55300/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><a href="https://nodejs.org/en/">安装nodejs</a><br><a href="https://git-scm.com/">安装git</a><br> <a id="more"></a></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>打开cmd命令行，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:&#x2F;hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">&#x2F;&#x2F;卸载</span><br><span class="line">npm uninstall hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install #安装package.json中的依赖包</span><br><span class="line">npm install hexo-deployer-git --save #安装deploy插件，用于部署到GitHub</span><br></pre></td></tr></table></figure>

<h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate #可简写为hexo g 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</span><br><span class="line">hexo server #可简写为hexo s 启动本地web服务，用于博客的预览</span><br><span class="line">hexo deploy #可简写为hexo d 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure>

<h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p>打开浏览器，输入<a href="http://localhost:4000/">http://localhost:4000</a></p>
<h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><p>在blog目录下运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next #将next主题下载到themes文件夹下</span><br><span class="line">&#x2F;&#x2F;更新主题</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>打开blog目录下的配置文件_config.xml,修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next #next即为主题名称</span><br></pre></td></tr></table></figure>

<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #清理hexo缓存</span><br><span class="line">hexo s #重新启动本地web服务器</span><br></pre></td></tr></table></figure>
<p>主题的其他设置见next主题<a href="http://theme-next.iissnan.com/">官网</a>.</p>
<h2 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h2><p>打开blog目录下的配置文件_config.xml,修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;jonesun&#x2F;jonesun.github.io.git</span><br><span class="line">    branch: master</span><br><span class="line">    name: jone sun</span><br><span class="line">    email: sunjoner7@gmail.com</span><br></pre></td></tr></table></figure>
<h2 id="部署到Github-Pages"><a href="#部署到Github-Pages" class="headerlink" title="部署到Github Pages"></a>部署到Github Pages</h2><p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>完成部署,过程中需要github账号/密码</p>
<h2 id="保存Hexo博客源文件"><a href="#保存Hexo博客源文件" class="headerlink" title="保存Hexo博客源文件"></a>保存Hexo博客源文件</h2><ol>
<li>在GitHub新建仓库blog </li>
<li>删除blog目录和主题目录下的.git文件夹(如果存在)</li>
<li>修改blog目录的.gitignore文件,加入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;.deploy_git</span><br><span class="line">&#x2F;public</span><br></pre></td></tr></table></figure></li>
<li>同步到Github中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line"># 若出现&#96;warning: LF will be replaced by CRLF in&#96;</span><br><span class="line"># 执行:</span><br><span class="line"># git config --global core.autocrlf  false</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;jonesun&#x2F;jonesun.github.io.git</span><br><span class="line">git push -u origin master</span><br><span class="line"># 此时可能会出错failed to push some refs to git  出现错误的主要原因是github中的README.md文件不在本地代码目录中，可以通过如下命令进行代码合并</span><br><span class="line"># git pull --rebase origin master</span><br><span class="line"># 此时再执行语句 </span><br><span class="line"># git push -u origin master</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h2><ol>
<li>检查更新，将本地博客源文件更新至最新版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li>
<li>新建文章<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &lt;新的文章&gt;</span><br></pre></td></tr></table></figure></li>
<li>编辑文章<br>打开blog\source_posts文件夹，使用自己喜欢的Markdowm编辑器进行编辑保存，这里推荐一个在线编辑器<a href="https://www.zybuluo.com/mdeditor">作业部落</a><br>运行查看<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
<li>同步Hexo源文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . #不添加被删除的文件,&#96;git add -A&#96;会添加所有修改.</span><br><span class="line">git commit -m &quot;更新描述&quot;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;jonesun&#x2F;blog.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li>
<li>部署<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="新电脑配置"><a href="#新电脑配置" class="headerlink" title="新电脑配置"></a>新电脑配置</h2><ol>
<li><p>安装nodejs和git</p>
</li>
<li><p>安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
<li><p>下载博客源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;jonesun&#x2F;blog.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装模块</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules &amp;&amp; npm install --force</span><br></pre></td></tr></table></figure>

<ol>
<li>运行部署<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="博客提交搜索引擎收录"><a href="#博客提交搜索引擎收录" class="headerlink" title="博客提交搜索引擎收录"></a>博客提交搜索引擎收录</h1><p>请确保Next主题版本为NexT-7.1.2及以上 </p>
<h2 id="百度和Google收录"><a href="#百度和Google收录" class="headerlink" title="百度和Google收录"></a>百度和Google收录</h2><ul>
<li>安装百度和 Google 的站点地图生成插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件(最外层的_config.yml), 可搜索sitemap字段(默认都有，没有再添加)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自动生成sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hexo g 生成后进入 public 目录，你会发现里面有 sitemap.xml 和 baidusitemap.xml 两个文件，这就是生成的站点地图。里面包含了网站上所有页面的链接，搜索引擎通过这两个文件来抓取网站页面: </p>
<p>sitemap.xml 用来提交给 Google</p>
<p>baidusitemap.xml 用来提交给百度</p>
<h2 id="Google-Search-Console"><a href="#Google-Search-Console" class="headerlink" title="Google Search Console"></a>Google Search Console</h2><ul>
<li>进入 <a href="https://www.google.com/webmasters">Google Web Master Search Console</a>，首先需要进行站点验证，在<strong>主题配置文件_config.yml</strong> 把验证代码写上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google_site_verification: 7MWmpu7Y_liZprzsvd1MxYuG1tRYQ7V1eK9_rLcHmB0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过hexo g 和 hexo d部署后，再点击Google Search Console需要的验证</p>
</li>
<li><p>验证是否收录</p>
</li>
</ul>
<p>打开谷歌搜索,输入: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;换成自己的域名，查看结果</span><br><span class="line">site: https:&#x2F;&#x2F;jonesun.github.io&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="百度站长平台"><a href="#百度站长平台" class="headerlink" title="百度站长平台"></a>百度站长平台</h2><p>首先注册百度账号，完善个人信息，然后打开<a href="https://ziyuan.baidu.com/site">站长平台</a>, 添加网站，得到验证代码后，在<strong>主题配置文件_config.yml</strong> 把验证代码写上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_site_verification: code-SeFMiHxes9</span><br></pre></td></tr></table></figure>

<ul>
<li>通过hexo g 和 hexo d部署后，再点击验证，等待结果</li>
</ul>
<h2 id="链接提交"><a href="#链接提交" class="headerlink" title="链接提交"></a>链接提交</h2><p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<strong>主题配置文件_config.yml</strong> 加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 5                      ## 提交最新的五个链接</span><br><span class="line">  host: jonesun.github.io         ## 百度站长平台中注册的域名</span><br><span class="line">  token: wxEYCMr7JzpSUEfi     ## 准入秘钥</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hexo-创建草稿"><a href="#hexo-创建草稿" class="headerlink" title="hexo 创建草稿"></a>hexo 创建草稿</h2><p>使用草稿新建的文章就不会发布，会存放在/source/_drafts路径下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>发布草稿，会把/source/_drafts下的文章移到/source/_posts下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure>

<h2 id="显示字数及阅读时长"><a href="#显示字数及阅读时长" class="headerlink" title="显示字数及阅读时长"></a>显示字数及阅读时长</h2><p>安装hexo-symbols-count-time</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>next主题中_config.yml中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>     <span class="comment"># 是否另起一行（true的话不和发表时间等同一行）</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>     <span class="comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span>   <span class="comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                   <span class="comment"># Average Word Length</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>                 <span class="comment"># Words Per Minute（每分钟阅读词数）</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">mins.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果显示为阅读时长NaN:aN, 执行 hexo clean即可</p>
</blockquote>
<p>在 Hexo 更新至 5.x 版本，Next 更新至 7.x 版本后，会出现文章的中文目录点击跳转失效的 bug, 参见<a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">Github Issues</a></p>
<p>排版布局和翻译风格上可以参考了阮一峰老师的<a href="https://github.com/ruanyf/document-style-guide">中文技术文档的写作规范</a></p>
<p>更多Hexo相关配置，可参考<a href="https://hexo.io/zh-cn/docs/">官网</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客集成Gitalk评论</title>
    <url>/20200729/hexo/63d6ed0b/</url>
    <content><![CDATA[<blockquote>
<p>next高版本的已经默认集成gitalk插件, 如果你本地没找到配置，尽快升级。目前我使用的是next 7.x版本，故只需要在_config.yml中打开gitalk配置即可</p>
</blockquote>
<ol>
<li>在GitHub新建Application</li>
</ol>
<p>用于用户评论文章时登录授权</p>
 <a id="more"></a>

<p><a href="https://github.com/settings/applications/new">新建</a></p>
<p><img src="register-a-new-oauth-application.png" alt="image"> </p>
<ul>
<li><p>Application name： 应用名称</p>
</li>
<li><p>Homepage URL：主页地址，直接写博客地址就行</p>
</li>
<li><p>Application description： 描述</p>
</li>
<li><p>Authorization callback URL：回调地址，也写博客地址就行</p>
</li>
</ul>
<ol start="2">
<li>拷贝Client ID和Client Secret</li>
</ol>
<p><img src="client-id-secret.png" alt="image"> </p>
<ol start="3">
<li>在Github中新建仓库</li>
</ol>
<p>用于存放评论数据</p>
<p><a href="https://github.com/new">新建</a></p>
<p><img src="blog-comment.png" alt="image"> </p>
<ol start="4">
<li>修改next主题配置</li>
</ol>
<p>打开next主题配置文件_config.yml(路径为blog\themes\xxx-主题名称)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true #改为 true </span><br><span class="line">  github_id: jonesun # 填写自己的github的用户名</span><br><span class="line">  repo: MyBlogGitalk # 存放评论的仓库名</span><br><span class="line">  client_id: xxxxxx # 填写上一步拷贝的Client ID</span><br><span class="line">  client_secret: xxxxxxxxx # 填写上一步拷贝的Client Secret</span><br><span class="line">  admin_user: jonesun # 也填写自己的github的用户名</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>部署上传</li>
</ol>
<p>使用 hexo g 和hexo d上传到博客保存的git上(一般是github)</p>
<p><img src="gitalk-comment-data.png" alt="image"> </p>
<p>用户在看到文章后，即可进行评论(需要GitHub账户才行)</p>
<p>如果有出现这个，登录一下就行了</p>
<p><img src="no-comment.png" alt="image"> </p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
        <tag>NexT</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>InterProcessSharedPreferences-Android中跨进程的SharedPreferences</title>
    <url>/20161208/android/a29c5e38/</url>
    <content><![CDATA[<p>解决android中的SharedPreferences不能跨进程读写的问题.</p>
 <a id="more"></a>

<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><ul>
<li><p>选择添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile project(&#39;:interprocesssharedpreferences&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>或者    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;jone.common.android.data.sharedPreferences:interprocesssharedpreferences:1.0.0&#39; </span><br><span class="line">&#x2F;&#x2F;如果获取不到，则加入 maven &#123; url &#39;http:&#x2F;&#x2F;dl.bintray.com&#x2F;sunjoner7&#x2F;maven&#39; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在AndroidManifest.xml注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--authorities 规则：应用的包名 + &quot;.InterProcessContentProvider&quot;--&gt;</span><br><span class="line">   &lt;provider</span><br><span class="line">       android:name&#x3D;&quot;jone.common.android.data.sharedPreferences.InterProcessContentProvider&quot;</span><br><span class="line">       android:authorities&#x3D;&quot;jone.common.android.data.sharedPreferences.sample.InterProcessContentProvider&quot;</span><br><span class="line">       android:enabled&#x3D;&quot;true&quot;</span><br><span class="line">       android:exported&#x3D;&quot;true&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>  自行copy<a href="https://github.com/jonesun/InterProcessSharedPreferences">源码</a>。</p>
</li>
</ul>
<h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterProcessSharedPreferences interProcessSharedPreferences = InterProcessSharedPreferences.getInstance(getApplication());</span><br><span class="line">interProcessSharedPreferences.putString(<span class="string">&quot;testStr&quot;</span>, edit_value.getText().toString()); <span class="comment">//写入</span></span><br><span class="line">interProcessSharedPreferences.getString(<span class="string">&quot;testStr&quot;</span>, <span class="string">&quot;empty&quot;</span>); <span class="comment">//读取</span></span><br><span class="line">interProcessSharedPreferences.remove(<span class="string">&quot;testStr&quot;</span>); <span class="comment">//删除</span></span><br></pre></td></tr></table></figure>

<h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterProcessSharedPreferences interProcessSharedPreferences = InterProcessSharedPreferences.getInstance(getApplication());</span><br><span class="line"></span><br><span class="line">ISharedPreferences.OnSharedPreferenceChangeListener onSharedPreferenceChangeListener = <span class="keyword">new</span> ISharedPreferences.OnSharedPreferenceChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSharedPreferenceChanged</span><span class="params">(ISharedPreferences sharedPreferences, String key)</span> </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;interProcessSharedPreferences--onSharedPreferenceChanged&gt;&gt;key: &quot;</span> + key + <span class="string">&quot; value: &quot;</span> + sharedPreferences.getString(key, <span class="string">&quot;empty&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//监听(onCreate)</span></span><br><span class="line">interProcessSharedPreferences.registerOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener); </span><br><span class="line"></span><br><span class="line"><span class="comment">//取消监听(onDestroy 不需要监听时一定要取消监听)</span></span><br><span class="line">interProcessSharedPreferences.unregisterOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>jonesun</tag>
      </tags>
  </entry>
  <entry>
    <title>JMH-Java微基准测试套件</title>
    <url>/20200720/java/520c60c5/</url>
    <content><![CDATA[<h1 id="JMH-Java-Microbenchmark-Harness-和jMeter的不同"><a href="#JMH-Java-Microbenchmark-Harness-和jMeter的不同" class="headerlink" title="JMH(Java Microbenchmark Harness)和jMeter的不同"></a>JMH(Java Microbenchmark Harness)和jMeter的不同</h1><blockquote>
<p>JMH和jMeter的使用场景还是有很大的不同的，jMeter更多的是对rest api进行压测，而JMH关注的粒度更细，它更多的是发现某块性能槽点代码，然后对优化方案进行基准测试对比。比如json序列化方案对比，bean copy方案对比，文中提高的洗牌算法对比等。</p>
</blockquote>
<p><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">官方样例</a></p>
<p><a href="https://github.com/Childe-Chen/goodGoodStudy/tree/master/src/main/java/com/cxd/benchmark">国人翻译的demo</a></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>JMH比较典型的应用场景有：</p>
<ul>
<li>想准确的知道某个方法需要执行多长时间，以及执行时间和输入之间的相关性</li>
<li>对比接口不同实现在给定条件下的吞吐量，找到最优实现</li>
<li>查看多少百分比的请求在多长时间内完成</li>
<li>…</li>
</ul>
<h1 id="JMH-可视化"><a href="#JMH-可视化" class="headerlink" title="JMH 可视化"></a>JMH 可视化</h1><p>将测试例子结果的 json 文件导入，就可以实现可视化</p>
<p><a href="http://deepoove.com/jmh-visual-chart/">JMH Visual Chart</a></p>
<p><a href="https://jmh.morethan.io/">JMH Visualizer</a></p>
<a id="more"></a>

<h1 id="JMH-插件"><a href="#JMH-插件" class="headerlink" title="JMH 插件"></a>JMH 插件</h1><p>可以通过 IDEA 安装 JMH 插件使 JMH 更容易实现基准测试，在 IDEA 中点击 File-&gt;Settings…-&gt;Plugins，然后搜索 jmh，选择安装 JMH plugin</p>
<p>这个插件可以让我们能够以 JUnit 相同的方式使用 JMH，主要功能如下：</p>
<ul>
<li>自动生成带有 @Benchmark 的方法</li>
<li>像 JUnit 一样，运行单独的 Benchmark 方法</li>
<li>运行类中所有的 Benchmark 方</li>
</ul>
<p>比如可以通过右键点击 Generate…，选择操作 Generate JMH benchmark 就可以生成一个带有 @Benchmark 的方法。</p>
<p>还有将光标移动到方法声明并调用 Run 操作就运行一个单独的 Benchmark 方法。</p>
<p>将光标移到类名所在行，右键点击 Run 运行，该类下的所有被 @Benchmark 注解的方法都会被执行。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="maven-引用"><a href="#maven-引用" class="headerlink" title="maven 引用"></a>maven 引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.openjdk.jmh&#x2F;jmh-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.23&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.openjdk.jmh&#x2F;jmh-generator-annprocess --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.23&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;!--            &lt;scope&gt;test&lt;&#x2F;scope&gt;--&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JMH-基础"><a href="#JMH-基础" class="headerlink" title="JMH 基础"></a>JMH 基础</h2><p><strong>@BenchmarkMode</strong></p>
<p>用来配置 Mode 选项，可用于类或者方法上，这个注解的 value 是一个数组，可以把几种 Mode 集合在一起执行，如：@BenchmarkMode({Mode.SampleTime, Mode.AverageTime})，还可以设置为 Mode.All，即全部执行一遍：</p>
<ul>
<li>Throughput：整体吞吐量，每秒执行了多少次调用，单位为 ops/time</li>
<li>AverageTime：用的平均时间，每次操作的平均时间，单位为 time/op</li>
<li>SampleTime：随机取样，最后输出取样结果的分布</li>
<li>SingleShotTime：只运行一次，往往同时把 Warmup 次数设为 0，用于测试冷启动时的性能</li>
<li>All：上面的所有模式都执行一次</li>
</ul>
<p><strong>@State</strong></p>
<p>通过 State 可以指定一个对象的作用范围，JMH 根据 scope 来进行实例化和共享操作。@State 可以被继承使用，如果父类定义了该注解，子类则无需定义。由于 JMH 允许多线程同时执行测试，不同的选项含义如下：</p>
<ul>
<li>Scope.Benchmark：所有测试线程共享一个实例，测试有状态实例在多线程共享下的性能</li>
<li>Scope.Group：同一个线程在同一个 group 里共享实例</li>
<li>Scope.Thread：默认的 State，每个测试线程分配一个实例</li>
</ul>
<p><strong>@OutputTimeUnit</strong></p>
<p>为统计结果的时间单位，可用于类或者方法注解。例如OutputTimeUnit申明为纳秒，所以基准测试单位是ns/op，即每次操作的纳秒单位平均时间<br>如果@BenchmarkMode(Mode.Throughput)和@OutputTimeUnit(TimeUnit.MILLISECONDS)那么基准测试结果就是每毫秒的吞吐量（即每毫秒多少次操作）</p>
<p><strong>@Warmup</strong></p>
<p>预热所需要配置的一些基本测试参数，可用于类或者方法上。一般前几次进行程序测试的时候都会比较慢，所以要让程序进行几轮预热，保证测试的准确性。参数如下所示：</p>
<ul>
<li>iterations：预热的次数</li>
<li>time：每次预热的时间</li>
<li>timeUnit：时间的单位，默认秒</li>
<li>batchSize：批处理大小，每次操作调用几次方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码预热总计5秒（迭代5次，每次1秒</span><br><span class="line">@Warmup(iterations &#x3D; 5, time &#x3D; 1, timeUnit &#x3D; TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>为什么需要预热？</p>
</blockquote>
<pre><code>因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译为机器码，从而提高执行速度，所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</code></pre>
<p><strong>@Measurement</strong></p>
<p>实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 @Warmup 相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;表示循环运行5次，总计5秒时间</span><br><span class="line">@Measurement(iterations &#x3D; 5, time &#x3D; 1, timeUnit &#x3D; TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>


<p><strong>@Threads</strong></p>
<p>每个进程中的测试线程，可用于类或者方法上。</p>
<p><strong>@Fork</strong></p>
<p>进行 fork 的次数，可用于类或者方法上。如果@Fork(1)，那么就是一个线程，这时候就是同步模式。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。</p>
<p><strong>@Param</strong></p>
<p>指定某项参数的多种情况，特别适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义 @State 注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Param(&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;)</span><br><span class="line">int  outputType;</span><br><span class="line">@Benchmark</span><br><span class="line">public String benchmark() throws TemplateException, IOException &#123;</span><br><span class="line">  if(outputType&#x3D;&#x3D;3)&#123;</span><br><span class="line">            return doStream();</span><br><span class="line">  &#125;else if(outputType&#x3D;&#x3D;2) &#123;</span><br><span class="line">    return doCharStream()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return  doString();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>@Setup 和 @TearDown</strong></p>
<p>这是一对注解，作用于方法上，前者用于测试前的初始化工作，后者用于回收某些资源，比如压测前需要准备一些数据</p>
<p><strong>@Level</strong></p>
<p>用于控制 @Setup，@TearDown 的调用时机，有如下含义</p>
<ul>
<li>Level.Tiral: 运行每个性能测试的时候执行，推荐的方式</li>
<li>Level.Iteration, 每次迭代的时候执行</li>
<li>Level.Invocation,每次调用方法的时候执行，这个选项需要谨慎使用</li>
</ul>
<h2 id="运行Benchmark"><a href="#运行Benchmark" class="headerlink" title="运行Benchmark"></a>运行Benchmark</h2><p>JMH提供了Runner类能运行Benchmark类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) throws RunnerException &#123;</span><br><span class="line">    Options opt &#x3D; new OptionsBuilder()</span><br><span class="line">        .include(MyBenchmark.class.getSimpleName())</span><br><span class="line">        .build();</span><br><span class="line">    new Runner(opt).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) throws RunnerException &#123;</span><br><span class="line">        Options opt &#x3D; new OptionsBuilder()</span><br><span class="line">                .include(StringConnectTest.class.getSimpleName())</span><br><span class="line">                .result(&quot;result.json&quot;)</span><br><span class="line">                .resultFormat(ResultFormatType.JSON).build();</span><br><span class="line">        new Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;include接受一个字符串表达式，如只测试方法名字包含“testObjectKey“的方法</span><br><span class="line">include(MyBenchmark.class.getSimpleName()+&quot;.*testObjectKey*&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用4个子进程做性能测试，每个进程预热一次，执行5次迭代</span><br><span class="line">public static void main(String[] args) throws RunnerException &#123;</span><br><span class="line">    Options opt &#x3D; new OptionsBuilder()</span><br><span class="line">        .include(MyBenchmark.class.getSimpleName())</span><br><span class="line">        .forks(4)</span><br><span class="line">        .warmupIterations(1)</span><br><span class="line">        .measurementIterations(5)</span><br><span class="line">        .build();</span><br><span class="line">    new Runner(opt).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-Docker使用</title>
    <url>/20201217/java/springboot/90c59710/</url>
    <content><![CDATA[<p>SpringBoot 2.4.0开始官方插件增加了对docker的支持</p>
<h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><p>登录阿里云<a href="https://cr.console.aliyun.com/cn-shanghai/instances/repositories">容器镜像服务</a></p>
<p>创建命名空间</p>
<p>获取访问凭证(这里为了演示方便,采用固定密码方式，企业项目需根据实际情况设置密码或子账号访问等)</p>
<p>pom.xml检查是否为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>插件中加入docker配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">name</span>&gt;</span>registry.cn-shanghai.aliyuncs.com/jonesun/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 执行完build 自动push --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">publish</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publish</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 默认build访问的是docker.io/paketobuildpacks/builder:base 这个在国内访问较慢，可从阿里云镜像中心搜索用户公开的镜像代替 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">builder</span>&gt;</span>registry.cn-shanghai.aliyuncs.com/sannmizu/builder:base<span class="tag">&lt;/<span class="name">builder</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 默认runImage访问的是docker.io/paketobuildpacks/run:base-cnb 如果在国内访问较慢，可从阿里云镜像中心搜索用户公开的镜像代替 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                        &lt;runImage&gt;registry.cn-hangzhou.aliyuncs.com/paketo-buildpacks/run:base-cnb&lt;/runImage&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--配置构建远程机信息，本机不用配置--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">docker</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                        &amp;lt;!&amp;ndash;远程docker daemon的连接地址和端口(如果本地未安装docker的话)&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                        &lt;host&gt;tcp://192.168.99.100:2375&lt;/host&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                        &amp;lt;!&amp;ndash;如果使用https协议需要设置为true&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                        &lt;tlsVerify&gt;false&lt;/tlsVerify&gt;--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">publishRegistry</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">username</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">url</span>&gt;</span>registry.cn-shanghai.aliyuncs.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">publishRegistry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">docker</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>maven插件有两种方式构建镜像:</p>
<p>插件与本地docker daemon通信来构建镜像，需要在windows安装docker<br>插件使用远程连接与docker daemon通信来构建镜像，需要远程服务器上面的docker开启远程连接</p>
<p>安装<a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247486525&idx=1&sn=01103c0629f36a8e9d511acb26fae225&scene=21#wechat_redirect">私有镜像仓库</a></p>
<p>拉取镜像</p>
<p>登录<br>docker login –username=sunr922@163.com registry.cn-shanghai.aliyuncs.com</p>
<p>docker pull registry.cn-shanghai.aliyuncs.com/jonesun/tool:[镜像版本号]</p>
<p>docker run -p 8888:8888 registry.cn-shanghai.aliyuncs.com/jonesun/tool:[镜像版本号]</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-Starters</title>
    <url>/20201226/java/springboot/c9c436f0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用Spring Boot Starters可以快速集成相关组件，无需编写复杂的配置，在引入某项技术框架时，一个比较好的习惯就是看有没有xxx-starter</p>
<a id="more"></a>

<h2 id="一、官方提供的starts"><a href="#一、官方提供的starts" class="headerlink" title="一、官方提供的starts"></a>一、官方提供的starts</h2><blockquote>
<p>以下基于Spring Boot 2.4.0版本，后续版本可能会有新增和删除，有兴趣可以到spring-boot-autoconfigure中查看最新版本</p>
</blockquote>
<h3 id="application-starters-应用程序级"><a href="#application-starters-应用程序级" class="headerlink" title="application starters 应用程序级"></a>application starters 应用程序级</h3><ul>
<li><p>spring-boot-starter: 核心Starter, 包含自动配置、日志及yaml支持等</p>
</li>
<li><p>spring-boot-starter-aop: 集成Spring AOP和Aspectj, 用于支持面向切面编程</p>
</li>
<li><p>spring-boot-starter-batch: 集成Spring Batch, 用于批处理相关</p>
</li>
<li><p>spring-boot-starter-cache: 集成Spring Cache, 用于缓存相关</p>
</li>
<li><p>spring-boot-starter-hateoas: 集成Spring MVC和Spring HATEOAS构建超媒体RESTFul Web应用</p>
</li>
<li><p>spring-boot-starter-integration: 集成Spring Integration</p>
</li>
<li><p>spring-boot-starter-jdbc: 集成JDBC结合Hikari连接池</p>
</li>
<li><p>spring-boot-starter-jersey: 集成JAX-RS和Jersey构建RESTful Web应用，是spring-boot-starter-web的一个替代品</p>
</li>
<li><p>spring-boot-starter-jooq: 集成JOOQ访问数据库，是spring-boot-starter-data-jpa或者spring-boot-starter-jdbc的替换品</p>
</li>
<li><p>spring-boot-starter-json: 集成Jackson用于读写JSON</p>
</li>
<li><p>spring-boot-starter-jta-atomikos: 集成Atomikos实现JTA事务</p>
</li>
<li><p>spring-boot-starter-jta-bitronix: 集成Bitronix实现JTA事务，不过2.3.0开始被标识为Deprecated</p>
</li>
<li><p>spring-boot-starter-mail: 集成Java Mail和Spring架构的邮件发送功能</p>
</li>
<li><p>spring-boot-starter-security: 集成Spring Security用于权限认证</p>
</li>
<li><p>spring-boot-starter-oauth2-client: 集成Spring Security’s OAuth2/OpenID连接客户端功能</p>
</li>
<li><p>spring-boot-starter-oauth2-resource-server: 集成Spring Security’s OAuth2资源服务器功能</p>
</li>
<li><p>spring-boot-starter-quartz: 集成Quartz任务调度</p>
</li>
<li><p>spring-boot-starter-rsocket: 构建RSocket客户端和服务端</p>
</li>
<li><p>spring-boot-starter-test: 集成JUint Jupiter, Hamcrest和Mockito测试Spring Boot应用和类库</p>
</li>
<li><p>spring-boot-starter-validation: 集成Java Bean Validation结合Hibernate Validator</p>
</li>
<li><p>spring-boot-starter-web: 集成Spring MVC构建RESTful Web应用，使用Tomcat作为默认内嵌容器</p>
</li>
<li><p>spring-boot-starter-web-services: 集成Spring Web Services</p>
</li>
<li><p>spring-boot-starter-webflux: 集成Spring Reactive Web构建WebFlux应用</p>
</li>
<li><p>spring-boot-starter-websocket: 集成Spring WebSocket构建WebSocket应用</p>
</li>
</ul>
<h4 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h4><p>所有Spring Data项目都是为了简化Spring应用的数据访问开发</p>
<ul>
<li><p>spring-boot-starter-data-cassandra: 集成Spring Data Cassandra和分布式数据库Cassandra</p>
</li>
<li><p>spring-boot-starter-data-cassandra-reactive: 集成Spring Data Cassandra Reactive和分布式数据库Cassandra</p>
</li>
<li><p>spring-boot-starter-data-couchbase: 集成Spring Data Couchbase和文档型数据库Couchbase</p>
</li>
<li><p>spring-boot-starter-data-couchbase-reactive: 集成Spring Data Couchbase Reactive和文档型数据库Couchbase</p>
</li>
<li><p>spring-boot-starter-data-elasticsearch: 集成Spring Data和搜索引擎Elasticsearch</p>
</li>
<li><p>spring-boot-starter-data-solr: 集成Spring Data Solr和搜索引擎Apache Solr</p>
</li>
<li><p>spring-boot-starter-data-jdbc: 集成Spring Data JDBC, 给基于JDBC的数据库应用提供Repository封装, 类似于Spring Data JPA中JpaRepository的功能，但是不引入任何ORM框架</p>
</li>
<li><p>spring-boot-starter-data-jpa: 集成Spring Data Jpa结合Hibernate</p>
</li>
<li><p>spring-boot-starter-data-ldap: 集成Spring Data LDAP</p>
</li>
<li><p>spring-boot-starter-data-mongodb: 集成Spring Data MongoDB和文档型数据库MongoDB</p>
</li>
<li><p>spring-boot-starter-data-mongodb-reactive: 集成Spring Data MongoDB Reactive和文档型数据库MongoDB</p>
</li>
<li><p>spring-boot-starter-data-neo4j: 集成Spring Data Neo4j和图形数据库Neo4j</p>
</li>
<li><p>spring-boot-starter-data-r2dbc: 集成Spring Data R2DBC</p>
</li>
<li><p>spring-boot-starter-data-redis: 集成Spring Data Redis和内存数据库Redis并使用Lettuce客户端</p>
</li>
<li><p>spring-boot-starter-data-redis-reactive: 集成Spring Data Redis Reactive和内存数据库Redis并使用Lettuce客户端</p>
</li>
<li><p>spring-boot-starter-data-rest: 集成Spring Data REST暴露Spring Data Repositories输出REST资源</p>
</li>
</ul>
<h4 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h4><ul>
<li><p>spring-boot-starter-thymeleaf: 集成Thymeleaf视图构建MVC Web应用</p>
</li>
<li><p>spring-boot-starter-freemarker: 集成Freemarker视图构建MVC Web应用</p>
</li>
<li><p>spring-boot-starter-mustache: 集成Mustache视图构建Web应用</p>
</li>
<li><p>spring-boot-starter-groovy-templates: 集成Groovy模板视图构建MVC Web应用</p>
</li>
</ul>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li><p>spring-boot-starter-activemq: 集成Apache ActiveMQ，基于JMS(Java Message Service 消息服务)的消息队列</p>
</li>
<li><p>spring-boot-starter-artemis: 集成Apache Artemis，基于JMS的消息队列</p>
</li>
<li><p>spring-boot-starter-amqp: 集成Spring AMQP和Rabbit MQ的消息队列</p>
</li>
</ul>
<h3 id="production-starters-生产级"><a href="#production-starters-生产级" class="headerlink" title="production starters 生产级"></a>production starters 生产级</h3><ul>
<li>spring-boot-starter-actuator: 集成Spring Boot Actuator, 提供生产功能以帮助监控和管理应用程序</li>
</ul>
<h3 id="technical-starters-技术类"><a href="#technical-starters-技术类" class="headerlink" title="technical starters 技术类"></a>technical starters 技术类</h3><ul>
<li><p>spring-boot-starter-log4j2: 集成Log4j2日志框架，注意需排除默认的logback引用</p>
</li>
<li><p>spring-boot-starter-logging: 集成Logback日志框架，引入Spring Boot时默认已集成</p>
</li>
<li><p>spring-boot-starter-tomcat: 集成Tomcat作为内嵌的servlet容器，引入web starter时默认已集成</p>
</li>
<li><p>spring-boot-starter-jetty: 集成Jetty作为内嵌的servlet容器，注意需排除掉web starter原有tomcat引用</p>
</li>
<li><p>spring-boot-starter-undertow: 集成Undertow作为内嵌的servlet容器，注意需排除掉web starter原有tomcat引用</p>
</li>
<li><p>spring-boot-starter-reactor-netty: 集成Netty作为内嵌的响应式Http服务器</p>
</li>
</ul>
<blockquote>
<p>以上所有官方提供的starter，如果你项目pom文件中的parent是spring-boot-starter-parent，则引入时无需指定version，Spring Boot会自动引用相关依赖(感兴趣可以idea安装Maven Helper这个插件看下自己使用的starts各自引用的库的版本)<br>如果发现starter自身引入的库版本较低，或者想体验该库的新版本，需先排除原有库引用再单独引入该库(可从<a href="https://search.maven.org/">Maven Central Repository</a>中查看)</p>
</blockquote>
<h2 id="二、第三方starts"><a href="#二、第三方starts" class="headerlink" title="二、第三方starts"></a>二、第三方starts</h2><p>一般第三方的框架会提供自制的 Spring Boot Starter，如：mybatis-spring-boot-starter，只要几个依赖，几行配置参数就能轻松实现集成</p>
<h2 id="三、自己编写Starter"><a href="#三、自己编写Starter" class="headerlink" title="三、自己编写Starter"></a>三、自己编写Starter</h2><p>除了第三方的 Starter，也可以私有定制Starter，方便在公司内部各业务部门快速集成使用，而不用各自造轮子</p>
<h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ul>
<li>groupId: 不要用官方的org.springframework.boot, 而要用你自己独特的。</li>
<li>artifactId: Spring Boot官方建议非官方的Starter命名格式遵循 xxx-spring-boot-starter ，例如 mybatis-spring-boot-starter。<br>官方starter会遵循spring-boot-starter-xxx ,例如的spring-boot-starter-web。</li>
</ul>
<h3 id="编写要点"><a href="#编写要点" class="headerlink" title="编写要点"></a>编写要点</h3><p>starter集成入应用有两种方式：</p>
<ul>
<li>主动生效，使用@Import注解，集成后在Spring Boot中加入自定义的@Enablexxx就会生效</li>
<li>被动生效, 在autoconfigure资源包下新建META-INF/spring.factories写入XXXAutoConfiguration全限定名, 这样在starter组件集成入Spring Boot应用后就会生效</li>
</ul>
<blockquote>
<p>核心要点是@ConditionalOnMissingBean等注解的用法</p>
</blockquote>
<p>比较好的习惯，编写自定义starter时最好包含以下模块</p>
<h4 id="xxx-spring-boot-autoconfigure"><a href="#xxx-spring-boot-autoconfigure" class="headerlink" title="xxx-spring-boot-autoconfigure"></a>xxx-spring-boot-autoconfigure</h4><p>普通maven项目即可， 需要引用spring-boot-autoconfigure和spring-boot-configuration-processor(以便在IDE中配置参数时可以进行提示)，主要用来定义配置参数、以及自动配置对外暴露的功能（一般是抽象的接口Spring Bean）</p>
<blockquote>
<p>注意一定要显式声明你配置的前缀标识（prefix）</p>
</blockquote>
<h4 id="xxx-spring-boot-starter"><a href="#xxx-spring-boot-starter" class="headerlink" title="xxx-spring-boot-starter"></a>xxx-spring-boot-starter</h4><p>starter是一个空jar。它的唯一目的是提供使用库所必需的依赖项。删除掉src文件夹，在pom文件中加入xxx-spring-boot-autoconfigure依赖(普通maven项目即可)</p>
<p><a href="https://github.com/jonesun/jonesun-sample-spring-boot">示例-jonesun-sample-spring-boot</a></p>
<blockquote>
<p>可以参考<a href="https://docs.spring.io/spring-boot/docs/2.4.1/reference/html/spring-boot-features.html#boot-features-developing-auto-configuration">spring官方提供的文章</a> ,还有市场上较流行的非官方starter的编写，如<a href="https://github.com/mybatis/spring-boot-starter">mybatis-spring-boot-starter</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-Test用法</title>
    <url>/20210305/java/springboot/8dec456e/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用idea新建SpringBoot项目时，大家应该会发现除了正常的src/main文件夹之外，还会有个test文件夹，相应的会引入spring-boot-starter-test模块，<br>本文就来聊聊这个test模板的用法</p>
<p>说到test大家都会想到junit，是的spring-boot-starter-test默认集成的就是junit，但需要注意的是：springboot2.x的版本, 默认使用的是<a href="https://junit.org/junit5/docs/current/user-guide/">junit5</a> 版本, junit4和junit5两个版本差别比较大，需要注意下用法：</p>
<p><em>通常我们只要引入 spring-boot-starter-test 依赖就行，它包含了一些常用的模块 Junit、Spring Test、AssertJ、Hamcrest、Mockito 等</em></p>
<p><img src="junit5vsjunit4.png" alt="junit5vsjunit4"></p>
 <a id="more"></a>

<h2 id="为什么使用JUnit5"><a href="#为什么使用JUnit5" class="headerlink" title="为什么使用JUnit5"></a>为什么使用JUnit5</h2><ul>
<li>JUnit4被广泛使用，但是许多场景下使用起来语法较为繁琐，JUnit5中支持lambda表达式，语法简单且代码不冗余。</li>
<li>JUnit5易扩展，包容性强，可以接入其他的测试引擎。</li>
<li>功能更强大提供了新的断言机制、参数化测试、重复性测试等新功能。</li>
<li>…</li>
</ul>
<p>如无特殊说明，直接使用junit5相关api(org.junit.jupiter.api.*, 这是junit5引入的;  junit4引入的是org.junit.Test这样类似的包)</p>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><ol>
<li>pom.xml中加入spring-boot-starter-test模块(一般会默认引入)：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是SpringBoot2.2开始会需要排除junit-vintage-engine，这个是因为早期的junit5默认引入了junit-vintage-engine用于运行junit4测试(junit-jupiter-engine用于junit5测试), 一般新的项目无需junit4，因此POM中的默认依赖项排除在外</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但从SpringBoot2.4.0开始spring-boot-starter-test中的junit5已经默认移除了junit-vintage-engine，所以就无需手动排除了</p>
</blockquote>
<p>当然，如果有写老的测试代码还是使用了junit4相关api的话:</p>
<ul>
<li>SpringBoot 2.2到2.4.0之前，只要将手动排除的代码注释掉即可</li>
<li>SpringBoot 2.4.0之后，需要手动添加junit-vintage-engine:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>看好实际项目中使用的SpringBoot版本</strong></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>junit5使用的都是org.junit.jupiter.xxx</strong></p>
<ol>
<li><p>在测试类加入@SpringBootTest：这个注解是SpringBoot自1.4.0版本开始引入的一个用于测试的注解，这样一般就可以了，不用加@RunWith(SpringRunner.class)，这个是junit4的注解</p>
</li>
<li><p>在测试方法中加入@Test: 注意是org.junit.jupiter.api.Test</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//xxx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>右击代码即可运行测试</p>
<h2 id="DisplayName-测试显示中文名称"><a href="#DisplayName-测试显示中文名称" class="headerlink" title="@DisplayName()测试显示中文名称"></a>@DisplayName()测试显示中文名称</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(&quot;测试1&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandAloneServerApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试方法1&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//xxx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="displayName.png" alt="displayName"></p>
<h2 id="指定测试顺序"><a href="#指定测试顺序" class="headerlink" title="指定测试顺序"></a>指定测试顺序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;测试1&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandAloneServerApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试方法1&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试方法2&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多其他注解用法，可查阅官方文档 <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">writing-tests-annotations</a></p>
<h2 id="测试Controller"><a href="#测试Controller" class="headerlink" title="测试Controller"></a>测试Controller</h2><p>测试Controller不建议直接引用Controller类进行测试，因为Controller一般是提供api给外部访问用的，使用http请求更能模拟真实场景，SpringBoot中提供了Mockito可以达到效果</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;用户Controller层测试&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span> <span class="comment">//不启动服务器,使用mockMvc进行测试http请求</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserControllerTest</span><span class="params">(MockMvc mockMvc, ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mockMvc = mockMvc;</span><br><span class="line">        <span class="keyword">this</span>.objectMapper = objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;注册&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserForm userForm = <span class="keyword">new</span> UserForm();</span><br><span class="line">        userForm.setName(<span class="string">&quot;jonesun&quot;</span>);</span><br><span class="line">        userForm.setAge(<span class="number">30</span>);</span><br><span class="line">        userForm.setEmail(<span class="string">&quot;sunr922@163.com&quot;</span>);</span><br><span class="line">        <span class="comment">//请求路径不要错了</span></span><br><span class="line">        MvcResult mvcResult = mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                        <span class="comment">//这里要特别注意和content传参数的不同，具体看你接口接受的是哪种</span></span><br><span class="line"><span class="comment">//                        .param(&quot;userName&quot;,info.getUserName()).param(&quot;password&quot;,info.getPassword())</span></span><br><span class="line">                        <span class="comment">//传json参数,最后传的形式是 Body = &#123;&quot;password&quot;:&quot;admin&quot;,&quot;userName&quot;:&quot;admin&quot;&#125;</span></span><br><span class="line">                        .content(objectMapper.writeValueAsString(userForm))</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                        .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">        )</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到返回代码</span></span><br><span class="line">        <span class="keyword">int</span> status = mvcResult.getResponse().getStatus();</span><br><span class="line">        <span class="comment">//得到返回结果</span></span><br><span class="line">        String content = mvcResult.getResponse().getContentAsString();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;status: &#123;&#125;, content: &#123;&#125;&quot;</span>, status, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;列表&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestBuilder request = MockMvcRequestBuilders.get(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line"><span class="comment">//                .param(&quot;searchPhrase&quot;,&quot;ABC&quot;)          //传参</span></span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON);  <span class="comment">//请求类型 JSON</span></span><br><span class="line">        MvcResult mvcResult = mockMvc.perform(request)</span><br><span class="line">                <span class="comment">// 期望的结果状态 等同于Assert.assertEquals(200,status);</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())                 <span class="comment">//添加ResultHandler结果处理器，比如调试时 打印结果(print方法)到控制台</span></span><br><span class="line">                .andReturn();                                         <span class="comment">//返回验证成功后的MvcResult；用于自定义验证/下一步的异步处理；</span></span><br><span class="line">        <span class="keyword">int</span> status = mvcResult.getResponse().getStatus();                 <span class="comment">//得到返回代码</span></span><br><span class="line">        String content = mvcResult.getResponse().getContentAsString();    <span class="comment">//得到返回结果</span></span><br><span class="line">        logger.info(<span class="string">&quot;status: &#123;&#125;, content: &#123;&#125;&quot;</span>, status, content);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/users&quot;))</span></span><br><span class="line"><span class="comment">//                .andDo(print())</span></span><br><span class="line"><span class="comment">//                .andExpect(status().isOk())</span></span><br><span class="line"><span class="comment">//                .andExpect(content().string(containsString(&quot;Hello World&quot;)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码见 <a href="https://github.com/jonesun/mybatis-sample/blob/master/src/test/java/org/jonesun/mybatis/sample/controller/UserControllerTest.java">github</a></p>
<h2 id="测试并发"><a href="#测试并发" class="headerlink" title="测试并发"></a>测试并发</h2><p>有时我们需要对自己编写的代码做并发测试，看在高并发情况下，代码中是否存在线程安全等问题，通常可以利用<a href="https://jmeter.apache.org/">Jmeter</a>或者浏览器提供的各个插件(如postman)。<br>实际上我们可以利用JUC提供的<a href="/20200731/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/d2a4479b/">并发同步器CountDownLatch和Semaphore</a>来实现</p>
<p>举例，模拟秒杀场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GoodsService goodsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long TEST_GOODS_ID = <span class="number">123L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Goods goods = <span class="keyword">new</span> Goods(TEST_GOODS_ID, <span class="string">&quot;商品1&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        goodsService.init(goods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        goodsService.buy(TEST_GOODS_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;秒杀单个商品&quot;)</span></span><br><span class="line">    <span class="meta">@Order(3)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">batchBuy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Integer inventory = goodsService.getInventoryByGoodsId(TEST_GOODS_ID);</span><br><span class="line">        logger.info(<span class="string">&quot;【&#123;&#125;】准备秒杀, 当前库存: &#123;&#125;&quot;</span>, TEST_GOODS_ID, inventory);</span><br><span class="line">        LocalDateTime startTime = LocalDateTime.now();</span><br><span class="line">        AtomicInteger buySuccessAtomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        AtomicInteger notBoughtAtomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        AtomicInteger errorAtomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalNum = <span class="number">300</span>;</span><br><span class="line">        <span class="comment">//用于发出开始信号</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatchSwitch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//控制并发量 10 50 100 200</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(totalNum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalNum; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatchSwitch.await();</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> result = goodsService.buy(TEST_GOODS_ID);</span><br><span class="line">                    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                        buySuccessAtomicInteger.incrementAndGet();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        notBoughtAtomicInteger.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    errorAtomicInteger.incrementAndGet();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatchSwitch.countDown();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        logger.info(<span class="string">&quot;测试完成,花费 &#123;&#125;毫秒，【&#123;&#125;】总共&#123;&#125;个用户抢购&#123;&#125;件商品，&#123;&#125;个人买到 &#123;&#125;个人未买到，&#123;&#125;个人发生异常，商品还剩&#123;&#125;个&quot;</span>, TEST_GOODS_ID, ChronoUnit.MILLIS.between(startTime, LocalDateTime.now()), totalNum,</span><br><span class="line">                inventory, buySuccessAtomicInteger.get(), notBoughtAtomicInteger.get(), errorAtomicInteger.get(),</span><br><span class="line">                goodsService.getInventoryByGoodsId(TEST_GOODS_ID));</span><br><span class="line">        assertEquals(inventory, buySuccessAtomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码见 <a href="https://github.com/jonesun/mybatis-sample/blob/master/src/test/java/org/jonesun/mybatis/sample/controller/UserControllerTest.java">github</a></p>
<p>– 未完，抽时间继续整理整理 –</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-消息队列MQ</title>
    <url>/20210226/java/springboot/ade04692/</url>
    <content><![CDATA[<h1 id="为什么要使用消息队列-MQ"><a href="#为什么要使用消息队列-MQ" class="headerlink" title="为什么要使用消息队列-MQ"></a>为什么要使用消息队列-MQ</h1><p><strong>不要跟风</strong> 使用MQ是为了：</p>
<pre><code>- 解耦:
  传统模式下系统间耦合性太强，比如系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！
  使用了MQ后系统A将消息写入消息队列，需要消息的系统B、C、D自己从消息队列中订阅，从而系统A不需要做任何修改。
- 异步:  
  传统模式下一些非必要的业务逻辑以同步的方式运行，太耗费时间！
  使用了MQ后系统A将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。
- 削峰:
  传统模式下并发量大的时候，所有的请求直接连接到数据库，会造成数据库连接异常从而引起系统崩溃！
  使用了MQ后系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息，减少后端的压力。在生产中，这个短暂的高峰期积压是允许的。</code></pre>
<p><strong>不要挖坑</strong> 不管是引入MQ技术，还是其他技术，有利也有弊：</p>
<pre><code>- 系统可用性降低: 引入MQ之后一旦MQ不可用之后(提供MQ的服务挂掉了)，那凡是关联使用的系统都会受到影响，因此，系统可用性降低
- 系统复杂性增加: 要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输等等，会使得系统的复杂性增大(可能会引入一些潜在的bug)</code></pre>
<p>个人建议，要看实际项目的需求，业务量不是特别大的项目，不建议为了使用而使用。<br>当然如果项目中有以上的场景需求，或者使用传统模式时遇到了瓶颈时，大胆的引入吧(上面说的弊端也是有很多解决方案的，如可以搭建MQ集群来保持MQ的高可用性)！</p>
<p><a href="https://www.cnblogs.com/wusier/p/14689805.html">消息中间件的应用场景</a></p>
 <a id="more"></a>

<h1 id="使用哪种方案"><a href="#使用哪种方案" class="headerlink" title="使用哪种方案"></a>使用哪种方案</h1><p>目前常见和使用广泛的MQ有ActiveMQ、RabbitMQ、RocketMQ、Kakfa，至于使用哪个方案，还是要看使用场景的(公司规模、使用的语言、数据量等)</p>
<h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p><a href="http://activemq.apache.org/">ActiveMQ</a></p>
<ul>
<li>ActiveMQ 5 “Classic”: 实际上ActiveMQ Classic原来就叫ActiveMQ，是Apache开发的基于JMS 1.1的消息服务器，目前稳定版本号是5.x</li>
<li>ActiveMQ Artemis: ActiveMQ Artemis是由RedHat捐赠的HornetQ服务器代码的基础上开发的，目前稳定版本号是2.x。</li>
</ul>
<p>和ActiveMQ Classic相比，Artemis版的代码与Classic完全不同，并且，它支持JMS 2.0，使用基于Netty的异步IO，大大提升了性能。<br>此外，Artemis不仅提供了JMS接口，它还提供了AMQP接口，STOMP接口和物联网使用的MQTT接口。</p>
<p>官网上有这么一句话：</p>
<blockquote>
<p>There are currently two “flavors” of ActiveMQ available - the “classic” 5.x broker and the “next generation” Artemis broker. Once Artemis reaches a sufficient level of feature parity with the 5.x code-base it will become ActiveMQ 6. Initial migration documentation is available.</p>
</blockquote>
<p>翻译过来就是目前有两种“风格”的ActiveMQ可用-“经典”5.x代理和“下一代”Artemis代理。一旦Artemis与5.x代码基达到足够的特性奇偶校验级别，它将成为ActiveMQ6。</p>
<p>可以看到ActiveMQ目前属于转型期，如果是新项目的话，还是期待下ActiveMQ6的发布吧。</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a href="https://www.rabbitmq.com/">RabbitMQ</a> 是一个由Erlang语言开发的基于AMQP标准的开源实现，而Erlang语言天生具备高并发的特性，虽然懂的erlang的开发人员不多，无法进行定制化，<br>但RabbitMQ的社区十分活跃，可以解决开发过程中遇到的常见问题，而且提供的管理界面用起来十分方便，这对于中小型公司来说十分重要。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><a href="http://kafka.apache.org/">kafka</a> 是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），<br>常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p>
<p>如果是大数据领域或者有日志采集功能的，肯定是首选kafka </p>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>当然如果项目使用了阿里云的全家桶，可以试试阿里出品的 <a href="http://rocketmq.apache.org/">RocketMQ</a> (当然在2016年底已经贡献给了Apache，成为了Apache的一个顶级项目)<br>RocketMQ中文资料丰富，也得到了阿里各个系统的验证，对于一般的项目来说，直接拿来就可以用。<br>而且针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>最后补充一个<a href="https://redis.io/">Redis</a>，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。<br>对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。<br>实验表明：</p>
<pre><code>- 入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；
- 出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</code></pre>
<p>当项目中已经引入了Redis且数据量和并发量(其实一般公司的项目，并不会太大)不是非常大的话，也可以直接利用Redis的MQ功能来作为消息队列的中间件</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实各个方案都有其优点和使用场景：</p>
<ul>
<li>ActiveMQ Artemis：支持协议较多，所以项目需要支持不同语言不同协议(例如与物联网相关系统交互的MQTT协议)项目的消息队列，优先选用</li>
<li>RabbitMQ：官方提供管理页面，可以较简单的管理重复消息，所以如果没有定制化的需求，且吞吐量要求不是那么高(单机吞吐量万级以上)的，优先选用</li>
<li>RocketMQ: 阿里出品，如果会用到<strong>顺序消息、事务消息等</strong>，或者项目部署在阿里云中，使用了其他的阿里云的产品，不妨直接试试RocketMQ</li>
<li>Redis: 如果不想引入新的中间件(当然有利有弊,一旦挂了则缓存+消息队列都不可用了)，且对数据量要求不那么大的话，可以采用</li>
<li>Kafka: 基本上日志收集、消息系统、活动追踪、运营指标、流式处理、时间源等都是用kafka，阿里云、腾讯云都推出了Kafka的云服务，可直接在云服务商直接开通使用</li>
</ul>
<p>关于部署，日常开发中建议直接使用docker安装，线上的话如果资金到位建议使用云服务提供的MQ服务，能省去不少事情(尤其是维护成本)</p>
<p><img src="%E9%98%BF%E9%87%8C%E4%BA%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88.png" alt="阿里云提供的消息队列方案"></p>
<p><img src="%E8%85%BE%E8%AE%AF%E4%BA%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88.png" alt="腾讯云提供的消息队列方案"></p>
<p><img src="%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88.png" alt="华为云提供的消息队列方案"></p>
<h1 id="如何保证可靠性"><a href="#如何保证可靠性" class="headerlink" title="如何保证可靠性"></a>如何保证可靠性</h1><p><img src="%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E6%96%B9%E6%A1%88.png" alt="保证消息可靠性的方案"></p>
<p>如何保证消息队列是高可用的？</p>
<p>如何保证消息不被重复消费？</p>
<p>如何保证消费的可靠性传输?</p>
<p>如何保证消息的顺序性？ 推荐RocketMQ</p>
<p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时怎么解决？</p>
<p><a href="https://blog.csdn.net/qq_36236890/article/details/81174504">消息队列常见问题和解决方案消息队列常见问题和解决方案</a> 这篇文章写的不错，暂且收藏了</p>
<blockquote>
<p>不过在尝试解决这些问题时有必要明白一点，其实小公司业务量不大，并发量不高的情况下这些问题是几乎不会发生的……<br>即使偶尔出现，开发人员手动修复数据处理就好。所以可结合公司实际业务场景看有没有必要解决这些问题。<br>不过对于技术人员来说，还是有必要了解一下。</p>
</blockquote>
<h1 id="Spring-Boot中的集成使用"><a href="#Spring-Boot中的集成使用" class="headerlink" title="Spring Boot中的集成使用"></a>Spring Boot中的集成使用</h1><p>– 未完，待整理 –</p>
<h2 id="RabbitMQ-的三种类型的交换器"><a href="#RabbitMQ-的三种类型的交换器" class="headerlink" title="RabbitMQ 的三种类型的交换器"></a>RabbitMQ 的三种类型的交换器</h2><p><em>RabbitMQ 使用 Exchange(交换机)和 Queue(队列)来实现消息队列</em></p>
<h3 id="广播式交换器类型-Fanout"><a href="#广播式交换器类型-Fanout" class="headerlink" title="广播式交换器类型(Fanout)"></a>广播式交换器类型(Fanout)</h3><p>该类交换器不分析所接收到消息中的 Routing Key，默认将消息转发到所有与该交换器绑定的队列中去</p>
<p><img src="rabbitmq-fanout.jpg" alt="Fanout"></p>
<h3 id="直接式交换器类型-Direct"><a href="#直接式交换器类型-Direct" class="headerlink" title="直接式交换器类型(Direct)"></a>直接式交换器类型(Direct)</h3><p>该类交换器需要精确匹配 Routing Key 与 Binding Key，如消息的 Routing Key = Cloud，那么该条消息只能被转发至 Binding Key = Cloud 的消息队列中去</p>
<p><img src="rabbitmq-direct.jpg" alt="Direct"></p>
<h3 id="主题式交换器-Topic-Exchange"><a href="#主题式交换器-Topic-Exchange" class="headerlink" title="主题式交换器(Topic Exchange)"></a>主题式交换器(Topic Exchange)</h3><p>该类交换器通过消息的 Routing Key 与 Binding Key 的模式匹配，将消息转发至所有符合绑定规则的队列中。</p>
<p>Binding Key 支持通配符，其中“*”匹配一个词组，“#”匹配多个词组(包括零个)</p>
<p><img src="rabbitmq-topic-exchange.jpg" alt="Topic Exchange"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成flyway实现数据库版本控制</title>
    <url>/20201209/java/springboot/933cf8db/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常项目开发中，代码可以使用GIT/SVN 来进行版本控制，而数据库的更新却需要人工进行干预。</p>
<p>之前我在项目开发时会根据项目版本手工创建好每次版本迭代会更新的sql文件，发布版本时先在线上执行下对应sql，然后再更新应用版本。在研究自动构建时就想有没有一种技术/框架可以将这种手工行为变为自动。</p>
<p>偶然的机会在网上搜索到<a href="https://flywaydb.org/">flyway-一个能对数据库变更做版本控制的工具</a>，通过在项目中集成就可以在每次版本更新时自动执行对应版本sql了</p>
<p>Flyway具有以下优点：</p>
<ul>
<li>简单 非常容易安装和学习，同时迁移的方式也很容易被开发者接受。</li>
<li>专一 Flyway 专注于搞数据库迁移、版本控制而并没有其它副作用。</li>
<li>强大 专为持续交付而设计。让Flyway在应用程序启动时迁移数据库。</li>
</ul>
<a id="more"></a>

<h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p><strong>某个环境使用了 flyway 控制版本之后，就不要再手动增删改表了</strong></p>
<h2 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h2><p>如果是新的项目，直接通过Idea选择Spring Initializr创建SpringBoot项目并勾选[Flyway Migration]即可：</p>
<p><img src="flyway.png" alt="flyway"></p>
<p>可以发现scr/resources下多了db/migration文件夹，这个文件夹就是提供flyway使用的</p>
<ul>
<li>首先先配置好数据库相关配置，这里为了演示方便使用了H2(实际项目更多使用的是MySQL)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: org.h2.Driver</span><br><span class="line">    # h2  数据库 持久化到磁盘C:&#x2F;h2 mysql模式</span><br><span class="line">    url: jdbc:h2:file:C:&#x2F;h2&#x2F;test;MODE&#x3D;MySQL;DATABASE_TO_LOWER&#x3D;TRUE</span><br><span class="line">    username: root</span><br><span class="line">    password: root123</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      enabled: true</span><br><span class="line">      settings:</span><br><span class="line">        trace: true</span><br><span class="line">        web-allow-others: true</span><br><span class="line">      path: &#x2F;h2-console</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据库相关配置这边就不多解释了</p>
</blockquote>
<ul>
<li>接着需要在application.yml中对flyway进行一些配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"></span><br><span class="line">  # flyway 配置</span><br><span class="line">  flyway:</span><br><span class="line">    # 启用或禁用 flyway 正式环境才开启</span><br><span class="line">    enabled: true</span><br><span class="line">    # 禁用数据库清理 flyway 的 clean 命令会删除指定 schema 下的所有 table, 生产务必禁掉</span><br><span class="line">    clean-disabled: true</span><br><span class="line">    # SQL 脚本的目录,多个路径使用逗号分隔 默认值 classpath:db&#x2F;migration</span><br><span class="line">    locations: classpath:db&#x2F;migration</span><br><span class="line">    #  metadata 版本控制信息表 默认 flyway_schema_history,建议后缀指定为当前项目名称</span><br><span class="line">    table: flyway_schema_history_demo</span><br><span class="line">    # 如果没有 flyway_schema_history 这个 metadata 表， 在执行 flyway migrate 命令之前, 必须先执行 flyway baseline 命令</span><br><span class="line">    # 设置为 true 后 flyway 将在需要 baseline 的时候, 自动执行一次 baseline。 针对非空数据库是否默认调用基线版本,为空的话默认会调用基线版本</span><br><span class="line">    baseline-on-migrate: true</span><br><span class="line">    # 指定 baseline 的版本号,默认值为 1, 低于该版本号的 SQL 文件, migrate 时会被忽略</span><br><span class="line">    baseline-version: 1</span><br><span class="line">    # 字符编码 默认 UTF-8</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    # 是否允许不按顺序迁移 开发建议 true  生产建议 false</span><br><span class="line">    out-of-order: false</span><br><span class="line">    # 需要 flyway 管控的 schema list,这里我们配置为flyway  缺省的话, 使用spring.datasource.url 配置的那个 schema,</span><br><span class="line">    # 可以指定多个schema, 但仅会在第一个schema下建立 metadata 表, 也仅在第一个schema应用migration sql 脚本.</span><br><span class="line">    # 但flyway Clean 命令会依次在这些schema下都执行一遍. 所以 确保生产 spring.flyway.clean-disabled 为 true</span><br><span class="line">    schemas: flyway</span><br><span class="line">    # 执行迁移时是否自动调用验证   当你的 版本不符合逻辑 比如 你先执行了 DML 而没有 对应的DDL 会抛出异常</span><br><span class="line">    validate-on-migrate: true</span><br></pre></td></tr></table></figure>

<ul>
<li>编写SQL初始化脚本</li>
</ul>
<p>在db/migration文件夹下新建V1.0.1__init.sql文件(必须以Vxx__开头，后面根据自己的规则编写即可)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 示例</span><br><span class="line">DROP TABLE IF EXISTS users;</span><br><span class="line"></span><br><span class="line">CREATE TABLE users</span><br><span class="line">(</span><br><span class="line">    id BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,</span><br><span class="line">    name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,</span><br><span class="line">    age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,</span><br><span class="line">    email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,</span><br><span class="line">    create_time DATETIME NULL DEFAULT NULL COMMENT &#39;创建日期&#39;,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO users (id, &#96;name&#96;, age, email, create_time) VALUES</span><br><span class="line">(1, &#39;Jone&#39;, 18, &#39;jone@163.com&#39;, &#39;2020-02-09 08:20:00&#39;),</span><br><span class="line">(2, &#39;Jack&#39;, 20, &#39;jack@163.com&#39;, &#39;2020-02-10 11:00:00&#39;),</span><br><span class="line">(3, &#39;Tom&#39;, 28, &#39;tom@163.com&#39;, &#39;2020-03-11 06:10:00&#39;),</span><br><span class="line">(4, &#39;Sandy&#39;, 21, &#39;sandy@163.com&#39;, &#39;2020-04-12 05:30:00&#39;),</span><br><span class="line">(5, &#39;Billie&#39;, 24, &#39;billie@163.com&#39;, &#39;2020-05-13 03:40:00&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>启动项目</li>
</ul>
<p>可以发现数据库中多了users表和一些数据，同时多了一个flyway数据库里有一个flyway_schema_history_demo表(这些都是在application.yml中配置的)，而这个表就是flyway用来控制sql版本的。</p>
<ul>
<li>后续更新</li>
</ul>
<p>后续只要根据SQL规则编写新的SQL即可达到每次部署Spring Boot项目时自动更新相应sql了。(需注意flyway社区版目前没有回滚机制，故每次更新时有条件的还是备份下原有数据库，防止意外情况)</p>
<blockquote>
<p>测试环境存在经常手动修改表增加表的情况的话，建议关闭flyway，因为在手动执行SQL执行之后再执行flyway中的SQL会导致执行失败的情况，当开发稳定后再将需要的SQL语句填入到flyway指定的sql中</p>
</blockquote>
<h3 id="SQL文件编写规则"><a href="#SQL文件编写规则" class="headerlink" title="SQL文件编写规则"></a>SQL文件编写规则</h3><p>db/migration文件夹的SQL语句命名需要遵从一定的规范，否则运行的时候flyway会报错。命名规则主要有两种：</p>
<ul>
<li><p>用于版本升级, 每个版本有唯一的版本号并只能执行一次。以大写的”V”开头，后面跟上”0~9”数字的组合,数字之间可以用“.”或者下划线”_”分割开，然后再以两个下划线分割，其后跟文件名称，最后以.sql结尾。比如，V2.1.5__create_user_ddl.sql、V4.1_2__add_user_dml.sql。</p>
</li>
<li><p>可重复运行的SQL，以大写的“R”开头，后面再以两个下划线分割，其后跟文件名称，最后以.sql结尾。比如，R__truncate_user_dml.sql。Flyway检测到该类型SQL 脚本的 checksum 有变动, Flyway 就会重新应用该脚本. 它并不用于版本更新</p>
</li>
</ul>
<blockquote>
<p>V开头的SQL执行优先级要比R开头的SQL优先级高。</p>
</blockquote>
<blockquote>
<p>另外还有一种：以Ux__开头的SQL，Undo用于撤销具有相同版本的版本化迁移带来的影响。但是该回滚过于粗暴，一般不推荐使用(另外这也是收费版本才支持的)</p>
</blockquote>
<p>Flyway 采用左对齐原则比较两个SQL文件的先后顺序, 缺位用 0 代替：</p>
<ul>
<li>1.0.1.1 比 1.0.1 版本高</li>
<li>1.0.10 比 1.0.9.4 版本高</li>
<li>1.0.10 和 1.0.010 版本号一样高, 每个版本号部分的前导 0 会被忽略</li>
</ul>
<p><strong>除了直接在db/migration文件夹中创建sql外，还可以使用自定义的文件夹来对版本进行分类(如db/migration/1.0.0/V1__create_users_by_jonesun.sql)，不会影响flyway对SQL的识别和运行</strong></p>
<h2 id="已有项目集成"><a href="#已有项目集成" class="headerlink" title="已有项目集成"></a>已有项目集成</h2><p>已有项目(Spring Boot项目)想要使用Flyway的话：</p>
<ul>
<li>pom.xml加入flyway引用:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.flywaydb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flyway-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>scr/resources下新建db/migration文件夹(注意是先新建db文件夹再新建migration文件夹)</li>
<li>同上面的新项目一样在application.yml中对flyway进行配置</li>
<li>在db/migration文件夹中增加一个名为 V1.0.0__init.sql的文件，内容为空，用于占位</li>
<li>在db/migration文件夹中按照规则新建Vxxx__xxx.sql即可</li>
</ul>
<p>一个好的习惯：先 dump 一份所有环境中当前项目最新版本的表结构，在 resources/db目录中创建一个 base_init.sql 文件，将最新版本的 DDL 以及需要初始化的数据放到这个文件中，这个 sql 文件后期就不要做任何修改</p>
<p>如果需要部署到新的环境，则只需要执行base_init.sql即可，其他版本的交给 flyway 就可以了</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>因为flyway针对Vxx__.sql在项目启动后只会执行一次，故开发环境下要不先关闭flyway, 要不sql编写后启动过项目后就不要再变化了，不然会报异常Validate failed，当然如果出现此类异常需要到flyway_schema_history_demo(表名随自己项目的配置)删除对应记录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE IGNORE FROM flyway_schema_history_demo WHERE success &#x3D; 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>flyway也提供了maven插件便于开发调试使用，有兴趣可以了解下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.flywaydb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flyway-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<p>与flyway类似的还有<a href="https://www.liquibase.org/">Liquibase</a>。对应的flyway和Liquibase都有收费版提供更强大的功能。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成log日志</title>
    <url>/20200724/java/springboot/33ed675a/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日志是开发过程中必不可少的模块，出现异常后可以通过查看日志看排查原因</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h2><blockquote>
<p>JDK Logging</p>
</blockquote>
<p>JDK提供的日志框架，由于自身有些局限性，故不太流行</p>
<blockquote>
<p>Commons Logging</p>
</blockquote>
<p>Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons<br>Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Loggin</p>
<blockquote>
<p>Log4j</p>
</blockquote>
<p>Apache的提供的一种日志实现，现已不推荐使用</p>
<blockquote>
<p>SLF4J</p>
</blockquote>
<p>SLF4J类似于Commons Logging，也是一个日志接口，比Commons Logging更加好用，现在流行程度也更高</p>
<blockquote>
<p>Logback</p>
</blockquote>
<p>Logback是由log4j创始人设计的另一个开源日志组件，性能比Log4j要高很多</p>
<blockquote>
<p>Log4j2</p>
</blockquote>
<p>Log4j的重构版，性能提升很多，尤其在多线程环境下，性能也高于Logback</p>
<p><strong>一般使用SLF4J提供的接口，引入Logback或者Log4j2</strong></p>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>SpringBoot2默认已经集成了logback，如果不想修改可直接在resource中新建logback.xml进行配置即可。</p>
<p>不过一般都推荐使用log4j2(SpringBoot2高版本已经不再支持log4j)，故可以在pom.xml中修改引用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 去掉logback配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入log4j2依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  //如果没有引入web模块，则</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在resource中新建log4j2-spring.xml(或者log4j2.xml)进行配置即可</p>
<p>喜欢yml格式的话，加入支持yml格式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 支持yml格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在resources目录下新建log4j2.yml进行配置(推荐使用yml格式)</p>
<blockquote>
<p>相比与其他的日志系统，log4j2丢数据这种情况少；disruptor技术，在多线程环境下，性能高于logback等10倍以上；利用jdk1.5并发的特性，减少了死锁的发生</p>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>需要注意的时，一般推荐使用slf4j(这里使用了设计模式中的外观模式或者叫门面模式),方便灵活的替换日志组件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TestService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;xxxxxxxxxxxxxxx&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，只会输出大于或等于设置级别的内容</p>
</blockquote>
<h2 id="配合lombok"><a href="#配合lombok" class="headerlink" title="配合lombok"></a>配合lombok</h2><p>如果项目使用了lombok插件，则引用可直接在类上注解即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Strin[] args)</span> </span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;Something else is wrong here&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h1><p>SLF4J的日志接口可以这样来拼接字符串:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure>

<h2 id="使用日志的好处"><a href="#使用日志的好处" class="headerlink" title="使用日志的好处"></a>使用日志的好处</h2><p>如果使用日志有很多好处：</p>
<ul>
<li>可以设置输出样式，避免自己每次都写”ERROR: “ + var；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以输出到不同的目的地：<ul>
<li>console：输出到屏幕；</li>
<li>file：输出到文件；</li>
<li>socket：通过网络输出到远程计算机；</li>
<li>jdbc：输出到数据库</li>
</ul>
</li>
<li>……</li>
</ul>
<p>日常开发中有些童鞋在跟进bug时会习惯性的使用**System.out.println()**来打印log日志，然后再删除掉，下次再出现问题再打印，可以自己考虑哪个更好</p>
<p><a href="https://logging.apache.org/log4j/2.x/manual/layouts.html">log42j官方配置参考</a></p>
<p><a href="https://www.baeldung.com/spring-boot-logging">springboot推荐配置</a></p>
<blockquote>
<p>控制台打印的日志配上颜色</p>
</blockquote>
<p>在配置文件的PatternLayout标签里指定disableAnsi=”false” noConsoleNoAnsi=”false”</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">disableAnsi</span>=<span class="string">&quot;false&quot;</span> <span class="attr">noConsoleNoAnsi</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">pattern</span>=<span class="string">&quot;%style&#123;%d&#123;ISO8601&#125;&#125; %highlight&#123;%-5level &#125;&#123;ERROR=Bright RED, WARN=Bright Yellow, INFO=Bright Green, DEBUG=Bright Cyan, TRACE=Bright White&#125;[%style&#123;%t&#125;&#123;bright,blue&#125;] %l: %msg%n%style&#123;%throwable&#125;&#123;red&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>动态设置日志保存路径</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_HOME&quot;</span>&gt;</span>$&#123;sys:user.dir&#125;<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_FOLDER&quot;</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">disableAnsi</span>=<span class="string">&quot;false&quot;</span> <span class="attr">noConsoleNoAnsi</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">pattern</span>=<span class="string">&quot;%highlight&#123;%d [%t] %-5level %l: %msg%n%throwable&#125;&#123;ERROR=Bright RED, WARN=Bright Yellow, INFO=Normal, DEBUG=Bright Blue, TRACE=Bright White&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFile&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">fileName</span>=<span class="string">&quot;$&#123;LOG_HOME&#125;/$&#123;FILE_FOLDER&#125;/logs/logger-log4j2.log&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;LOG_HOME&#125;/$&#123;FILE_FOLDER&#125;/logs/$$&#123;date:yyyy-MM&#125;/logger-log4j2-%d&#123;-dd-MMMM-yyyy&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %p %C&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- rollover on startup, daily and when the file reaches</span></span><br><span class="line"><span class="comment">                    10 MegaBytes --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">OnStartupTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10 MB&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- LOG everything at INFO level --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- LOG &quot;com.jonesun*&quot; at TRACE level --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.jonesun&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="异步日志"><a href="#异步日志" class="headerlink" title="异步日志"></a>异步日志</h2><blockquote>
<p>官方建议一般程序员查看的日志改成异步方式，一些运营日志改成同步。日志异步输出的好处在于，使用单独的进程来执行日志打印的功能，可以提高日志执行效率，减少日志功能对正常业务的影响。</p>
</blockquote>
<p>Log4j2中的异步日志实现方式有两种:</p>
<ul>
<li>AsyncAppender采用了ArrayBlockingQueue来保存需要异步输出的日志事件</li>
<li>AsyncLogger则使用了Disruptor框架来实现高吞吐</li>
</ul>
<h3 id="AsyncAppender"><a href="#AsyncAppender" class="headerlink" title="AsyncAppender"></a>AsyncAppender</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!-- AsyncAppender配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">&quot;asyncTest&quot;</span> <span class="attr">blocking</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;asyncTest&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="AsyncLogger"><a href="#AsyncLogger" class="headerlink" title="AsyncLogger"></a>AsyncLogger</h3><p>AsyncLogger需要加载disruptor-3.0.0.jar或者更高的版本(pom.xml)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j2异步日志需要加载disruptor-3.0.0.jar或者更高的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件loggers改为(或者新增Appender再配置给异步):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &amp;lt;!&amp;ndash; LOG everything at INFO level &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;Root level=&quot;info&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;AppenderRef ref=&quot;Console&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;AppenderRef ref=&quot;RollingFile&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/Root&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- LOG &quot;com.baeldung*&quot; at TRACE level --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;com.jonesun&quot;</span> <span class="attr">level</span>=<span class="string">&quot;trace&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">asyncRoot</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">asyncRoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="高阶"><a href="#高阶" class="headerlink" title="高阶"></a>高阶</h1><p>随着业务量的提高，普通日志已经满足不了需求，此时可以引入Elasticsearch，使用<a href="/20200721/java/springboot/5316e6b4">ELK</a><br>来搭建日线日志系统，，这几个组件都挺能抢内存的，elasticsearch默认就要2g内存，线上机器性能不够的话，还是乖乖使用原始log收集</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成swagger</title>
    <url>/20201010/java/springboot/a5de5e84/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://swagger.io/">Swagger</a> 是一个规范和完整的文档框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务文档</p>
<h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>swagger3.0.0简化了配置，故推荐直接使用最新版, 如果有还在用2.x版本的请参考时注意区分</p>
<blockquote>
<p>pom.xml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以了，不用像2.x版本需要引入springfox-swagger和springfox-swagger-ui</p>
<blockquote>
<p>Swagger3Config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Swagger3Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        &#x2F;&#x2F;返回文档摘要信息</span><br><span class="line">        return new Docket(DocumentationType.OAS_30)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">&#x2F;&#x2F;                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(Operation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;生成接口信息，包括标题、联系人等</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;Swagger3接口文档&quot;)</span><br><span class="line">                .description(&quot;如有疑问，请联系开发工程师&quot;)</span><br><span class="line">                .contact(new Contact(&quot;JoneSun&quot;, &quot;https:&#x2F;&#x2F;jonesun.github.io&#x2F;&quot;, &quot;sunr922@163.com&quot;))</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意只有controller层中标注@Operation注解的才会显示，同样可以@ApiOperation或者其他注解</p>
<blockquote>
<p>UserController</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api(tags &#x3D; &quot;用户管理接口&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Operation(summary &#x3D; &quot;获取用户列表&quot;)</span><br><span class="line">    @GetMapping(value&#x3D;&quot;&#x2F;&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserList() &#123;</span><br><span class="line">        return userService.selectList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Operation(summary &#x3D; &quot;新增用户&quot;)</span><br><span class="line">    @PostMapping(value&#x3D;&quot;&#x2F;&quot;)</span><br><span class="line">    public String postUser(@ModelAttribute User user) &#123;</span><br><span class="line">        userService.insert(user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Operation(summary &#x3D; &quot;获取用户&quot;)</span><br><span class="line">    @GetMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public User getUser(@PathVariable Long id) &#123;</span><br><span class="line">        return userService.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Operation(summary &#x3D; &quot;更新用户&quot;)</span><br><span class="line">    @PutMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123;</span><br><span class="line">        user.setId(id);</span><br><span class="line">        userService.updateById(user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Operation(summary &#x3D; &quot;删除用户&quot;)</span><br><span class="line">    @DeleteMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123;</span><br><span class="line">        userService.deleteById(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便完成了swagger3的简单配置，启动服务打开地址：项目地址+/swagger-ui/index.html</p>
<blockquote>
<p>有人说需要在主类上加入@EnableOpenApi注解，但不加好像就可以用</p>
</blockquote>
<h2 id="关闭swagger"><a href="#关闭swagger" class="headerlink" title="关闭swagger"></a>关闭swagger</h2><p>application-xx.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">springfox:</span><br><span class="line">  documentation:</span><br><span class="line">  # 一键关闭</span><br><span class="line">    enabled: false</span><br><span class="line">    swagger-ui:</span><br><span class="line">    # 控制ui的展示</span><br><span class="line">      enabled: false</span><br></pre></td></tr></table></figure>

<h2 id="配合Security"><a href="#配合Security" class="headerlink" title="配合Security"></a>配合Security</h2><p>WebSecurityConfig加入白名单即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] SWAGGER_WHITELIST &#x3D; &#123;</span><br><span class="line">        &quot;&#x2F;swagger-ui.html&quot;,</span><br><span class="line">        &quot;&#x2F;swagger-ui&#x2F;*&quot;,</span><br><span class="line">        &quot;&#x2F;swagger-resources&#x2F;**&quot;,</span><br><span class="line">        &quot;&#x2F;v2&#x2F;api-docs&quot;,</span><br><span class="line">        &quot;&#x2F;v3&#x2F;api-docs&quot;,</span><br><span class="line">        &quot;&#x2F;webjars&#x2F;**&quot;</span><br><span class="line">&#125;;</span><br><span class="line">httpSecurity.cors().antMatchers(SWAGGER_WHITELIST).permitAll();</span><br></pre></td></tr></table></figure>

<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>现在很多项目都使用前后端分离的方式，使用了JWT这样的认证方式(在Header构造一个token), swagger支持在config中加入全局参数配置</p>
<blockquote>
<p>方式一</p>
</blockquote>
<p>每次请求的时候，手动输入token globalRequestParameters</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swagger3Config</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回文档摘要信息</span><br><span class="line">        return new Docket(DocumentationType.OAS_30)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">&#x2F;&#x2F;                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(Operation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .globalRequestParameters(globalRequestParameters());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private List&lt;RequestParameter&gt; globalRequestParameters() &#123;</span><br><span class="line">        RequestParameterBuilder parameterBuilder &#x3D; new RequestParameterBuilder()</span><br><span class="line">                .in(ParameterType.HEADER).name(&quot;Authorization&quot;)</span><br><span class="line">                .required(false)</span><br><span class="line">                .query(param -&gt; param.model(model -&gt; model.scalarModel(ScalarType.STRING)));</span><br><span class="line">        return Collections.singletonList(parameterBuilder.build());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式二</p>
</blockquote>
<p>全局的Auth认证配置 securitySchemes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swagger3Config</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回文档摘要信息</span><br><span class="line">        return new Docket(DocumentationType.OAS_30)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">&#x2F;&#x2F;                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(Operation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .securitySchemes(security());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityScheme&gt; security() &#123;</span><br><span class="line">        ApiKey apiKey &#x3D; new ApiKey(&quot;Authorization&quot;, &quot;Authorization&quot;, &quot;header&quot;);</span><br><span class="line">        return Collections.singletonList(apiKey);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>浏览器打开页面，点击右侧的Authorize按钮即可弹框。填入token即可</p>
<p><img src="auth.png" alt="auth"></p>
<h2 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api：用在请求的类上，表示对类的说明</span><br><span class="line">    tags&#x3D;&quot;说明该类的作用，可以在UI界面上看到的注解&quot;</span><br><span class="line">    value&#x3D;&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot;</span><br><span class="line"></span><br><span class="line">@ApiOperation：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">    value&#x3D;&quot;说明方法的用途、作用&quot;</span><br><span class="line">    notes&#x3D;&quot;方法的备注说明&quot;</span><br><span class="line"></span><br><span class="line">@ApiImplicitParams：用在请求的方法上，表示一组参数说明</span><br><span class="line">    @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        required：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：@RequestHeader</span><br><span class="line">            · query --&gt; 请求参数的获取：@RequestParam</span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</span><br><span class="line">            · div（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认String，其它值dataType&#x3D;&quot;Integer&quot;       </span><br><span class="line">        defaultValue：参数的默认值</span><br><span class="line"></span><br><span class="line">@ApiResponses：用在请求的方法上，表示一组响应</span><br><span class="line">    @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如400</span><br><span class="line">        message：信息，例如&quot;请求参数没填好&quot;</span><br><span class="line">        response：抛出异常的类</span><br><span class="line"></span><br><span class="line">@ApiModel：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用@RequestBody这样的场景，</span><br><span class="line">            请求参数无法使用@ApiImplicitParam注解进行描述的时候）</span><br><span class="line">    @ApiModelProperty：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用swagger要注意</p>
</blockquote>
<ul>
<li>在生产环境中必须关闭swagger</li>
<li>它本身只用于前后端工程师之间的沟通,可以专门使用一台内部服务器来展示ui供访问</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>springdoc-openapi-ui，，它自动引入Swagger UI用来创建API文档，也比较方便</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成websocket</title>
    <url>/20200904/java/springboot/11360df2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>HTTP 协议有一个缺陷：通信只能由客户端发起</p>
</blockquote>
<p>HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。可以替代长轮询，用于对实时性要求比较高的场景:</p>
<ul>
<li><p>聊天室</p>
</li>
<li><p>服务端消息实时推送</p>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>SpringBoot中使用WebSocket非常简单:</p>
<ol>
<li>pom.xml中加入引用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建WebSocketConfig配置类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果直接使用springboot的内置容器，而不是使用独立的servlet容器，就要注入ServerEndpointExporter，外部容器则不需要。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">        return new ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义接受和处理消息的处理类</li>
</ol>
<p>注意@ServerEndpoint的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ServerEndpoint(&quot;&#x2F;websocket&#x2F;&#123;username&#125;&quot;)</span><br><span class="line">public class ChatRoomServerEndpoint &#123;</span><br><span class="line"></span><br><span class="line">    public static final Map&lt;String, Session&gt; ONLINE_USER_SESSIONS &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @OnOpen</span><br><span class="line">    public void openSession(@PathParam(&quot;username&quot;) String username, Session session) &#123;</span><br><span class="line">        ONLINE_USER_SESSIONS.put(username, session);</span><br><span class="line">        String message &#x3D; &quot;[&quot; + username + &quot;] 客户端信息！&quot;;</span><br><span class="line">        sendMessageAll(&quot;服务器连接成功！&quot;);</span><br><span class="line">        sendMessage(session, &quot;&quot;);</span><br><span class="line">        System.out.println(&quot;连接成功&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(@PathParam(&quot;username&quot;) String username, String message) &#123;</span><br><span class="line">        System.out.println(&quot;服务器收到：&quot; + &quot;[&quot; + username + &quot;] : &quot; + message);</span><br><span class="line">        sendMessageAll(&quot;我已收到你的消息》》[&quot; + username + &quot;] : &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnClose</span><br><span class="line">    public void onClose(@PathParam(&quot;username&quot;) String username, Session session) &#123;</span><br><span class="line">        &#x2F;&#x2F;当前的Session 移除</span><br><span class="line">        ONLINE_USER_SESSIONS.remove(username);</span><br><span class="line">        &#x2F;&#x2F;并且通知其他人当前用户已经断开连接了</span><br><span class="line">        sendMessageAll(&quot;[&quot; + username + &quot;] 断开连接！&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnError</span><br><span class="line">    public void onError(Session session, Throwable throwable) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 单用户推送</span><br><span class="line">    public void sendMessage(Session session, String message) &#123;</span><br><span class="line">        if (session &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final RemoteEndpoint.Basic basic &#x3D; session.getBasicRemote();</span><br><span class="line">        if (basic &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            basic.sendText(message);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(&quot;sendMessage IOException &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 全用户推送</span><br><span class="line">    public void sendMessageAll(String message) &#123;</span><br><span class="line">        ONLINE_USER_SESSIONS.forEach((sessionId, session) -&gt; sendMessage(session, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就实现了websocket server的集成，后面就是使用不同的技术实现客户端了(html、android等)</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>当然可以编写java版的用于测试连接，这里我们使用Java-WebSocket：</p>
<ol>
<li>pom.xml文件中添加引用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.java-websocket&#x2F;Java-WebSocket --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.java-websocket&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Java-WebSocket&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写测试类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(Runner.class)</span><br><span class="line">class WebSocketClientTests &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger log &#x3D; LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    WebSocketClient webSocketClient;</span><br><span class="line">    @Test</span><br><span class="line">    void testClient() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            webSocketClient &#x3D; new WebSocketClient(new URI(&quot;ws:&#x2F;&#x2F;localhost:8080&#x2F;websocket&#x2F;test&quot; + System.currentTimeMillis()),new Draft_6455()) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onOpen(ServerHandshake handshakedata) &#123;</span><br><span class="line">                    log.info(&quot;[websocket] 连接成功&quot;);</span><br><span class="line">                    webSocketClient.send(&quot;你好，我是客户端1111&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onMessage(String message) &#123;</span><br><span class="line">                    log.info(&quot;[websocket] 收到消息&#x3D;&#123;&#125;&quot;,message);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onClose(int code, String reason, boolean remote) &#123;</span><br><span class="line">                    log.info(&quot;[websocket] 退出连接&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(Exception ex) &#123;</span><br><span class="line">                    log.info(&quot;[websocket] 连接错误&#x3D;&#123;&#125;&quot;,ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            webSocketClient.connect();</span><br><span class="line"></span><br><span class="line">            while (!webSocketClient.isClosed()) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            log.info(&quot;[主程序] 退出&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行SpringBoot服务端和测试类，即可看到效果</li>
</ol>
<h2 id="连接地址说明"><a href="#连接地址说明" class="headerlink" title="连接地址说明"></a>连接地址说明</h2><blockquote>
<p>ws://localhost:8080/websocket/xxx</p>
</blockquote>
<p>客户端需使用websocket的协议ws，由于是用SpringBoot集成的websocket，故url地址与正常的http的类似，后面的websocket/test是取决于@ServerEndpoint的定义(源码里为@ServerEndpoint(“/websocket/{username}”)，故客户端可以使用websocket/xxx),不同ServerEndpoint处理不同策略</p>
<ul>
<li>如果SpringBoot的application.yml指定了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: &#x2F;spring-websocket</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure>

<p>则此时客户端连接的url应改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws:&#x2F;&#x2F;localhost:8888&#x2F;spring-websocket&#x2F;websocket&#x2F;xxx</span><br></pre></td></tr></table></figure>

<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul>
<li><p>重连心跳机制</p>
</li>
<li><p>使用netty：Servlet的线程模型并不适合大规模的长链接。基于NIO的Netty等框架更适合处理WebSocket长链接</p>
</li>
<li><p>加入ssl时的处理</p>
</li>
<li><p>与HTTP/2推送的不同-HTTP/2 只能推送静态资源，无法推送指定的信息</p>
</li>
<li><p>fetch-下一代的免刷新web交互手段</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot应用整合ELK实现日志收集</title>
    <url>/20200721/java/springboot/5316e6b4/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ELK：Elasticsearch、Logstash、Kibana,组合起来可以搭建线上日志系统</p>
<h2 id="各服务作用"><a href="#各服务作用" class="headerlink" title="各服务作用"></a>各服务作用</h2><ul>
<li>Elasticsearch:用于存储收集到的日志信息；</li>
<li>Logstash:用于收集日志，SpringBoot应用整合了Logstash以后会把日志发送给Logstash,- Logstash再把日志转发给Elasticsearch；</li>
<li>Kibana:通过Web端的可视化界面来查看日志</li>
</ul>
<a id="more"></a>

<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><ol>
<li><p>安装docker与Docker Compose</p>
</li>
<li><p>安装Elasticsearch</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:6.4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Logstash </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull logstash:6.4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Kibana </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull kibana:6.4.0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="编写-docker-compose-yml"><a href="#编写-docker-compose-yml" class="headerlink" title="编写 docker-compose.yml"></a>编写 docker-compose.yml</h1><pre><code>在SpringBoot项目中的scr/main/docker/docker-compose.yml编写</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: elasticsearch:6.4.0</span><br><span class="line">    container_name: elasticsearch</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;cluster.name&#x3D;elasticsearch&quot; #设置集群名称为elasticsearch</span><br><span class="line">      - &quot;discovery.type&#x3D;single-node&quot; #以单一节点模式启动</span><br><span class="line">      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; #设置使用jvm内存大小</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">  kibana:</span><br><span class="line">    image: kibana:6.4.0</span><br><span class="line">    container_name: kibana</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch #kibana在elasticsearch启动之后再启动</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;elasticsearch.hosts&#x3D;http:&#x2F;&#x2F;es:9200&quot; #设置访问elasticsearch的地址</span><br><span class="line">    ports:</span><br><span class="line">      - 5601:5601</span><br><span class="line">  logstash:</span><br><span class="line">    image: logstash:6.4.0</span><br><span class="line">    container_name: logstash</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;:&#x2F;configdir</span><br><span class="line">    command: logstash -f &#x2F;configdir&#x2F;logstash-springboot.conf</span><br><span class="line">logstash.conf #挂载logstash的配置文件</span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch #kibana在elasticsearch启动之后再启动</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">    ports:</span><br><span class="line">      - 4560:4560</span><br></pre></td></tr></table></figure>

<h1 id="编写-logstash-springboot-conf"><a href="#编写-logstash-springboot-conf" class="headerlink" title="编写 logstash-springboot.conf"></a>编写 logstash-springboot.conf</h1><pre><code>在SpringBoot项目中的scr/main/docker/logstash-springboot.conf编写:</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;192.168.31.13&quot;</span><br><span class="line">    port &#x3D;&gt; 4560</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts &#x3D;&gt; &quot;es:9200&quot;</span><br><span class="line">    index &#x3D;&gt; &quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>cmd切换到docker文件夹下,执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h1 id="安装json-lines插件"><a href="#安装json-lines插件" class="headerlink" title="安装json_lines插件"></a>安装json_lines插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入logstash容器</span><br><span class="line">docker exec -it logstash &#x2F;bin&#x2F;bash</span><br><span class="line"># 进入bin目录</span><br><span class="line">cd &#x2F;bin&#x2F;</span><br><span class="line"># 安装插件</span><br><span class="line">logstash-plugin install logstash-codec-json_lines</span><br><span class="line"># 退出容器</span><br><span class="line">exit</span><br><span class="line"># 重启logstash服务</span><br><span class="line">docker restart logstash</span><br></pre></td></tr></table></figure>

<h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><p>浏览器打开</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:5601&#x2F;app&#x2F;kibana#&#x2F;management?_g&#x3D;()</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/jonesun/blog/blob/master/source/image/elk/kibana.jpg?raw=true" alt="image"> </p>
<h1 id="SpringBoot应用集成Logstash"><a href="#SpringBoot应用集成Logstash" class="headerlink" title="SpringBoot应用集成Logstash"></a>SpringBoot应用集成Logstash</h1><h2 id="pom-xml添加引用"><a href="#pom-xml添加引用" class="headerlink" title="pom.xml添加引用"></a>pom.xml添加引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--集成logstash--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.logstash.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logstash-logback-encoder&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="resource中新增logback-spring-xml"><a href="#resource中新增logback-spring-xml" class="headerlink" title="resource中新增logback-spring.xml"></a>resource中新增logback-spring.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--&lt;!DOCTYPE configuration&gt;--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;defaults.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;console-appender.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--应用名称--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;APP_NAME&quot; value&#x3D;&quot;mall-admin&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--日志文件保存路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;LOG_FILE_PATH&quot; value&#x3D;&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-&#x2F;tmp&#125;&#125;&#125;&#x2F;logs&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;contextName&gt;$&#123;APP_NAME&#125;&lt;&#x2F;contextName&gt;</span><br><span class="line">    &lt;!--每天记录日志到文件appender--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_FILE_PATH&#125;&#x2F;$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;&#x2F;maxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    &lt;!--输出到logstash的appender--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;LOGSTASH&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;!--可以访问的logstash日志收集端口--&gt;</span><br><span class="line">        &lt;destination&gt;192.168.31.13:4560&lt;&#x2F;destination&gt;</span><br><span class="line">        &lt;encoder charset&#x3D;&quot;UTF-8&quot; class&#x3D;&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    &lt;root level&#x3D;&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;LOGSTASH&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编写日志"><a href="#编写日志" class="headerlink" title="编写日志"></a>编写日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(TestController.class);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">    public String test() &#123;</span><br><span class="line">        LOGGER.debug(&quot;TestController:&#123;&#125;&quot;, &quot;Hello World!!!ELK-debug&quot;);</span><br><span class="line">        LOGGER.error(&quot;TestController:&#123;&#125;&quot;, &quot;Hello World!!!ELK-error&quot;);</span><br><span class="line">        LOGGER.warn(&quot;TestController:&#123;&#125;&quot;, &quot;Hello World!!!ELK-warn&quot;);</span><br><span class="line">        LOGGER.info(&quot;TestController:&#123;&#125;&quot;, &quot;Hello World!!!ELK-info&quot;);</span><br><span class="line">&#x2F;&#x2F;        int i &#x3D; 1 &#x2F;0;</span><br><span class="line">        return &quot;Hello World!!!ELK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行SpringBoot应用"><a href="#运行SpringBoot应用" class="headerlink" title="运行SpringBoot应用"></a>运行SpringBoot应用</h2><p>运行SpringBoot项目，浏览器访问<code>http://192.168.31.13:8901/test</code></p>
<h1 id="在kibana中查看日志信息"><a href="#在kibana中查看日志信息" class="headerlink" title="在kibana中查看日志信息"></a>在kibana中查看日志信息</h1><h2 id="创建index-pattern"><a href="#创建index-pattern" class="headerlink" title="创建index pattern"></a>创建index pattern</h2><p><img src="https://github.com/jonesun/blog/blob/master/source/image/elk/create-index-pattern.jpg?raw=true" alt="image"> </p>
<p><img src="https://github.com/jonesun/blog/blob/master/source/image/elk/create-index-pattern-1.jpg?raw=true" alt="image"> </p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p><img src="https://github.com/jonesun/blog/blob/master/source/image/elk/kibana-discover.jpg?raw=true" alt="image"> </p>
<blockquote>
<p>注意ipd地址<code>192.168.31.13</code>需改为自己的本机ip</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>搭建了ELK日志收集系统之后，如果要查看SpringBoot应用的日志信息，就不需要查看日志文件了，直接在Kibana中查看即可</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>ELK</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发小技巧-对象属性拷贝BeanUtils.copyProperties</title>
    <url>/20200831/java/springboot/c177f6b0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常我们在开发过程中经常会遇到将某个对象的一些属性赋值给另一个对象，常见的是将前端传输的from或者DTO赋值给DO</p>
<blockquote>
<p>DO/DTO/VO/FORM的区别</p>
</blockquote>
<ul>
<li>DO 就是entity ，对应表实体，和数据库的字段一一对应</li>
<li>DTO 数据传输对象，DTO本身不是业务对象</li>
<li>VO 用于封装传递到前端需要展示的字段，数据库表不需要展示的，不要包含</li>
<li>form 用于封装前端传入的字段， 可以配合@Valid注解，对前端传入数据，进行验证，比如必填字段</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>一般我们会这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserInputDTO &#123;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private Boolean sex;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    private LocalDate birthday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String userId;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private Boolean sex;</span><br><span class="line"></span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    private LocalDate birthday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line">UserInputDTO userInputDTO &#x3D; new UserInputDTO();</span><br><span class="line">userInputDTO.setUsername(&quot;username&quot;);</span><br><span class="line">userInputDTO.setAge(20);</span><br><span class="line">userInputDTO.setBirthday(LocalDate.of(2000, 1, 1));</span><br><span class="line">userInputDTO.setSex(Boolean.TRUE);</span><br><span class="line">userInputDTO.setDesc(&quot;this is my desc&quot;);</span><br><span class="line"></span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setUsername(userInputDTO.getUsername());</span><br><span class="line">user.setAge(userInputDTO.getAge());</span><br><span class="line">user.setBirthday(userInputDTO.getBirthday());</span><br><span class="line">user.setSex(userInputDTO.getSex());</span><br><span class="line">user.setDesc(userInputDTO.getDesc());</span><br></pre></td></tr></table></figure>

<p>而实际上，Spring框架自带一个工具类，可以实现上面的功能，避免编写重复的样板代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserInputDTO userInputDTO &#x3D; new UserInputDTO();</span><br><span class="line">userInputDTO.setUsername(&quot;username&quot;);</span><br><span class="line">userInputDTO.setAge(20);</span><br><span class="line">userInputDTO.setBirthday(LocalDate.of(2000, 1, 1));</span><br><span class="line">userInputDTO.setSex(Boolean.TRUE);</span><br><span class="line">userInputDTO.setDesc(&quot;this is my desc&quot;);</span><br><span class="line"></span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO, user);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BeanUtils提供对Java反射和自省API的包装。其主要目的是利用反射机制对JavaBean的属性进行处理</p>
</blockquote>
<h1 id="注意要求"><a href="#注意要求" class="headerlink" title="注意要求"></a>注意要求</h1><p>当然如果使用了该工具类，有些情况需要开发过程中注意下：</p>
<ul>
<li>对象属性，最好为包装类，否则可能出现null与0的问题</li>
<li>这个工具类是对bean之间存在属性名相同的属性进行处理，无论是源bean或者是目标bean中多出来的属性均不处理</li>
<li>BeanUtils是浅拷贝，需注意深浅拷贝的不同</li>
</ul>
<blockquote>
<p>深浅拷贝</p>
</blockquote>
<ul>
<li>浅拷贝： 只是调用子对象的set方法，并没有将所有属性拷贝。(也就是说，引用的一个内存地址)</li>
<li>深拷贝： 将子对象的属性也拷贝过去</li>
</ul>
<p>同类的还有Apache的commons库里也有BeanUtils，需注意如果使用了Apache的工具类的话，参数与Spring提供的参数顺序是相反的，当然《阿里巴巴java开发手册》中明确规定:</p>
<p><img src="%E6%B3%A8%E6%84%8F%E8%A6%81%E7%82%B9.png" alt="注意要点"></p>
<p>从网上搜索相关资料，可以知晓，大概是效率问题，是因为Apache BeanUtils在代码中增加了非常多的校验、兼容、日志打印等代码，导致性能下降严重(当然在一些特定场景中这些校验还是比较重要的)。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成使用</title>
    <url>/20201009/java/springboot/7b2ee301/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><blockquote>
<p>SpringBoot版本为2.x, 2.4.0开始版本号没有.RELEASE后缀</p>
</blockquote>
<p><a href="/20201226/java/springboot/c9c436f0">SpringBoot-Starters</a></p>
<p><a href="/20210706/jenkins/9b38587/">使用Jenkins自动构建</a></p>
<h2 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h2><p><a href="/20200724/java/springboot/33ed675a">SpringBoot-集成Log日志</a></p>
<p><a href="/20210305/java/springboot/8dec456e">SpringBoot-Test用法</a></p>
<p><a href="/20200929/java/springboot/c091a644">SpringBoot-集成Mybatis</a></p>
<p><a href="/20201010/java/springboot/a5de5e84">SpringBoot-集成Swagger3</a></p>
<p><a href="/20200826/java/springboot/b11f77d1">SpringBoot-集成Redis</a></p>
<p><a href="/20200722/java/springboot/1e755469">SpringBoot-SpringSecurity5整合</a></p>
<p><a href="/20200904/java/springboot/11360df2">SpringBoot-集成Websocket</a></p>
<p><a href="/20200721/java/springboot/5316e6b4">SpringBoot应用整合ELK实现日志收集</a></p>
<p><a href="/20201120/java/springboot/685e4f62">SpringBoot-监控</a></p>
<p><a href="/20201209/java/springboot/933cf8db">SpringBoot-集成Flyway实现数据库版本控制</a></p>
<p><a href="/20201207/java/springboot/c778234">SpringBoot-SpringInitializr说明</a></p>
<p><a href="/20210226/java/springboot/ade04692">SpringBoot-消息队列MQ</a></p>
<p><a href="/20201217/java/springboot/90c59710">SpringBoot-Docker使用</a></p>
<h2 id="开发小技巧"><a href="#开发小技巧" class="headerlink" title="开发小技巧"></a>开发小技巧</h2><p><a href="/20200831/java/springboot/c177f6b0">SpringBoot开发小技巧-对象属性拷贝BeanUtils.copyProperties</a></p>
<p><a href="/20200817/java/springboot/62be47dd">SpringBoot开发小技巧-打印Mybatis中的sql语句</a></p>
<p><a href="https://toscode.gitee.com/leshalv/screw/tree/master">screw-简洁好用的数据库表结构文档生成工具</a></p>
<p><a href="/20210712/java/springboot/5ca3dffb">springboot多环境配置</a></p>
<a id="more"></a>


<h2 id="推荐idea插件"><a href="#推荐idea插件" class="headerlink" title="推荐idea插件"></a>推荐idea插件</h2><ul>
<li>Maven Helper: 查看Maven引入的jar包是否有冲突</li>
<li>Codota: 右键选中代码会提示很多相关API用法，节省不少查阅资料的时间</li>
<li>IntelliJad：是一个Java class文件的反编译工具，可以对Jar选择class文件右键Decompile，会出现反编译的结果</li>
</ul>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>添加如下依赖到pom.xml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;&lt;!-- --&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>修改源码后，使用快捷键Ctrl + F9手动构建项目后，Spring Boot会自动重新加载</p>
<blockquote>
<p>默认配置下，针对/static、/public和/templates目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新</p>
</blockquote>
<p>如果不想手动构建，需要对IDEA做一些<a href="https://stackoverflow.com/questions/53569745/spring-boot-developer-tools-auto-restart-doesnt-work-in-intellij">配置更改</a></p>
<p>使用springboot的maven插件spring-boot-maven-plugin，可以直接打出可运行的jar：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>

<p>运行后在target文件夹下就可以看到jar了，直接用Java命令即可运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar springboot-demo-jar-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>如果不喜欢默认的项目名+版本号作为运行jar文件名，可以加一个配置指定文件名:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>xxx-app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>springboot2.x的版本, 默认使用的是junit5版本, junit4和junit5两个版本差别比较大，需要注意下用法</p>
</blockquote>
<p><img src="junit5vsjunit4.png" alt="junit5 vs junit4"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpringTestBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XXX xxx;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxxTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xxx.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试样例可以参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#spring-mvc-test-framework">官方教程</a></p>
<h2 id="运行监控"><a href="#运行监控" class="headerlink" title="运行监控"></a>运行监控</h2><p>Spring Boot内置了一个监控功能Actuator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>运行项目后输入<a href="http://localhost:8080/actuator%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81">http://localhost:8080/actuator，可以查看应用程序当前状态</a></p>
<p>默认只有health和info可使用web访问，要暴露更多的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints">访问点</a>给Web，需要在application.yml中加上配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: info, health, beans, env, metrics</span><br></pre></td></tr></table></figure>

<p>常用的如下: </p>
<table>
<thead>
<tr>
<th>Endpoint ID</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>auditevents</td>
<td>显示应用暴露的审计事件 (比如认证进入、订单失败)</td>
</tr>
<tr>
<td>info</td>
<td>显示应用的基本信息</td>
</tr>
<tr>
<td>health</td>
<td>显示应用的健康状态</td>
</tr>
<tr>
<td>metrics</td>
<td>显示应用多样的度量信息</td>
</tr>
<tr>
<td>loggers</td>
<td>显示和修改配置的loggers</td>
</tr>
<tr>
<td>logfile</td>
<td>返回log file中的内容(如果logging.file或者logging.path被设置)</td>
</tr>
<tr>
<td>httptrace</td>
<td>显示HTTP足迹，最近100个HTTP request/repsponse</td>
</tr>
<tr>
<td>env</td>
<td>显示当前的环境特性</td>
</tr>
<tr>
<td>flyway</td>
<td>显示数据库迁移路径的详细信息</td>
</tr>
<tr>
<td>liquidbase</td>
<td>显示Liquibase 数据库迁移的纤细信息</td>
</tr>
<tr>
<td>shutdown</td>
<td>让你逐步关闭应用</td>
</tr>
<tr>
<td>mappings</td>
<td>显示所有的@RequestMapping路径</td>
</tr>
<tr>
<td>scheduledtasks</td>
<td>显示应用中的调度任务</td>
</tr>
<tr>
<td>threaddump</td>
<td>执行一个线程dump</td>
</tr>
<tr>
<td>heapdump</td>
<td>返回一个GZip压缩的JVM堆dump</td>
</tr>
</tbody></table>
<h3 id="在运行时改变日志等级"><a href="#在运行时改变日志等级" class="headerlink" title="在运行时改变日志等级"></a>在运行时改变日志等级</h3><p>loggers endpoint也允许你在运行时改变应用的日志等级。</p>
<p>举个例子，为了改变root logger的等级为DEBUG ，发送一个POST请求到<a href="http://localhost:8080/actuator/loggers/root%EF%BC%8C%E5%8A%A0%E5%85%A5%E5%A6%82%E4%B8%8B%E5%8F%82%E6%95%B0">http://localhost:8080/actuator/loggers/root，加入如下参数</a>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;configuredLevel&quot;</span>: <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个功能对于线上问题的排查非常有用。</strong></p>
<p>同时，你可以通过传递null值给configuredLevel来重置日志等级。</p>
<blockquote>
<p>spring-boot-autoconfigure 包含了Spring Boot对于第三方库的自动配置，在编写自定义配置时可以参考使用</p>
</blockquote>
<p>如果是idea使用gradle编译的话，如果出现中文乱码则打开Help&gt;Edit Custom VM Options，在最后一行加上:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding&#x3D;UTF-8</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="关于-Autowired与-Resource"><a href="#关于-Autowired与-Resource" class="headerlink" title="关于@Autowired与@Resource"></a>关于@Autowired与@Resource</h3><p>如果在idea中使用类似:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于字段的依赖注入方式时会有黄色警告(不建议使用字段注入)：</p>
<ul>
<li>对于必需的依赖项，建议使用基于构造函数的注入，以使它们成为不可变的，并防止它们为null。</li>
<li>对于可选的依赖项，建议使用基于Setter的注入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于构造函数的依赖注入</span></span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//setter方式</span></span><br><span class="line">     <span class="meta">@Autowire</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">serUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Autowired通过类型装配，若注入类型一样的对象就无法选择具体注入哪一个，则要配合@Qualifiler结合使用；@Resource默认通过类型名注入</p>
</blockquote>
<p>一般模块间的依赖推荐使用：</p>
<ul>
<li>存在多态，推荐使用@Resource</li>
<li>允许不存在，推荐@Autowired并设置required属性为false</li>
</ul>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>@Component注解默认实例化的对象是单例，如果想声明成多例对象可以使用@Scope(“prototype”), Scope的全部可选项</p>
<ul>
<li>singleton 全局只有一个实例，即单例模式</li>
<li>prototype 每次注入Bean都是一个新的实例</li>
<li>request 每次HTTP请求都会产生新的Bean</li>
<li>session 每次HTTP请求都会产生新的Bean，该Bean在仅在当前session内有效</li>
<li>global session 每次HTTP请求都会产生新的Bean，该Bean在 当前global Session（基于portlet的web应用中）内有效</li>
</ul>
<p>对于不常使⽤的 Bean 设置延迟加载，这样偶尔使⽤的时候再加载，不必要从⼀开始该 Bean 就占 ⽤资源</p>
<p>在Bean的初始化和清理方法上标记@PostConstruct和@PreDestroy</p>
<p>先使用@PropertySource读取配置文件，然后通过@Value以${key:defaultValue}的形式注入，可以极大地简化读取配置的麻烦</p>
<p>Profile: 创建某个Bean时，Spring容器可以根据注解@Profile来决定是否创建</p>
<p>Conditional: Spring还可以根据@Conditional决定是否创建某个Bean</p>
<p>FactoryBean可以⽣成某⼀个类型的Bean实例，也就是说我们可以借助于它⾃定义Bean的创建过程，实现FactoryBean接口即可(获取FactoryBean，需要在id之前添加“&amp;”)。</p>
<p>如果你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component注解的，因此就不能使用自动化装配的方案了，但是我们可以使用@Bean。</p>
<h3 id="pom中使用阿里云镜像"><a href="#pom中使用阿里云镜像" class="headerlink" title="pom中使用阿里云镜像"></a>pom中使用阿里云镜像</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用gradle的话:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三方库想找到最新版本，除到各自官网查找外，可以到<a href="https://search.maven.org/">Maven Central Repository Search</a> 中搜索</p>
</blockquote>
<h3 id="中文乱码解决"><a href="#中文乱码解决" class="headerlink" title="中文乱码解决"></a>中文乱码解决</h3><blockquote>
<p>spring boot 2.4.2 如果控制台存在中文乱码问题，需修改application.yml:</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">charset:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">gbk</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/spring-projects/spring-boot/issues/24894">use 2.4.2 print log garbled</a></p>
<ul>
<li>使用spring-boot:run时控制台输出乱码</li>
</ul>
<p>pom.xml中修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring-boot:run 中文乱码解决 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--增加jvm参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jvmArguments</span>&gt;</span>-Dfile.encoding=UTF-8<span class="tag">&lt;/<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h1><p>Spring框架中提供了许多实现了Aware接口的类，这些类主要是为了辅助Spring访问容器中的数据:</p>
<ul>
<li>BeanNameAware：能够获取bean的名称</li>
<li>BeanFactoryAware：获取当前BeanFactory，这样可以调用容器的服务</li>
<li>ApplicationContextAware：获取ApplicationContext</li>
<li>MessageSourceAware：获取MessageSource相关文本信息</li>
<li>ApplicationEventPublisherAware: 获取ApplicationEventPublisher，用于发布事件</li>
<li>ResourceLoaderAware: 获取资源加载器，可以获取外部资源文件</li>
<li>……</li>
</ul>
<p>使用时直接实现对应接口即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//这里就可以获取到ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Retry"><a href="#Spring-Retry" class="headerlink" title="Spring Retry"></a>Spring Retry</h1><p><a href="https://github.com/spring-projects/spring-retry">spring-retry</a> 优雅引入重试机制：只需要在需要重试的方法上加上@Retryable注解并配置重试策略属性就好，不需要太多侵入代码：</p>
<ul>
<li>delay：默认1秒</li>
<li>maxDelay：最大重试等待时间</li>
<li>multiplier：用于计算下一个延迟时间的乘数(延迟大于0时生效)</li>
<li>random：随机重试等待时间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencys</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一定不要忘了在启动类上加上 <strong>@EnableRetry</strong></p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Retryable(maxAttempts=5,backoff = @Backoff(delay = 100))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retrySomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;printSomething is called&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过需要注意的是如果被 @Retryable 注解的方法的调用方和被调用方处于同一个类中，那么重试将会失效</p>
</blockquote>
<blockquote>
<p>另外Spring的重试机制只支持对异常进行捕获，而无法对返回值进行校验判断重试。如果想要更灵活的重试策略可以使用<strong>Guava Retry</strong></p>
</blockquote>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><h2 id="谈谈你对IOC-和-AOP-的理解？他们的实现原理是什么？"><a href="#谈谈你对IOC-和-AOP-的理解？他们的实现原理是什么？" class="headerlink" title="谈谈你对IOC 和 AOP 的理解？他们的实现原理是什么？"></a>谈谈你对IOC 和 AOP 的理解？他们的实现原理是什么？</h2><p>IOC 叫做控制反转，指的是通过Spring来管理对象的创建、配置和生命周期，这样相当于把控制权交给了<br>Spring，不需要人工来管理对象之间复杂的依赖关系，这样做的好处就是解耦。在Spring里面，主要提供<br>了 BeanFactory 和 ApplicationContext 两种 IOC 容器，通过他们来实现对 Bean 的管理。</p>
<p>AOP 叫做面向切面编程，他是一个编程范式，目的就是提高代码的模块性。Spring AOP 基于动态代理的<br>方式实现，如果是实现了接口的话就会使用 JDK 动态代理，反之则使用 CGLIB 代理，Spring中 AOP 的应<br>用主要体现在 事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务逻辑的<br>隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了 Aspect 切面、JoinPoint 连接点、<br>PointCut 切入点、Advice 增强等实现方式。</p>
<h2 id="Spring-Boot-启动流程"><a href="#Spring-Boot-启动流程" class="headerlink" title="Spring Boot 启动流程"></a>Spring Boot 启动流程</h2><ol>
<li>准备环境，根据不同的环境创建不同的Environment</li>
<li>准备、加载上下文，为不同的环境选择不同的Spring Context，然后加载资源，配置Bean</li>
<li>初始化，这个阶段刷新Spring Context，启动应用</li>
</ol>
<p>网上搜到的流程图</p>
<p><img src="spring-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="spring-boot启动流程"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发小技巧-打印Mybatis中的sql语句</title>
    <url>/20200817/java/springboot/62be47dd/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们平常在开发SpringBoot+Mybatis项目时,有时会需要打印sql的执行语句</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><p>如果项目使用的时yml配置，则:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">    level:</span><br><span class="line">        com:</span><br><span class="line">            xxxxx:</span><br><span class="line">                dao: debug</span><br></pre></td></tr></table></figure>

<h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><p>如果项目使用的时properties配置，则:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis.configuration.log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">logging.level.com.xxxxx.dao&#x3D;debug</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意包名路径应为mybatis对应的方法接口所在的包，而不是mapper.xml所在的包</p>
</blockquote>
<p>即可在控制台中打印sql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&gt;  Preparing: SELECT user_change_bind_log_id,user_id,last_bind,bind,bind_type,log_time FROM user_change_bind_log WHERE user_id&#x3D;? AND bind_type&#x3D;? AND log_status&#x3D;0 ORDER BY log_time DESC LIMIT ? </span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 100023(Integer), device(String), 10(Integer)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意上线时需要去除打印，可以用application-xx实现</p>
</blockquote>
<h1 id="推荐使用idea插件"><a href="#推荐使用idea插件" class="headerlink" title="推荐使用idea插件"></a>推荐使用idea插件</h1><h2 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a>MyBatis Log Plugin</h2><blockquote>
<p>这款插件可以把Mybatis输出的SQL日志还原成完整的SQL语句，就不需要我们去手动转换了(如何配置，百度一下)</p>
</blockquote>
<h2 id="Free-MyBatis-plugin"><a href="#Free-MyBatis-plugin" class="headerlink" title="Free MyBatis plugin"></a>Free MyBatis plugin</h2><blockquote>
<p>非常好用的MyBatis插件，对MyBatis的xml具有强大的提示功能，同时可以关联mapper接口和mapper.xml中的sql实现</p>
</blockquote>
<ul>
<li>可以通过Mapper接口中方法左侧的箭头直接跳转到对应的xml实现中去</li>
<li>也可以从xml中Statement左侧的箭头直接跳转到对应的Mapper接口方法中去</li>
<li>还可以通过Alt+Enter键组合直接生成新方法的xml实现</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud集成使用</title>
    <url>/20210319/java/springcloud/55535/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>顾名思义是跟云相关的，云程序实际上就是指分布式应用程序，所以Spring Cloud就是为了让分布式应用程序编写更方便，更容易而提供的一组基础设施，它的核心是Spring框架，利用Spring Boot的自动配置，力图实现最简化的分布式应用程序开发。</p>
<p>截至目前（2021-06-22）<a href="https://spring.io/projects/spring-cloud">官网</a> 最新版本为2020.0.3版</p>
<p>Spring Cloud包含了一大堆技术组件，既有开源社区开发的组件，也有商业公司开发的组件，既有持续更新迭代的组件，也有即将退役不再维护的组件。</p>
<h2 id="Spring-Cloud变化"><a href="#Spring-Cloud变化" class="headerlink" title="Spring Cloud变化"></a>Spring Cloud变化</h2><p>在2020.x之前Spring Cloud一直以来把Netflix OSS套件作为其官方默认的一站式解决方案，但是Netflix公司在2018年开始将其核心组件Hystrix、Ribbon、Zuul、Archaius等进行了闭源和设置为维护模式。</p>
<blockquote>
<p>模块置于维护模式，意味着 Spring Cloud 团队将不会再向模块添加新功能，只修复重大bug以及安全问题</p>
</blockquote>
<p>当然Spring Cloud 2020.0.0版本开始彻底删除掉了Netflix除Eureka外的所有组件依赖。所以学习Spring Cloud时需要注意版本(尤其看网上的各个博客教程时)：</p>
<table>
<thead>
<tr>
<th>Release Train</th>
<th>发布时间</th>
<th>Spring Boot版本</th>
<th>SC Commons版本</th>
</tr>
</thead>
<tbody><tr>
<td>2020.0.x</td>
<td>2020-12</td>
<td>2.4.x</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Hoxton</td>
<td>2019-07</td>
<td>2.2.x, 2.3.x (从SR5起)</td>
<td>2.2.x</td>
</tr>
<tr>
<td>Greenwich</td>
<td>2018-11</td>
<td>2.1.x</td>
<td>2.1.x</td>
</tr>
<tr>
<td>Finchley</td>
<td>2017-10</td>
<td>2.0.x</td>
<td>2.0.x</td>
</tr>
<tr>
<td>Edgware</td>
<td>2017-08</td>
<td>1.5.x</td>
<td>1.3.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>2017-05</td>
<td>1.5.x</td>
<td>1.2.x</td>
</tr>
<tr>
<td>Brixton</td>
<td>2016-09</td>
<td>1.3.x</td>
<td>1.1.x</td>
</tr>
<tr>
<td>Angel</td>
<td>2016-05</td>
<td>1.2.x</td>
<td>1.0.x</td>
</tr>
</tbody></table>
<p><strong>如果是新项目直接上2020.x最新版本</strong>，需要注意有些Netflix的组件不再推荐使用(除Eureka和已经贡献出去的OpenFeign)，Spring Cloud的替代建议是:</p>
<table>
<thead>
<tr>
<th>Netflix</th>
<th>推荐替代品</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Hystrix</td>
<td>Resilience4j</td>
<td>受Hystrix启发，专门为Java 8 和函数式编程设计的轻量级容错框架</td>
</tr>
<tr>
<td>Hystrix Dashboard / Turbine</td>
<td>Micrometer + Monitoring System</td>
<td>专业的监控组件</td>
</tr>
<tr>
<td>Ribbon</td>
<td>Spring Cloud Loadbalancer</td>
<td>Spring出品的负载均衡器</td>
</tr>
<tr>
<td>Zuul 1</td>
<td>Spring Cloud Gateway</td>
<td>Spring出品的API网关服务</td>
</tr>
</tbody></table>
<p>这个也教育了我们使用Spring Cloud时尽量面向它的抽象编程，这样即使Spring Cloud换底层组件（如换熔断器、负载均衡器）等等，理论上对我们业务是无影响或者影响很小的，这都得益于它的Spring Cloud Commons抽象，那里是精华</p>
<p>不过以上是Spring Cloud的建议，在国内的话因为Spring Cloud Alibaba的发展还是不错的，可以结合起来挑选合适的组件</p>
<h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><p><a href="https://spring.io/projects/spring-cloud-alibaba">Spring Cloud Alibaba</a> <a href="https://developer.aliyun.com/article/718349">官网学习</a> 是阿里巴巴结合自身微服务实践,开源的微服务全家桶。也是SpringCloud的子项目，也遵循Spring Cloud Common的抽象实现</p>
<p><img src="spring-cloud-alibaba.png" alt="spring-cloud-alibaba"></p>
<p><strong>需要注意的是如果想Spring Cloud 2020 结合 Spring Cloud Alibaba使用的话，Spring Cloud Alibaba最好也使用2021.1(第一个支持2020版spring cloud的版本)及以上版本，避免一些奇怪的问题</strong></p>
<p>从官网上的介绍和一些资料显示，Spring Cloud Alibaba主要的变化是：</p>
<ol>
<li>阿里开源了<a href="https://nacos.io/zh-cn/docs/quick-start.html">Nacos</a> 这个组件可以用来代替 Spring Cloud Config和Spring Cloud Eureka:</li>
</ol>
<ul>
<li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更</li>
<li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现</li>
</ul>
<ol start="2">
<li>服务容错使用了<a href="https://sentinelguard.io/zh-cn/">Sentinel</a> 替代了Hystrix</li>
</ol>
<blockquote>
<p>Spring Cloud官方推荐的Resilience4j现在发展也不错，Resilience4j自带整合了Micrometer，但Sentinel提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等，中小团队的话还是推荐Sentinel的</p>
</blockquote>
<p>如果项目使用了阿里云作为云服务商，可以集成其提供的各个组件(其他的可以到官网查看)，还是比较方便的：</p>
<ul>
<li><p>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p>
</li>
<li><p>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>
</li>
<li><p>Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p>
</li>
<li><p>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
</li>
<li><p>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p>
</li>
<li><p>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p>
</li>
</ul>
<h2 id="如何选型"><a href="#如何选型" class="headerlink" title="如何选型"></a>如何选型</h2><p>通过以上介绍，大概我们可以了解到各个组件功能的选型了，这里我再总结下，也方便接下来各个组件的学习。当然因为这个前提条件部署于国内云环境中(一般大家都用阿里云吧)，如果有涉及到国外的云服务器那可能会推荐AWS或者Microsoft、Google等自己提供的一系列套件:</p>
<ul>
<li>服务治理： 为了解决微服务架构中的服务实例维护问题(ip地址)， 实现对微服务应用实例的自动化管理。<strong>Spring Cloud Eureka 或者 Alibaba Nacos Discovery</strong></li>
<li>客户端负载均衡：为了实现服务的高可用，合理摊分用户的请求。<del>Spring Cloud Ribbon</del> <strong>Spring Cloud LoadBalancer</strong> 当然也可以直接用Nginx进行负载均衡</li>
<li>服务容错保护： 为了帮助用户保障微服务的稳定性，防止在高并发的情况下，由于单个服务的延迟，可能导致所有的请求都处于延迟状态，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用。 <del>Spring  Cloud Hystrix</del> <strong>Resilience4j 或者 Alibaba Sentinel</strong></li>
<li>声明式服务调用： 为了让使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。<strong>Spring Cloud Openfeign</strong></li>
<li>API网关服务：为了方便进行统一的鉴权，安全控制，日志处理等。<del>Spring Cloud Zuul</del> <strong>Spring Cloud Gateway</strong></li>
<li>分布式配置中心：解决分布式系统的配置管理方案。 <strong>Spring Cloud Config 或者 Alibaba Nacos Config</strong></li>
</ul>
<blockquote>
<p>以上就是Spring Cloud的核心组件了，再结合Spring Security、Spring Boot Admin等组件就可以搭建Spring Cloud的项目了。个人建议如果项目引入了Nacos就直接把Eureka和Spring Cloud Config都替换掉</p>
</blockquote>
<h1 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h1><p>微服务网关就是一个系统，通过暴露该微服务网关系统，方便我们进行相关的鉴权，安全控制，日志统一处理，易于监控的相关功能</p>
<p>实现微服务网关的技术有很多:</p>
<ul>
<li>Nginx: 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务</li>
<li>Zuul: 是 Netflix 出品的一个基于 JVM 路由和服务端的负载均衡器。</li>
<li>spring-cloud-gateway: 是spring 出品的 基于spring 的网关项目，集成断路器，路径重写，性能比Zuul好。</li>
</ul>
<h2 id="为什么要使用网关"><a href="#为什么要使用网关" class="headerlink" title="为什么要使用网关"></a>为什么要使用网关</h2><p>不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p>
<ol>
<li>客户端会多次请求不同的微服务，增加了客户端的复杂性</li>
<li>存在跨域请求，在一定场景下处理相对复杂</li>
<li>认证复杂，每个服务都需要独立认证</li>
<li>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施</li>
<li>某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定的困难</li>
</ol>
<p>以上这些问题可以借助网关解决。</p>
<p>网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 网关这一层。也就是说，API 的实现方面更多地考虑业务逻辑，而安全、性能、监控可以交由 网关来做，这样既提高业务灵活性又不缺安全性</p>
<h2 id="微服务网关的优点"><a href="#微服务网关的优点" class="headerlink" title="微服务网关的优点"></a>微服务网关的优点</h2><ul>
<li>安全 ，只有网关系统对外进行暴露，微服务可以隐藏在内网，通过防火墙保护。</li>
<li>易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。</li>
<li>易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li>
<li>减少了客户端与各个微服务之间的交互次数</li>
<li>易于统一授权。</li>
</ul>
<h1 id="常用技术框架"><a href="#常用技术框架" class="headerlink" title="常用技术框架"></a>常用技术框架</h1><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper是一个开源的分布式协调服务，由雅虎公司创建，见名思意Zookeeper就像动物管理员一样管理动物(应用组件)，负责分布式组件环境的协调工作。<br>他的目标是可以提供高性能、高可用和顺序访问控制的能力，同时也是为了解决分布式环境下数据一致性的问题。</p>
<p>应用场景：</p>
<ul>
<li>命名服务Name Service，依赖Zookeeper可以生成全局唯一的节点ID，来对分布式系统中的资源进行管理</li>
<li>分布式协调，这是Zookeeper的核心使用了。利用Wather的监听机制，一个系统的某个节点状态发生改变，另外系统可以得到通知</li>
<li>集群管理，分布式集群中状态的监控和管理，使用Zookeeper来存储</li>
<li>Master选举，利用Zookeeper节点的全局唯一性，同时只有一个客户端能够创建成功的特点，可以作为Master选举使用，创建成功的则作为Master</li>
<li>分布式锁，利用Zookeeper创建临时顺序节点的特性</li>
</ul>
<h1 id="补充一些概念解释"><a href="#补充一些概念解释" class="headerlink" title="补充一些概念解释"></a>补充一些概念解释</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote>
<p>同一个业务，部署在多个服务器上</p>
</blockquote>
<p>计算机集群简称集群是一种计算机系统，它通过一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多</p>
<p>集群技术特点：</p>
<ul>
<li>通过多台计算机完成同一个工作，达到更高的效率。</li>
<li>两机或多机内容、工作过程等完全一样。如果一台死机，另一台可以起作用</li>
</ul>
<p>集群：多台服务器部署相同应用构成一个集群</p>
<p>作用：通过负载均衡设备共同对外提供服务</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><blockquote>
<p>一个业务分拆多个子业务，部署在不同的服务器上</p>
</blockquote>
<p>分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。组件之间彼此进行交互以实现一个共同的目标</p>
<p>一个业务分拆多个子业务，部署在不同的服务器上(不同的服务器，运行不同的代码，为了同一个目的)</p>
<p>分布式：不同模块部署在不同服务器上</p>
<p>作用：分布式解决网站高并发带来问题</p>
<h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><p>业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力，通过服务的组合和编排来实现上层的业务流程</p>
<p>作用：简化维护,降低整体风险,伸缩灵活</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行SOA到微服务架构的演进过程</p>
<p>作用：各服务可独立应用，组合服务也可系统应用</p>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP理论是分布式架构中重要理论</p>
<ul>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul>
<li>spring-cloud 2020.0.0以上版本无法连接nacos config解决办法</li>
</ul>
<p>加入spring-cloud-starter-bootstrap:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果还不行，则去除spring-cloud-context:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在spring cloud config client中，启动时不在使用spring-cloud-context来加载bootstrap.yml来启动了。而是改为spring-cloud-starter-bootstrap作为引导。所以需要把boot-starter-bootstrap加入代码中.<br>但是nacos中的依赖引入了spring-cloud-context。导致bootstrap和context两个包冲突。因此需要在spring-cloud-starter-alibaba-nacos-discovery和spring-cloud-starter-alibaba-nacos-config两个包中把context包去除</p>
</blockquote>
<p>最后附上自己研究并搭建的基于Spring Cloud 2020和Spring Cloud Alibaba 2021 简易版 <a href="https://github.com/jonesun/spring-cloud-jonesun">spring-cloud-jonesun</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下安装Nexus3.x搭建Maven仓库</title>
    <url>/20180209/maven/c1ff8d1f/</url>
    <content><![CDATA[<p>使用android studio或者idea开发应用时，除了可以依赖本地的库之外，还可以依赖网上（公有maven服务器、私有maven服务器、jcenter等）。如果是依赖本地的，必须要将依赖的module和主工程放在一个project里面，这就导致了每个project都需要配置这些依赖关系，如果是公司内多个工程依赖同一个公司内部的控件，控件有更新时，同步非常麻烦，但公司内部的控件不可能部署到公有maven服务器上，所以有必要搭建一个局域网内的maven服务器，方便管理公司内部的公共库。</p>
<a id="more"></a>

<h2 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h2><blockquote>
<p>3.x版本只能运行在JVM8及以上</p>
</blockquote>
<p>本地内部仓库在本地构建nexus私服的好处：</p>
<ol>
<li>加速构建、稳定；</li>
<li>节省带宽、节省中央maven仓库的带宽；</li>
<li>控制和审计；</li>
<li>能够部署第三方构件；</li>
<li>可以建立本地内部仓库、可以建立公共仓库</li>
</ol>
<p><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/0.png?raw=true" alt="image"> </p>
<p><a href="https://www.sonatype.com/download-sonatype-trial?submissionGuid=8d76d833-cc25-4b42-8c46-123de611dbcb">Nexus下载</a><br><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/1.png?raw=true" alt="image"> </p>
<p>下载了3.x - OS X的源码包之后，解压文件得到两个目录：<br>nexus-xxx：该目录包含了Nexus运行时所需要的文件，如启动脚本等。<br>sonatype-work：该目录包含了Nexus生成的配置文件，日志文件，仓库文件等。</p>
<p>运行<br>cmd 到nexus-xxx\bin文件夹 输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nexus &#x2F;run</span><br><span class="line">&#x2F;&#x2F;其他命令</span><br><span class="line">start：在后台启动服务，不在界面上打印任何启动或者运行时信息。</span><br><span class="line">run：启动服务，但是在界面上打印出启动信息以及运行时信息以及日志信息。</span><br><span class="line">stop：关闭服务</span><br><span class="line">status：查看nexus运行状态</span><br><span class="line">restart：重启服务</span><br><span class="line">force-reload：强制重载一遍配置文件，然后重启服务</span><br></pre></td></tr></table></figure>

<p>安装为服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nexus.exe &#x2F;install &lt;optional-service-name&gt; #安装</span><br><span class="line">nexus.exe &#x2F;start &lt;optional-service-name&gt; #开始</span><br><span class="line">nexus.exe &#x2F;stop &lt;optional-service-name&gt; #结束</span><br><span class="line">nexus.exe &#x2F;uninstall &lt;optional-service-name&gt; #卸载</span><br><span class="line">#其中&lt;optional-service-name&gt;为服务的名称，可自定义</span><br></pre></td></tr></table></figure>

<p>浏览器访问 <a href="http://localhost:8081/">http://localhost:8081/</a><br><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/2.png?raw=true" alt="image"> </p>
<h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><blockquote>
<p>默认登录用户名密码(admin admin123)</p>
</blockquote>
<p>Nexus的主要的仓库类型：</p>
<ul>
<li>hosted（宿主）：宿主仓库主要用于存放项目部署的构件、或者第三方构件用于提供下载。</li>
<li>proxy（代理）：代理仓库就是对远程仓库的一种代理，从远程仓库下载构件和插件然后缓存在Nexus仓库中</li>
<li>group（仓库组）：对我们已经配置完的仓库的一种组合策略。</li>
</ul>
<p>Nexus内置的仓库就已经包含了主要的仓库类型：</p>
<ul>
<li>maven-central：代理中央仓库、策略为Release、只会下载和缓存中央仓库中的发布版本构件。</li>
<li>maven-releases：策略为Release的宿主仓库、用来部署组织内部的发布版本内容。</li>
<li>maven-snapshots：策略为Snapshot的宿主仓库、用来部署组织内部的快照版本内容。</li>
<li>maven-public：该仓库将上述所有策略为Release的仓库聚合并通过一致的地址提供服务。</li>
<li>nuget-hosted：用来部署nuget构件的宿主仓库</li>
<li>nuget.org-proxy：代理nuget远程仓库，下载和缓冲nuget构件。</li>
<li>nuget-group：该仓库组将nuget-hosted与nuget.org-proxy仓库聚合并通过一致的地址提供服务。</li>
<li>maven-public：该仓库组将maven-central，maven-releases与maven-snapshots仓库聚合并通过一致的地址提供服务。</li>
</ul>
<p>点击 Repository 下 Repositories 创建仓库</p>
<p><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/3.png?raw=true" alt="image"> </p>
<h2 id="Gradle打包上传"><a href="#Gradle打包上传" class="headerlink" title="Gradle打包上传"></a>Gradle打包上传</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>新建gradle项目，在build.gragle中编写配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group &#39;com.example.mylibrary&#39;</span><br><span class="line">version &#39;1.0-SNAPSHOT&#39;</span><br><span class="line"></span><br><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line"></span><br><span class="line">sourceCompatibility &#x3D; 1.8</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(url:&quot;http:&#x2F;&#x2F;192.168.31.6:8081&#x2F;repository&#x2F;colorfulworld&#x2F;&quot;) &#123;</span><br><span class="line">            authentication(userName:&quot;admin&quot;, password:&quot;admin123&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        pom.version&#x3D;&quot;1.0&quot;</span><br><span class="line">        pom.artifactId&#x3D;&quot;javaUtils&quot;</span><br><span class="line">        pom.groupId&#x3D;&quot;com.example&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行 uploadArchives 进行上传</p>
</blockquote>
<p><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/4.png?raw=true" alt="image"> </p>
<h3 id="android-studio"><a href="#android-studio" class="headerlink" title="android studio"></a>android studio</h3><p>新建app项目，然后新建库(android.library 或者 java.library)，在build.gragle中编写配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;com.android.library&#39;</span><br><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: &quot;http:&#x2F;&#x2F;192.168.31.6:8081&#x2F;repository&#x2F;colorfulworld&#x2F;&quot;) &#123;</span><br><span class="line">                authentication(userName: &quot;admin&quot;, password: &quot;admin123&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.groupId &#x3D; &#39;com.example.mylibrary&#39;</span><br><span class="line">            pom.artifactId &#x3D; &#39;utils&#39;</span><br><span class="line">            pom.version &#x3D; &#39;0.0.1&#39;</span><br><span class="line"></span><br><span class="line">            pom.project &#123;</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &#39;The Apache Software License, Version 2.0&#39;</span><br><span class="line">                        url &#39;http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0.txt&#39;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行 uploadArchives 进行上传</p>
</blockquote>
<p><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/5.png?raw=true" alt="image"> </p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><img src="https://github.com/jonesun/blog/blob/master/source/image/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Nexus3-x%E6%90%AD%E5%BB%BAMaven%E4%BB%93%E5%BA%93/6.png?raw=true" alt="image"> </p>
<h2 id="项目引用"><a href="#项目引用" class="headerlink" title="项目引用"></a>项目引用</h2><p>配置 Project 的build.gradle文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;http:&#x2F;&#x2F;192.168.31.6:8081&#x2F;repository&#x2F;colorfulworld&#x2F;&quot; &#125;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 module 的 build.gradle 中添加依赖即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;compile &#39;com.example.mylibrary:utils:0.0.1&#39;</span><br><span class="line"></span><br><span class="line">implementation &#39;com.example.mylibrary:utils:0.0.1&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>jonesun</tag>
        <tag>maven</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/20160808/uncategorized/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br> <a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java-io</title>
    <url>/20201022/java/ddadecb7/</url>
    <content><![CDATA[<p>InputStream代表输入字节流，OutputStream代表输出字节流</p>
<p>如果读写的是文本文件则可使用 Reader和Writer表示字符流，字符流传输的最小数据单位是char</p>
<blockquote>
<p>字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符</p>
</blockquote>
<p><img src="IO.png" alt="IO"></p>
 <a id="more"></a>

<h1 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h1><p><img src="InputStream.png" alt="InputStream"></p>
<p>InputStream分为两类:</p>
<ul>
<li><p>直接提供数据的基础InputStream</p>
<ul>
<li>FileInputStream</li>
<li>ByteArrayInputStream</li>
<li>ServletInputStream</li>
<li>…</li>
</ul>
</li>
<li><p>提供额外附加功能的InputStream(继承自FilterInputStream)</p>
<ul>
<li>BufferedInputStream：提供缓冲的功能来提高读取的效率, 默认缓冲区大小是8M</li>
<li>DigestInputStream: 添加计算签名的功能</li>
<li>CipherInputStream: 添加加密/解密功能</li>
<li>…</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数据来源自文件</span><br><span class="line">InputStream file &#x3D; new FileInputStream(&quot;test.gz&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供缓冲的功能来提高读取的效率</span><br><span class="line">InputStream buffered &#x3D; new BufferedInputStream(file);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容</span><br><span class="line">InputStream gzip &#x3D; new GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure>

<p>这里用到了装饰器模式：Decorator， 可以让我们通过少量的类来实现各种功能的组合</p>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>从文件流中读取数据</p>
<p>File相关概念解析</p>
<ul>
<li>.表示当前目录，..表示上级目录</li>
<li>getPath()，返回构造方法传入的路径</li>
<li>getAbsolutePath()，返回绝对路径，</li>
<li>getCanonicalPath，它和绝对路径类似，但是返回的是规范路径</li>
</ul>
<p>绝对路径可以表示成C:\Windows\System32..\notepad.exe，而规范路径就是把.和..转换成标准的绝对路径后的路径：C:\Windows\notepad.exe</p>
<h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    try (InputStream input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; input.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; &#x2F;&#x2F; 编译器在此自动为我们写入finally并调用close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000<del>11111111，换算成十进制是0</del>255，换算成十六进制是00~ff, 二进制文件不利于直观查看，可以转成常用的十进制进行展示，因此需要把读取的字节从二进制转成十进制整数，故返回int型</p>
</blockquote>
<h3 id="read-byte-bytes"><a href="#read-byte-bytes" class="headerlink" title="read(byte[] bytes)"></a>read(byte[] bytes)</h3><p>此方法是利用缓冲区一次性读取多个字节，效率比一个字节一个字节读取效率要高很多</p>
<p><strong>返回值不再是字节的int值，而是返回实际读取了多少个字节</strong>。如果返回-1，表示没有更多的数据了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">try(InputStream inputStream &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">    byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">    int n;</span><br><span class="line">    while ((n &#x3D; inputStream.read(bytes)) &gt; -1) &#123;</span><br><span class="line">        &#x2F;&#x2F;n表示读取了多少字节</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        sb.append(new String(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;读取到的: &quot; + sb.toString());</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如某个文本文件大小是3kb, 设置的缓冲区byte[]大小为1024(即1024字节)则while会执行3次，每次n返回1024</p>
</blockquote>
<h3 id="transferTo-OutputStream-out"><a href="#transferTo-OutputStream-out" class="headerlink" title="transferTo(OutputStream out)"></a>transferTo(OutputStream out)</h3><p>JDK 9新增了InputStream.transferTo(OutputStream)方法，此方法允许从对象调用方法表示的输入流中轻松传输（复制）字节到提供给该方法的输出流。正如方法的Javadoc注释所述，从该输入流中读取所有字节，并按照读取的顺序将字节写入给定的输出流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过try-with-resources语句可以确保两个资源的正确回收</span><br><span class="line">try (InputStream input &#x3D; new FileInputStream(&quot;input.txt&quot;);</span><br><span class="line">     OutputStream output &#x3D; new FileOutputStream(&quot;output.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output);</span><br><span class="line">&#125;catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这个方法和spring提供的不是同一个方法</p>
</blockquote>
<h1 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h1><p><img src="OutputStream.png" alt="OutputStream"></p>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>写入字节到输出流。要注意的是，如果是write(int)传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void writeFile() throws IOException &#123;</span><br><span class="line">    try (OutputStream output &#x3D; new FileOutputStream(&quot;out&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">        output.write(&quot;Hello&quot;.getBytes(&quot;UTF-8&quot;)); &#x2F;&#x2F; Hello</span><br><span class="line">    &#125; &#x2F;&#x2F; 编译器在此自动为我们写入finally并调用close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。</p>
<p>通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法</p>
<p>但是，在某些情况下，我们必须手动调用flush()方法: 写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。 解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去</p>
<h1 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h1><p><img src="Reader.png" alt="Reader"></p>
<p>Reader是Java的IO库提供的另一个输入流接口。和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取</p>
<blockquote>
<p>StringReader可以直接把String作为数据源: Reader reader = new StringReader(“Hello”)</p>
</blockquote>
<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>对读取文件操作系统的封装，所有的读写都是直接操作文件系统。因此如果是频繁读写操作，不建议使用FileReader 和 FileWriter，性能将会非常低，这时你需要使用<strong>BufferedReader</strong>。</p>
<blockquote>
<p>BufferedReader在读取文本文件时，会先尽量从文件中读入字符数据并置入缓冲区，而之后若使用read()方法，会先从缓冲区中进行读取。如果缓冲区数据不足，才会再从文件中读取，使用BufferedWriter时，写入的数据并不会先输出到目的地，而是先存储至缓冲区中。如果缓冲区中的数据满了，才会一次对目的地进行写出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    try (Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        char[] buffer &#x3D; new char[1000];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; reader.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.println(&quot;read &quot; + n + &quot; chars.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileReader默认的编码与系统相关，例如，Windows系统的默认编码可能是GBK，打开一个UTF-8编码的文本文件就会出现乱码。要避免乱码问题，需要在创建FileReader时指定编码</p>
</blockquote>
<h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><p>可以把任何InputStream转换为Reader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (Reader reader &#x3D; new InputStreamReader(new FileInputStream(&quot;src&#x2F;readme.txt&quot;), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h1><p><img src="Writer.png" alt="Writer"></p>
<p>把char转换为byte并输出, 比OutputStream多了一个写入String的方法：void write(String s)</p>
<h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (Writer writer &#x3D; new FileWriter(&quot;readme.txt&quot;, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(&#39;H&#39;); &#x2F;&#x2F; 写入单个字符</span><br><span class="line">    writer.write(&quot;Hello&quot;.toCharArray()); &#x2F;&#x2F; 写入char[]</span><br><span class="line">    writer.write(&quot;Hello&quot;); &#x2F;&#x2F; 写入String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p>将任意的OutputStream转换为Writer的转换器</p>
<p>try (Writer writer = new OutputStreamWriter(new FileOutputStream(“readme.txt”), StandardCharsets.UTF_8)) {<br>    // TODO:<br>}</p>
<h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><p>RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。提供了对文件的读写功能</p>
<p>RandomAccessFile的基本功能有：定位用的getFilePointer()，在文件里移动用的seek()，以及判断文件大小的length()、skipBytes()跳过多少字节数。此外，它的构造函数还要一个表示以只读方式(“r”)，还是以读写方式(“rw”)打开文件的参数。实际它和C的fopen()一模一样，都是直接对文件句柄操作。</p>
<p>构造函数中mode参数传值介绍:</p>
<ul>
<li>r 代表以只读方式打开指定文件 。</li>
<li>rw 以读写方式打开指定文件 。</li>
<li>rws 读写方式打开，并对内容或元数据都同步写入底层存储设备 。</li>
<li>rwd 读写方式打开，对文件内容的更新同步更新至底层存储设备 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;读指定文件的内容，并且输出控制台</span><br><span class="line">RandomAccessFile raf&#x3D;new RandomAccessFile(&quot;G:\\java-lambda\\work.txt&quot;,&quot;r&quot;);</span><br><span class="line">byte[] buff &#x3D; new byte[1024];</span><br><span class="line">int len &#x3D; 0;</span><br><span class="line">while ((len &#x3D; raf.read(buff,0,1024))!&#x3D;-1)&#123;</span><br><span class="line">    System.out.println(new String(buff,0,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h1><p>从Java 7开始，提供了Files和Paths这两个工具类，能极大地方便我们读写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;把一个文件的全部内容读取为一个byte[]</span><br><span class="line">byte[] data &#x3D; Files.readAllBytes(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认使用UTF-8编码读取:</span><br><span class="line">String content1 &#x3D; Files.readString(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;));</span><br><span class="line">&#x2F;&#x2F; 可指定编码:</span><br><span class="line">String content2 &#x3D; Files.readString(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;), StandardCharsets.ISO_8859_1);</span><br><span class="line">&#x2F;&#x2F; 按行读取并返回每行内容:</span><br><span class="line">List&lt;String&gt; lines &#x3D; Files.readAllLines(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写入二进制文件:</span><br><span class="line">byte[] data &#x3D; ...</span><br><span class="line">Files.write(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;), data);</span><br><span class="line">&#x2F;&#x2F; 写入文本并指定编码:</span><br><span class="line">Files.writeString(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;), &quot;文本内容...&quot;, StandardCharsets.ISO_8859_1);</span><br><span class="line">&#x2F;&#x2F; 按行写入文本:</span><br><span class="line">List&lt;String&gt; lines &#x3D; ...</span><br><span class="line">Files.write(Paths.get(&quot;&#x2F;path&#x2F;to&#x2F;file.txt&quot;), lines);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;还有copy()、delete()、exists()、move()等快捷方法操作文件和目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容</p>
</blockquote>
<blockquote>
<p>对于大一些的流，为了提高效率就会用到nio的相关知识了，而nio比较复杂，一般都会基于netty来做二次封装</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-时间</title>
    <url>/20201022/java/1956c086/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日常开发中必不可少要与时间打交道，而关于时间的处理网上有很多文章，下面基于大神的文章和我自己的理解对时间做一个整理</p>
<p>开始之前我们得先明确下一些概念，有助于后面程序代码得理解</p>
<ul>
<li><p>时间：类似于<strong>08:00</strong>和<strong>2020年10月1日12:00</strong>，这个叫做时间，时间是一个相对得概念。在国内我们说得时间和国外得时间表示得就不一样，比如现在是2020年10月1日10:00，在美国芝加哥得话现在就是2020年09月30日21:00，所以一般需要说当地时间(本地时间)</p>
</li>
<li><p>时刻：时刻就是一个准确得时间，如现在我们和国外同时做了一个事情，如果以上帝得视角来看，那这个时间点就是可以确定得哪个时刻(程序里就是时间戳)</p>
</li>
<li><p>时区: 但我们不是上帝，我们对应得如果要准确得表示一个事情得时间，就得加上时区了。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区</p>
</li>
</ul>
<blockquote>
<p>总结一下，如果要表示准确得时间，得这样说: 北京时间(东八区) 2020年10月1日12:00</p>
</blockquote>
<p>下面我们就看下在Java中对于时间得处理</p>
<p>我们都知道Java8加入了LocalDateTime等基础类，改进了时间得运算处理，所以如果是新项目想都不要想，直接上java8+，如果是旧项目或者有引用库还是java7及以下得也有方法可以解决，但不管怎样，放弃Date或者Calendar从现在开始</p>
<a id="more"></a>

<blockquote>
<p>新API的类型几乎全部是不变类型，可以在多线程情况下放心使用, 并且修正了旧API一些不合理的常量设计：</p>
</blockquote>
<ul>
<li>Month的范围用1~12表示1月到12月(再也不用记要不要加1减1了)</li>
<li>Week的范围用1~7表示周一到周日</li>
<li>处理加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日</li>
</ul>
<blockquote>
<p>System.currentTimeMillis()，这个数值代表什么呢？从 Javadoc 可以看出，它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个数值与夏 / 冬令时并没有关系，所以并不受其影响</p>
</blockquote>
<h1 id="重要类"><a href="#重要类" class="headerlink" title="重要类"></a>重要类</h1><ul>
<li><p>LocalDateTime: 表示一个带日期得时间(LocalDateTime.now())</p>
</li>
<li><p>LocalDate: 表示一个日期(不带时分秒得时间)</p>
</li>
<li><p>LocalTime: 表示一个不带日期得时间</p>
</li>
</ul>
<p><em>当需要在程序上显示时就用到了</em>:</p>
<ul>
<li>DateTimeFormatter: 格式化显示时间</li>
</ul>
<p><em>当需要对时间进行计算时就用到了</em>：</p>
<ul>
<li>Duration: 两个LocalDateTime之间的差值(相差多少时间)，比如PT1235H10M30S，表示1235小时10分钟30秒</li>
<li>Period：两个LocalDate之间的差值(相差多少天), 比如P1M21D，表示1个月21天</li>
</ul>
<p><em>当需要准确得表示时间时就得用到时区</em>：</p>
<ul>
<li>ZoneId: 仅表示时区</li>
<li>ZonedDateTime: 带时区的时间(ZoneId+LocalDateTime)</li>
</ul>
<p><em>当需要表示时刻时就得用时间戳</em>：</p>
<ul>
<li>Instant: 用Instant.now()获取当前时间戳，比System.currentTimeMillis()多了一个更高精度的纳秒</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前时间戳</span><br><span class="line">Instant instant &#x3D; Instant.now();</span><br><span class="line">System.out.println(&quot;当前时间戳: &quot; + instant.toEpochMilli());&#x2F;&#x2F;与System.currentTimeMillis类似</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加一个时区组合成ZonedDateTime 默认东八区</span><br><span class="line">ZonedDateTime zonedDateTime &#x3D; instant.atZone(ZoneId.systemDefault());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出显示</span><br><span class="line">System.out.println(&quot;北京时间: &quot; + zonedDateTime.format(DateTimeFormatter.ISO_DATE));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;去掉时区显示时间</span><br><span class="line">LocalDateTime localDateTime &#x3D; zonedDateTime.toLocalDateTime();</span><br><span class="line">System.out.println(&quot;当前时间: &quot; + localDateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy&#x2F;MM&#x2F;dd HH:mm:ss&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;去掉日期</span><br><span class="line">LocalTime localTime &#x3D; localDateTime.toLocalTime();</span><br><span class="line">System.out.println(&quot;当前时间: &quot; + localTime.format(DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算两个时间</span><br><span class="line">LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2000, 9, 1, 9, 20);</span><br><span class="line">Duration duration &#x3D; Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(&quot;duration相差: &quot; + duration);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算两个日期</span><br><span class="line">Period period &#x3D; Period.between(localDateTime1.toLocalDate(), localDateTime.toLocalDate());</span><br><span class="line">System.out.println(&quot;period相差: &quot; + period);</span><br></pre></td></tr></table></figure>

<h1 id="新老版本转换"><a href="#新老版本转换" class="headerlink" title="新老版本转换"></a>新老版本转换</h1><p>LocalDateTime，ZoneId，Instant，ZonedDateTime和long都可以互相转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│LocalDateTime│────┐</span><br><span class="line">└─────────────┘    │    ┌─────────────┐</span><br><span class="line">                   ├───&gt;│ZonedDateTime│</span><br><span class="line">┌─────────────┐    │    └─────────────┘</span><br><span class="line">│   ZoneId    │────┘           ▲</span><br><span class="line">└─────────────┘      ┌─────────┴─────────┐</span><br><span class="line">                     │                   │</span><br><span class="line">                     ▼                   ▼</span><br><span class="line">              ┌─────────────┐     ┌─────────────┐</span><br><span class="line">              │   Instant   │&lt;───&gt;│    long     │</span><br><span class="line">              └─────────────┘     └─────────────┘</span><br></pre></td></tr></table></figure>
<blockquote>
<p>转换的时候，需要留意long类型以毫秒还是秒为单位即可</p>
</blockquote>
<h2 id="旧API转新API"><a href="#旧API转新API" class="headerlink" title="旧API转新API"></a>旧API转新API</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;long -&gt; Instance</span><br><span class="line">Instant instant &#x3D; Instant.ofEpochMilli(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date -&gt; Instant</span><br><span class="line">Instant ins1 &#x3D; new Date().toInstant();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Calendar -&gt; Instant</span><br><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">Instant ins2 &#x3D; Calendar.getInstance().toInstant();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Instance + ZoneId -&gt; ZonedDateTime</span><br><span class="line">ZonedDateTime zonedDateTime &#x3D; instant.atZone(ZoneId.systemDefault());</span><br><span class="line">&#x2F;&#x2F;注意，如果源数据是calendar，采用calendar中保存的时区</span><br><span class="line">ZonedDateTime zdt &#x3D; ins2.atZone(calendar.getTimeZone().toZoneId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ZonedDateTime -&gt; LocalDateTime</span><br><span class="line">LocalDateTime localDateTime &#x3D; zonedDateTime.toLocalDateTime();</span><br></pre></td></tr></table></figure>

<h2 id="新API转旧API"><a href="#新API转旧API" class="headerlink" title="新API转旧API"></a>新API转旧API</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; LocalDateTime -&gt; ZonedDateTime -&gt; long -&gt; Date:</span><br><span class="line">ZonedDateTime zdt &#x3D; LocalDateTime.now().atZone(ZoneId.systemDefault());</span><br><span class="line">long ts &#x3D; zdt.toInstant().toEpochMilli();</span><br><span class="line">Date date &#x3D; new Date(ts);</span><br><span class="line">System.out.println(&quot;date: &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(date));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LocalDateTime -&gt; ZonedDateTime -&gt; long -&gt; Calendar:</span><br><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">calendar.clear();</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));</span><br><span class="line">calendar.setTimeInMillis(ts);</span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot中处理"><a href="#SpringBoot中处理" class="headerlink" title="SpringBoot中处理"></a>SpringBoot中处理</h1><blockquote>
<p>以上配置针对于SpringBoot 2.x及以上版本</p>
</blockquote>
<p><strong>推荐jackson, SpringBoot内置，既能处理json也能处理xml</strong>故这里只讲jackson的处理，其他json库网上搜索即可</p>
<p>一般我们都会用json来作为前后台传递数据用的格式，LocalDateTime类型如果不处理话，直接传递客户端使用是不太方便的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyUser &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    private LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    private LocalTime localTime;</span><br><span class="line"></span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;getter setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;json返回</span><br><span class="line">&#123;</span><br><span class="line">  &quot;createTime&quot;: &quot;2020-10-23T05:47:07.670Z&quot;,</span><br><span class="line">  &quot;date&quot;: &quot;2020-10-23T05:47:07.670Z&quot;,</span><br><span class="line">  &quot;localDate&quot;: &quot;string&quot;,</span><br><span class="line">  &quot;localTime&quot;: &#123;</span><br><span class="line">    &quot;hour&quot;: 0,</span><br><span class="line">    &quot;minute&quot;: 0,</span><br><span class="line">    &quot;nano&quot;: 0,</span><br><span class="line">    &quot;second&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;name&quot;: &quot;string&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ISO 8601规定的日期和时间分隔符是T</p>
</blockquote>
<p>故需要作一些配置修改</p>
<ul>
<li>如果是部分实体需要，直接在属性上加上@JsonFormat注解即可:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JsonFormat(pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">@JsonFormat(pattern &#x3D; &quot;yyyy-MM-dd&quot;)</span><br><span class="line">private LocalDate localDate;</span><br><span class="line"></span><br><span class="line">@JsonFormat(pattern &#x3D; &quot;HH:mm:ss&quot;)</span><br><span class="line">private LocalTime localTime;</span><br><span class="line"></span><br><span class="line">@JsonFormat(pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private Date date;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;jone&quot;,</span><br><span class="line">  &quot;createTime&quot;: &quot;2020-10-23 13:50:48&quot;,</span><br><span class="line">  &quot;localDate&quot;: &quot;2020-10-23&quot;,</span><br><span class="line">  &quot;localTime&quot;: &quot;13:50:48&quot;,</span><br><span class="line">  &quot;date&quot;: &quot;2020-10-23 05:50:48&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果项目涉及到国内外，还需加上时区如：@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”,timezone=”GMT+8”)</p>
</blockquote>
<ul>
<li>全局设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JsonConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * DateTime格式化字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final String DEFAULT_DATETIME_PATTERN &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Date格式化字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final String DEFAULT_DATE_PATTERN &#x3D; &quot;yyyy-MM-dd&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Time格式化字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final String DEFAULT_TIME_PATTERN &#x3D; &quot;HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() &#123;</span><br><span class="line">        return builder -&gt; builder</span><br><span class="line">                .serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATETIME_PATTERN)))</span><br><span class="line">                .serializerByType(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_PATTERN)))</span><br><span class="line">                .serializerByType(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_PATTERN)))</span><br><span class="line">                .serializerByType(Date.class, new DateSerializer(false, new SimpleDateFormat(DEFAULT_DATETIME_PATTERN)))</span><br><span class="line">                .deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATETIME_PATTERN)))</span><br><span class="line">                .deserializerByType(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_PATTERN)))</span><br><span class="line">                .deserializerByType(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_PATTERN)))</span><br><span class="line">                .deserializerByType(Date.class, new DateDeserializers.DateDeserializer(DateDeserializers.DateDeserializer.instance, new SimpleDateFormat(DEFAULT_DATETIME_PATTERN), DEFAULT_DATETIME_PATTERN))</span><br><span class="line">                ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将前端获取的时间转换为一个符合自定义格式的时间格式存储到数据库@DateTimeFormat</p>
<blockquote>
<p>关于@JsonFormat与@DateTimeFormat的用法</p>
</blockquote>
<p>@JsonFormat 是jackson提供的，@DateTimeFormat 由spring提供的</p>
<ul>
<li>前端 传给 后端。<ul>
<li>当前端传来的是键值对，用@DateTimeFormat 规定接收的时间格式。</li>
<li>当前端传来json串，后台用@ReuqestBody接收，用@JsonFormat 规定接收的时间格式。</li>
</ul>
</li>
<li>后端 传给 前端。<ul>
<li>后端返回给前端的时间值，只能用@JsonFormat 规定返回格式，@DateTimeFormat 无法决定返回值的格式。</li>
</ul>
</li>
</ul>
<h1 id="数据库相关处理"><a href="#数据库相关处理" class="headerlink" title="数据库相关处理"></a>数据库相关处理</h1><table>
<thead>
<tr>
<th>数据库</th>
<th>对应Java类（旧）</th>
<th>对应Java类（新）</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>java.util.Date</td>
<td>LocalDateTime</td>
</tr>
<tr>
<td>DATE</td>
<td>java.sql.Date</td>
<td>LocalDate</td>
</tr>
<tr>
<td>TIME</td>
<td>java.sql.Time</td>
<td>LocalTime</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>java.sql.Timestamp</td>
<td>LocalDateTime</td>
</tr>
</tbody></table>
<blockquote>
<p>DATETIME与TIMESTAMP区别：datetime的存储范围是 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999，而timestamp的范围是 1970-01-01 00:00:01.000000到 2038-01-19 03:14:07.999999</p>
</blockquote>
<blockquote>
<p>新系统最好使用DATETIME，因为TIMESTAMP存储了不在范围内的时间值时，会直接抛出异常</p>
</blockquote>
<blockquote>
<p>还有一种建议即直接用long表示，在数据库中存储为BIGINT类型, 显示的时候再转换</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038 年问题</a></p>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>由于日常开发Mybatis用的比较多，故只讲下Mybatis下的用法，JPA的有兴趣可以自行搜索下</p>
<p>首先检查下项目中引用的Mybatis版本，当然所有的第三方库配合SpringBoot的话，优先看是否存在xxx-spring-boot-starter或者xxx-starter(珍惜时间，远离加班)</p>
<p>如果是新项目建议使用最新版本，如目前我使用的是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此版本引用的mybatis版本是3.5.3</span><br></pre></td></tr></table></figure>
<p>MyBatis从3.4.5版本开始就完全支持了LocalDateTime, 如果使用的是旧版本请升级下，如果是由于三方库使用的mybatis版本较低，可以排除内嵌的引用，单独引用新版本</p>
<h1 id="旧系统处理"><a href="#旧系统处理" class="headerlink" title="旧系统处理"></a>旧系统处理</h1><p>当项目无法升级到Java8+环境的，也无需担心，可以使用<strong>Joda-Time</strong>这个库，值得一提的是，Joda-Time的作者Stephen Colebourne和Oracle一起共同参与了java8新的API的设计和实现，用法上基本同Java8一致</p>
<p>当然Joda-Time也有一些功能(如用来表示一对时间的Interval)是java8还没支持的，所以Stephen Colebourne又提供了一个新的第三方库<strong>Threeten</strong>来弥补Java 8的不足</p>
<p>Threeten主要提供两种发行包：</p>
<ul>
<li>ThreeTen-Backport：对Java 6和Java 7的项目提供Java 8的date-time类的支持</li>
<li>ThreeTen-Extra：为Java 8的date-time类提供额外的增强功能（比如：Interval等）</li>
</ul>
<h1 id="Android项目"><a href="#Android项目" class="headerlink" title="Android项目"></a>Android项目</h1><blockquote>
<p>Android到棉花糖上运行在Java 7(“Android N”是第一个引入Java 8语言特性的版本)。因此，除非你只针对Android NoGuAT和以上，否则你不能依赖Java 8语言特性</p>
</blockquote>
<p>因为Android项目对于内存要求较高，Joda-Time不是最好的选择，ThreeTen-Backport也存在一些性能问题(使用JAR资源加载时区信息)，这个时候Android界的大神<strong>jakewharton</strong>提供了<a href="https://github.com/JakeWharton/ThreeTenABP">threetenabp</a>, 他的github上也说明了为什么不推荐使用Joda-Time和ThreeTen-Backport</p>
<p>所以如果你的Android项目需兼容老版本(现在还有需要兼容4.4-的):</p>
<ul>
<li>在app/build.gradle中引用threetenabp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;com.jakewharton.threetenabp:threetenabp:1.2.4&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Application.onCreate()方法中初始化时区信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public void onCreate() &#123;</span><br><span class="line">  super.onCreate();</span><br><span class="line">  AndroidThreeTen.init(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以愉快的使用LocalDateTime等新类了</p>
<h1 id="Date及Calendar不便之处"><a href="#Date及Calendar不便之处" class="headerlink" title="Date及Calendar不便之处"></a>Date及Calendar不便之处</h1><p>前面说了Java8+的新api，下面我们说一说旧的Date及Calendar的不便之处，以便放弃</p>
<ul>
<li>首先就是获取年月日的时候的加减1了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(date.getYear() + 1900); &#x2F;&#x2F; 必须加上1900</span><br><span class="line">System.out.println(date.getMonth() + 1); &#x2F;&#x2F; 0~11，必须加上1</span><br><span class="line">System.out.println(date.getDate()); &#x2F;&#x2F; 1~31，不能加1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Date不能直接转换时区，并且总是以当前计算机系统的默认时区为基础进行输出(Date对象无时区信息，时区信息存储在SimpleDateFormat中)</p>
</li>
<li><p>相比较locaDateTime丰富的时间处理(获取前一天，两个时间差等)，Date需要额外编写DateUtils(网上各种搜索,还不一定正确)</p>
</li>
</ul>
<p>Calendar可以用于获取并设置年、月、日、时、分、秒，多了可以做简单的日期和时间运算的功能，但是:</p>
<ul>
<li><p>Calendar只有一种方式获取，即Calendar.getInstance()，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段</p>
</li>
<li><p>Calendar获取年月日这些信息变成了get(int field)，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，1~7分别表示周日，周一，……，周六。</p>
</li>
<li><p>最后就是常见的多线程安全的问题了, SimpleDateFormat线程不安全(原因网上自行搜索下)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-集合</title>
    <url>/20201014/java/b4ef74d7/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java的java.util包主要提供了以下四种类型的集合：</p>
<ul>
<li><p>List：一种有序列表的集合</p>
</li>
<li><p>Set：一种保证没有重复元素的集合</p>
</li>
<li><p>Map：一种通过键值（key-value）查找的映射表集合</p>
</li>
<li><p>Queue: 先进先出（FIFO：First In First Out）的有序表</p>
<a id="more"></a>

</li>
</ul>
<p>Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的，<br>ListIterator是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。 Iterator 只能向前移动，而 ListIterator 可以双向移动。</p>
<p><img src="iterable.png" alt="iterable"></p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><img src="list.png" alt="list"></p>
<blockquote>
<p>ArrayList</p>
</blockquote>
<p>ArrayList在内部使用了数组来存储所有元素。可以看作是能够自动增长容量的数组。例如，一个ArrayList拥有5个元素，实际数组大小为6（即有一个空位）</p>
<blockquote>
<p>LinkedList</p>
</blockquote>
<p>通过链表实现了List接口。在LinkedList中，它的内部每个元素都指向下一个元素</p>
<p>LinkedList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指<strong>数据量很大或者操作很频繁</strong>(当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣与ArrayList，且越靠近后面越差)</p>
<blockquote>
<p>CopyOnWriteArrayList</p>
</blockquote>
<p>juc中提供的在并发编程中读多写少的场景下的list实现, 原理是任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全</p>
<blockquote>
<p>Vector<br>线程安全的List实现，在方法上加入synchronized。现在一般不推荐使用了，可用Collections.synchronizedList来包装集合使用</p>
</blockquote>
<h2 id="与Array的区别及转换"><a href="#与Array的区别及转换" class="headerlink" title="与Array的区别及转换"></a>与Array的区别及转换</h2><p>数组和List类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组{‘A’, ‘B’, ‘C’, ‘D’, ‘E’}中删除索引为2的元素</p>
<p>这个“删除”操作实际上是把’C’后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦</p>
<blockquote>
<p>list转array</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer[] array &#x3D; list.toArray(Integer[]::new);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Integer[] array &#x3D; list.toArray(new Integer[list.size()]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>array转list</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer[] array &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">List&lt;Integer&gt; list &#x3D; List.of(array);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;java 11之前的版本，可以使用Arrays.asList(T...)方法把数组转换成List</span><br></pre></td></tr></table></figure>

<p>要注意的是，返回的List不一定就是ArrayList或者LinkedList，因为List只是一个接口，如果我们调用List.of()，它返回的是一个只读List。对只读List调用add()、remove()方法会抛出UnsupportedOperationException</p>
<p><strong>如果对 List 对象做了任何修改，又不想让原始数组被修改，那么就应该在另一个集合中创建一个副本。</strong></p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><img src="set.png" alt="set"></p>
<p>Set用于存储不重复的元素集合,如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素</p>
<p>Set接口并不保证有序，而SortedSet接口则保证元素是有序的：</p>
<blockquote>
<p>HashSet</p>
</blockquote>
<p>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口。HashSet内部通过维护一个HashMap来实现读取插入等功能</p>
<blockquote>
<p>TreeSet</p>
</blockquote>
<p>TreeSet是有序的，因为它实现了SortedSet接口。使用TreeSet和使用TreeMap的要求一样，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象, 可按照条件进行排序</p>
<blockquote>
<p>LinkedHashSet</p>
</blockquote>
<p>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同, LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的</p>
<p><strong>LinkedHashSet输出顺序是确定的，就是插入时的顺序</strong></p>
<blockquote>
<p>CopyOnWriteArraySet</p>
</blockquote>
<p>juc中提供的在并发编程中读多写少的场景下的set实现，内部维护了一个CopyOnWriteArrayList，CopyOnWriteArraySet相对CopyOnWriteArrayList用来存储不重复的对象</p>
<blockquote>
<p>ConcurrentSkipListSet</p>
</blockquote>
<p>juc中提供的在并发编程中线程安全的有序的集合，适用于高并发的场景。ConcurrentSkipListMap其实是TreeMap的并发版本，但实现是不一样的：ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的</p>
<p><em>Set 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 Set 中。因此，查找通常是 Set 最重要的操作，因此通常会选择 HashSet 实现，该实现针对快速查找进行了优化。</em></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="map.png" alt="map"></p>
<p>map相关的介绍在<a href="/20200811/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/57e2d1c0">java多线程6-ConcurrentHashMap</a>有体现，另外再补充一个EnumMap</p>
<blockquote>
<p>EnumMap</p>
</blockquote>
<p>如果作为key的对象是enum类型，可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，既保证速度，也不浪费空间</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><img src="queue.png" alt="queue"></p>
<h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><p>它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>抛异常</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>增(把元素添加到队列末尾)</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>删(从队列头部取出元素)</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查(或者说瞧，看队列中还有没有元素)</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p>两组方法的区别：</p>
<ol>
<li>如果队列空了，那 remove() 会抛异常，而poll() 返回null；element() 会抛异常，而 peek() 返回null;</li>
<li>有些队列(如BlockingQueue)会有容量的限制，当达到了最大的容量且不会扩容时，使用add(e)就会抛异常；而 offer(e) 返回false;</li>
</ol>
<p><em>所以使用时尽量前后统一，即前面使用了add(e)后面就使用remove()，前面使用了offer(e)后面就使用poll();</em></p>
<blockquote>
<p>PriorityQueue</p>
</blockquote>
<p>优先队列,它的出队顺序与元素的优先级有关(如排队时vip的处理)</p>
<p>PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）</p>
<blockquote>
<p>BlockingQueue</p>
</blockquote>
<p>并发编程中经常用到了阻塞队列，如线程池的任务队列<a href="/20200723/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/87bed628">java多线程2-线程池</a>，它是基于ReentrantLock</p>
<p><strong>阻塞队列BlockingQueue就是为线程之间共享数据而设计的</strong></p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</li>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</li>
</ul>
<p>这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>双端队列(允许两头都进，两头都出)，那自然是有针对First端的操作和对Last端的操作：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>抛异常</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>增(把元素添加到队列头部/末尾)</td>
<td>addFirst(e)/ addLast(e)</td>
<td>offerFirst(e)/ offerLast(e)</td>
</tr>
<tr>
<td>删(从队列头部/末尾取出元素)</td>
<td>removeFirst()/ removeLast()</td>
<td>pollFirst()/ pollLast()</td>
</tr>
<tr>
<td>查(或者说瞧，看队列中还有没有元素)</td>
<td>getFirst()/ getLast()</td>
<td>peekFirst()/ peekLast()</td>
</tr>
</tbody></table>
<p><strong>LinkedList即是List，又是Queue，还是Deque</strong>,但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用</p>
<ul>
<li>getFirst() 和 element() 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 List 为空，则抛出 NoSuchElementException 异常。 peek() 方法与这两个方法只是稍有差异，它在列表为空时返回 null 。</li>
<li>removeFirst() 和 remove() 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 NoSuchElementException 异常。 poll() 稍有差异，它在列表为空时返回 null 。</li>
<li>addFirst() 在列表的开头插入一个元素。</li>
<li>offer() 与 add() 和 addLast() 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li>removeLast() 删除并返回列表的最后一个元素。</li>
</ul>
<p><em>使用时一样，尽量用同一组方法</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是一个List:</span><br><span class="line">List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 这是一个Queue:</span><br><span class="line">Queue&lt;String&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li>Hashtable：一种线程安全的Map实现；</li>
<li>Vector：一种线程安全的List实现；</li>
<li>Stack：基于Vector实现的LIFO的栈(Java 6 添加了 ArrayDeque ，其中包含直接实现堆栈功能的方法)</li>
</ul>
<p>如使用ArrayDeque封装下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;T&gt; storage = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; storage.push(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.peek(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.isEmpty(); &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> storage.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span></span><br></pre></td></tr></table></figure>

<p>还有一小部分接口是遗留接口，也不应该继续使用：Enumeration<E>：已被Iterator<E>取代。</p>
<h2 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h2><table>
<thead>
<tr>
<th>interface</th>
<th>non-thread-safe</th>
<th>thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>ArrayList</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>ConcurrentHashMap</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet / TreeSet</td>
<td>CopyOnWriteArraySet</td>
</tr>
<tr>
<td>Queue</td>
<td>ArrayDeque / LinkedList</td>
<td>ArrayBlockingQueue / LinkedBlockingQueue</td>
</tr>
<tr>
<td>Deque</td>
<td>ArrayDeque / LinkedList</td>
<td>LinkedBlockingDeque</td>
</tr>
</tbody></table>
<p>java.util.Collections工具类还提供了一个旧的线程安全集合转换器，可以这么用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map unsafeMap &#x3D; new HashMap();</span><br><span class="line">Map threadSafeMap &#x3D; Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>
<p>但是它实际上是用一个包装类包装了非线程安全的Map，然后对所有读写方法都用synchronized加锁，这样获得的线程安全集合的性能比java.util.concurrent集合要低很多，一般不推荐使用。</p>
<p>例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class SynchronizedMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private final Map&lt;K,V&gt; m;     &#x2F;&#x2F; Backing Map</span><br><span class="line">    final Object      mutex;        &#x2F;&#x2F; Object on which to synchronize</span><br><span class="line">    &#x2F;&#x2F; …</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        synchronized (mutex) &#123;return m.size();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;&#x2F; … </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>java提供了Collections方便集合的操作</p>
<ul>
<li>排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; Arrays.asList(2, 4, 9, 3, 1, 5, 8, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;排序</span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(&quot;list: &quot; + list);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;倒序</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(&quot;list: &quot; + list);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reverse的意思是反转，而不是降序。只是将list集合原来的顺序反转了一下，反转并不意味着降序了。所以要想实现降序，可以先对集合进行升序，然后再反转，这样就降序了</p>
</blockquote>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>如果要经常随机访问，推荐ArrayList</li>
<li>如果经常从列表的任意位置插入或者删除元素，推荐LinkedList</li>
<li>如果需模拟堆栈(后进先出)，推荐LinkedList</li>
<li>使用map如果不要求顺序，推荐HashMap</li>
<li>使用map如果需要根据自己需要进行排序，推荐TreeMap</li>
<li>使用map如果需要按照插入的顺序进行访问，又想保持快速访问的能力，推荐LinkedHashMap</li>
<li>想要列表中不存在重复元素，推荐set, 由于set的很多实现类实际上是map实现类的特殊存在(value为空对象的map), 故使用哪个实现类同map一样</li>
</ul>
<blockquote>
<p>不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack(替代为ArrayDeque)</p>
</blockquote>
<h1 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h1><blockquote>
<p>Vector 和 ArrayList 的区别是什么？</p>
</blockquote>
<ol>
<li>线程安全问题，Vector在很多方法上都添加了synchronized以保障线程安全，但线程安全的成本就是效率会降低，在某些系统里很容易成为瓶颈； </li>
<li>扩容时ArrayList的新容量是原容量的<strong>1.5</strong>倍，而Vector默认则为两倍；</li>
</ol>
<blockquote>
<p>ArrayDeque 和 LinkedList 的区别有哪些？</p>
</blockquote>
<ol>
<li>ArrayDeque 是一个可扩容的数组，LinkedList 是链表结构；</li>
<li>ArrayDeque 里不可以存 null 值，</li>
<li>但是 LinkedList 可以；ArrayDeque 在操作头尾端的增删操作时更高效，但是 LinkedList 只有在当要移除中间某个元素且已经找到了这个元素后的移除才是 O(1) 的；</li>
<li>ArrayDeque 在内存使用方面更高效。</li>
</ol>
<p>所以，如果要实现普通的队列<strong>只要不是必须要存null值，推荐ArrayDeque</strong>。当然如果需要兼容Java6之前的版本就得用LinkedList，因为ArrayDeque是Java6才引入的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java8开发小技巧-获取两个时间的时间差</title>
    <url>/20200812/java/java8/16e93703/</url>
    <content><![CDATA[<p>日常开发中经常会需要计算一个方法执行了多久:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;模拟方法执行，花费2s</span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line"></span><br><span class="line">long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;花费 &quot; + (endTime - startTime) + &quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>

<p>java8之后提供了新的时间日期处理类，那么Java8之后就可以使用ChronoUnit:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime startTime &#x3D; LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;模拟方法执行，花费2s</span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line"></span><br><span class="line">LocalDateTime endTime &#x3D;  LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;花费 &quot; + ChronoUnit.MILLIS.between(startTime, LocalDateTime.now()) + &quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<blockquote>
<p>System.currentTimeMillis()只能精确到毫秒，如果你有更高的要求，要精确到纳秒，或者只需要秒、分钟等，java8可以轻松搞定，利用ChronoUnit的不同枚举单位计算即可：</p>
</blockquote>
<ul>
<li>CENTURIES    代表一个世纪概念的单位。</li>
<li><strong>DAYS</strong>    代表一天概念的单位</li>
<li>DECADES    代表十年概念的单位</li>
<li>ERAS    代表一个时代概念的单位</li>
<li>FOREVER    代表永恒概念的人工单位</li>
<li>HALF_DAYS    代表AM / PM中使用的半天概念的单位</li>
<li><strong>HOURS</strong>    表示一小时概念的单位</li>
<li><strong>MICROS</strong>    表示微秒概念的单位</li>
<li>MILLENNIA    代表千年概念的单位</li>
<li><strong>MILLIS</strong>    表示毫秒概念的单位</li>
<li><strong>MINUTES</strong>    表示一分钟概念的单位</li>
<li><strong>MONTHS</strong>    代表一个月概念的单位</li>
<li><strong>NANOS</strong>    代表纳秒概念的单位，是支持的最小时间单位</li>
<li><strong>SECONDS</strong>    表示一秒概念的单位。</li>
<li>WEEKS    表示一周概念的单位。</li>
<li>YEARS    代表一年概念的单位</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>javaFx-属性绑定</title>
    <url>/20201119/java/javafx/ba53eabe/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>javafx.beans.property包提供了丰富的Property类用于对java对象中的属性和javaFX UI控件进行绑定，可达到：</p>
<ul>
<li>在任意位置修改java对象的值时可实时更新绑定的UI控件的显示，无需手动编写更新方法</li>
<li>javaFX UI控件进行变化时(如用户输入内容)，实时写入对应的java对象中，无需手动设置</li>
</ul>
<table>
<thead>
<tr>
<th>java属性</th>
<th>javaFx对应Property</th>
<th>绑定构建类</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>IntegerProperty</td>
<td>JavaBeanIntegerPropertyBuilder</td>
</tr>
<tr>
<td>Integer</td>
<td>ObjectProperty&lt;Integer&gt;</td>
<td>JavaBeanObjectPropertyBuilder</td>
</tr>
<tr>
<td>long</td>
<td>LongProperty</td>
<td>JavaBeanLongPropertyBuilder</td>
</tr>
<tr>
<td>Long</td>
<td>ObjectProperty&lt;Long&gt;</td>
<td>JavaBeanObjectPropertyBuilder</td>
</tr>
<tr>
<td>String</td>
<td>StringProperty</td>
<td>JavaBeanStringPropertyBuilder</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，如果java对象中的属性为基本数据类型的包装类，则不能直接使用对应的Property，需使用ObjectProperty<T>, 否则在属性值为null时会报空指针异常(原因是其内部都是使用基本数据类型转换的，感兴趣可以看看源码中的实现)</p>
</blockquote>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面我们就来看看如何实现的</p>
<ul>
<li>新建简单javaBean</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyJavaBean implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private int myInt;</span><br><span class="line"></span><br><span class="line">    private Integer myInteger;</span><br><span class="line"></span><br><span class="line">    private String myString;</span><br><span class="line"></span><br><span class="line">    public int getMyInt() &#123;</span><br><span class="line">        return myInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyInt(int myInt) &#123;</span><br><span class="line">        this.myInt &#x3D; myInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getMyInteger() &#123;</span><br><span class="line">        return myInteger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyInteger(Integer myInteger) &#123;</span><br><span class="line">        this.myInteger &#x3D; myInteger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getMyString() &#123;</span><br><span class="line">        return myString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyString(String myString) &#123;</span><br><span class="line">        this.myString &#x3D; myString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyJavaBean&#123;&quot; +</span><br><span class="line">                &quot;myInt&#x3D;&quot; + myInt +</span><br><span class="line">                &quot;, myInteger&#x3D;&quot; + myInteger +</span><br><span class="line">                &quot;, myString&#x3D;&#39;&quot; + myString + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>新建javaFxWrapper类，用于实现javaBean与javaFx UI控件的属性绑定</li>
</ul>
<p>重点在于<strong>JavaBeanObjectPropertyBuilder</strong>等的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyJavaBeanFxWrapper &#123;</span><br><span class="line"></span><br><span class="line">    private MyJavaBean myJavaBean;</span><br><span class="line"></span><br><span class="line">    private IntegerProperty myInt;</span><br><span class="line"></span><br><span class="line">    private ObjectProperty&lt;Integer&gt; myInteger;</span><br><span class="line"></span><br><span class="line">    private StringProperty myString;</span><br><span class="line"></span><br><span class="line">    public MyJavaBeanFxWrapper(MyJavaBean myJavaBean) throws NoSuchMethodException &#123;</span><br><span class="line">        this.myJavaBean &#x3D; myJavaBean;</span><br><span class="line">        intProperty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MyJavaBeanFxWrapper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">    private void intProperty() throws NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        myInt &#x3D; JavaBeanIntegerPropertyBuilder.create().bean(this.myJavaBean).name(&quot;myInt&quot;).build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;IntegerProperty如果遇到bean中属性值为null时，初始化会报错(内部使用int，转换出错)，故需使用ObjectProperty&lt;Integer&gt;</span><br><span class="line">        myInteger &#x3D; JavaBeanObjectPropertyBuilder.create().bean(this.myJavaBean).name(&quot;myInteger&quot;).build();</span><br><span class="line"></span><br><span class="line">        myString &#x3D; JavaBeanStringPropertyBuilder.create().bean(this.myJavaBean).name(&quot;myString&quot;).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyJavaBean getMyJavaBean() &#123;</span><br><span class="line">        return myJavaBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyJavaBean(MyJavaBean myJavaBean) throws NoSuchMethodException &#123;</span><br><span class="line">        this.myJavaBean &#x3D; myJavaBean;</span><br><span class="line">        intProperty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMyInt() &#123;</span><br><span class="line">        return myInt.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IntegerProperty myIntProperty() &#123;</span><br><span class="line">        return myInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getMyInteger() &#123;</span><br><span class="line">        return myInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ObjectProperty&lt;Integer&gt; myIntegerProperty() &#123;</span><br><span class="line">        return myInteger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getMyString() &#123;</span><br><span class="line">        return myString.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StringProperty myStringProperty() &#123;</span><br><span class="line">        return myString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个比较好的习惯就是两个对象中的属性命名尽量保持一致，可以减少因属性名不一致造成的绑定失败的概率</p>
</blockquote>
<ul>
<li>Controller中进行绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Controller implements Initializable &#123;</span><br><span class="line"></span><br><span class="line">    public Label intLabel, integerLabel, stringLabel;</span><br><span class="line"></span><br><span class="line">    public TextField intTextField, integerTextField, stringTextField;</span><br><span class="line"></span><br><span class="line">    private MyJavaBeanFxWrapper myJavaBeanFxWrapper;</span><br><span class="line">    private MyJavaBean myJavaBean;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(URL location, ResourceBundle resources) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;定义java对象</span><br><span class="line">            myJavaBean &#x3D; new MyJavaBean();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将java对象设置到javafx辅助类中，以支持属性绑定</span><br><span class="line">            myJavaBeanFxWrapper &#x3D; new MyJavaBeanFxWrapper(myJavaBean);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;控件只做显示, 单向绑定即可</span><br><span class="line">            intLabel.textProperty().bind(myJavaBeanFxWrapper.myIntProperty().asString());</span><br><span class="line">            integerLabel.textProperty().bind(myJavaBeanFxWrapper.myIntegerProperty().asString());</span><br><span class="line">            stringLabel.textProperty().bind(myJavaBeanFxWrapper.myStringProperty());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;控件可编辑，双向绑定</span><br><span class="line">            intTextField.textProperty().bindBidirectional(myJavaBeanFxWrapper.myIntProperty(), new StringConverter&lt;&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String toString(Number object) &#123;</span><br><span class="line">                    return String.valueOf(object);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public Number fromString(String string) &#123;</span><br><span class="line">                    return Integer.valueOf(string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            integerTextField.textProperty().bindBidirectional(myJavaBeanFxWrapper.myIntegerProperty(), new StringConverter&lt;&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String toString(Integer object) &#123;</span><br><span class="line">                    return String.valueOf(object);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public Integer fromString(String string) &#123;</span><br><span class="line">                    if(&quot;&quot;.equals(string)) &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return Integer.valueOf(string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            stringTextField.textProperty().bindBidirectional(myJavaBeanFxWrapper.myStringProperty());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就达到了在不破坏原有javabean的基础上通过新建一个javaFx的辅助类，即可实现UI与数据对象的绑定，大大方便了javaFx的的日常开发</p>
<blockquote>
<p>日常开发时建议将java对象设置到javaFx辅助类中后，就直接使用javaFx的辅助类进行操作，只有最后需要保存或者传递时才获取java原始对象</p>
</blockquote>
<h2 id="list的绑定"><a href="#list的绑定" class="headerlink" title="list的绑定"></a>list的绑定</h2><p>javaFx中承载list数据的控件一般为listView，下面我们就演示下如何进行list的绑定</p>
<ul>
<li>javabean中新增list属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyJavaBean implements Serializable &#123; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; myStringList;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter&#x2F;setter</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>javaFxWrapper类中新增对应绑定</li>
</ul>
<p>javaFx提供了<strong>ObservableList</strong>以实现list数据的动态监听，而UI控件也直接与这个ObservableList进行交互</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyJavaBeanFxWrapper &#123; </span><br><span class="line">    ...</span><br><span class="line">    private ListProperty&lt;String&gt; myStringList;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">    private void intProperty() throws NoSuchMethodException &#123;</span><br><span class="line">        ...</span><br><span class="line">        myStringList &#x3D; new SimpleListProperty&lt;&gt;(FXCollections.observableArrayList());</span><br><span class="line">        if(myJavaBean.getMyStringList() !&#x3D; null) &#123;</span><br><span class="line">            myStringList.addAll(myJavaBean.getMyStringList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里需手动设置到原始对象中(暂时没找到自动绑定的方法)</span><br><span class="line">        &#x2F;&#x2F;除非原始javabean中的list属性为ObservableList类型，才可以直接使用</span><br><span class="line">        &#x2F;&#x2F;myStringList &#x3D; new SimpleListProperty&lt;&gt;(this.myJavaBean, &quot;myStringList&quot;, myJavaBean.getMyStringList());</span><br><span class="line">        &#x2F;&#x2F;但如此javabean中就会引入javafx相关包，当然不介意这个的就可以改写使用</span><br><span class="line">        myStringList.addListener((observable, oldValue, newValue) -&gt; myJavaBean.setMyStringList(newValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ObservableList&lt;String&gt; getMyStringList() &#123;</span><br><span class="line">        return myStringList.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListProperty&lt;String&gt; myStringListProperty() &#123;</span><br><span class="line">        return myStringList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Controller中进行绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Controller implements Initializable &#123; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    public ListView&lt;String&gt; listView;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">    public void initialize(URL location, ResourceBundle resources) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           &#x2F;&#x2F;有关UI上的操作尽量都使用myJavaBeanFxWrapper来修改数据</span><br><span class="line">            myJavaBeanFxWrapper.myStringListProperty().addAll(&quot;123&quot;, &quot;456&quot;, &quot;789&quot;);</span><br><span class="line">            myJavaBeanFxWrapper.getMyStringList().addAll(&quot;www&quot;, &quot;eee&quot;, &quot;rrr&quot;);</span><br><span class="line">            listView.itemsProperty().bind(myJavaBeanFxWrapper.myStringListProperty());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然以上做法有一个注意要点，即javabean在初始化后就不能自己通过setMyStringList来同步UI了(除非直接使用的ObservableList)，尽量都使用myJavaBeanFxWrapper或listView的getItems()进行操作，当javabean因为外在因素，如从网络上重新加载了，需重新设置到myJavaBeanFxWrapper</p>
</blockquote>
<h2 id="自定义对象绑定"><a href="#自定义对象绑定" class="headerlink" title="自定义对象绑定"></a>自定义对象绑定</h2><p>javabean中除了基本数据类型及其包装类、String、list(集合)外，还可能会有自定义的对象属性，使用ObjectProperty即可, 但这种做法的颗粒度不太细，推荐还是新增对应自定义子对象的Fxwrapper，并在javabean变化时进行绑定初始化</p>
<p>示例代码使用的是java14+javafx14，<a href="https://github.com/jonesun/javafx-property-test">github-javafx-property-test</a>, 如果还是使用的javafx8则不需要pom.xml中对于openjfx的引用</p>
<h1 id="属性绑定常用方法"><a href="#属性绑定常用方法" class="headerlink" title="属性绑定常用方法"></a>属性绑定常用方法</h1><p>bind(): 单向绑定</p>
<p>bindBidirectional(): 双向绑定</p>
<p>addListener()：添加监听</p>
<blockquote>
<p>The ObservableValue stores a strong reference to the listener which will prevent the listener from being garbage collected and may result in a memory leak. It is recommended to either unregister a listener by calling removeListener after use or to use an instance of WeakChangeListener avoid this situation.它是一个强引用的Listener，有可能会引起内存泄露，推荐的解决办法是使用完之后调用removeListener，或者使用WeakChangeListener这个弱引用的监听。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">styleTypeToggleGroup.selectedToggleProperty().addListener(new WeakChangeListener&lt;&gt;((observable, oldValue, newValue) -&gt; &#123;</span><br><span class="line">            updateView();</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>javafx</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javafx</tag>
      </tags>
  </entry>
  <entry>
    <title>javaFx发展</title>
    <url>/20200520/java/javafx/a81ff2a/</url>
    <content><![CDATA[<h2 id="javaFx发展"><a href="#javaFx发展" class="headerlink" title="javaFx发展"></a>javaFx发展</h2><p>从 JDK 11 开始，Oracle 将从 JDK 中删除 JavaFX，但在 2022 年之前，Oracle 还会继续为 JDK 8 中的 JavaFX 提供商业支持。2011 年，JavaFX 成为 Open JDK 的一部分开源，这项技术的发展现在由 <a href="https://openjfx.io/">OpenFX</a> (<a href="https://openjfx.cn/">国内网站</a> )社区负责</p>
<p>当然如果是基于高版本的jdk开发, 推荐使用<a href="https://bell-sw.com/pages/java-8u242/">Liberica JDK-不仅包含了 JavaFX，还继续为 Windows 以及 Linux 提供 32 位构建</a>, 下载Full version版本就可以无缝切换</p>
<p>学习javaFx常用布局控件可参考<a href="http://tutorials.jenkov.com/javafx/index.html">JavaFX Tutorial</a></p>
 <a id="more"></a>

<h2 id="为何使用javaFx"><a href="#为何使用javaFx" class="headerlink" title="为何使用javaFx"></a>为何使用javaFx</h2><blockquote>
<p>跨平台</p>
</blockquote>
<p>JavaFX可在Windows、Mac OS X和Linux上运行，利用 JavaFX 能够非常轻松的搭建出在各个平台下体验基本一致的应用，甚至有人还将 JavaFX 移植到安卓上</p>
<blockquote>
<p>学习成本低</p>
</blockquote>
<ul>
<li><p>有 Java 基础的完全能够通过阅读项目源码以及少量借助搜索引擎来学会使用，由于本身是基于java开发的，所以可以支持各类java第三方库，包括集成Spring Boot来构建项目</p>
</li>
<li><p>支持通过 fxml 和 css 来编写界面，有前端或者android开发经验者均可快速上手</p>
</li>
</ul>
<blockquote>
<p>web方向支持</p>
</blockquote>
<ul>
<li><p>拥有一个 WebView 组件，可以通过js与原生java交互，实现丰富的功能</p>
</li>
<li><p>可运行于服务器端，通过浏览器提供用户访问，可参考<a href="https://www.jpro.one/?page=demos">jpro</a></p>
</li>
</ul>
<blockquote>
<p>支持使用Spring Boot管理</p>
</blockquote>
<ul>
<li>可充分使用Spring Boot各类支持库</li>
</ul>
<p><a href="https://github.com/jonesun/javafx-test-with-javapackager">javafx-test-with-javapackager</a></p>
<p><a href="https://gitee.com/sunr7/TestOpenjfx14">TestOpenJfx14</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext springContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        springContext = SpringApplication.run(MyApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Parent root = FXMLLoader.load(getClass().getResource(&quot;/fxml/main.fxml&quot;), null, null, springContext::getBean);</span></span><br><span class="line">        <span class="comment">//或者</span></span><br><span class="line">        FXMLLoader fxmlLoader = <span class="keyword">new</span> FXMLLoader(getClass().getResource(<span class="string">&quot;/fxml/main.fxml&quot;</span>));</span><br><span class="line">        fxmlLoader.setControllerFactory(springContext::getBean);</span><br><span class="line">        Parent root = fxmlLoader.load();</span><br><span class="line"></span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        primaryStage.setScene(<span class="keyword">new</span> Scene(root, <span class="number">800</span>, <span class="number">700</span>));</span><br><span class="line">        primaryStage.show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        springContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了能正常使用Desktop.getDesktop()相关方法</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;java.awt.headless&quot;</span>, Boolean.toString(<span class="keyword">false</span>));</span><br><span class="line">        launch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> <span class="keyword">implements</span> <span class="title">Initializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContext springContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Scene</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionEvent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scene <span class="title">getScene</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Node) actionEvent.getSource()).getScene();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Stage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionEvent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stage <span class="title">getStage</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">        Scene scene = getScene(actionEvent);</span><br><span class="line">        <span class="keyword">return</span> (Stage) scene.getWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Stage</span></span><br><span class="line"><span class="comment">     * 注意如果是在initialize中获取的话需使用 Platform.runLater(() -&gt; Stage stage = getStage(node);&#125;);</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stage <span class="title">getStage</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Stage) node.getScene().getWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionEvent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fxmlName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openController</span><span class="params">(ActionEvent actionEvent, String fxmlName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scene scene = getScene(actionEvent);</span><br><span class="line">        Parent root = FXMLLoader.load(getClass().getResource(fxmlName), <span class="keyword">null</span>, <span class="keyword">null</span>, springContext::getBean);</span><br><span class="line">        scene.setRoot(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/jonesun/javafx8-springboot-demo">示例</a></p>
<blockquote>
<p>支持自动更新</p>
</blockquote>
<p>java8使用<a href="https://github.com/edvin/fxlauncher">fxlauncher</a>, java9+使用<a href="https://github.com/update4j/update4j">update4j</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;bufferedImage转image java11+需引用javafx-swing</span><br><span class="line">new ImageView(SwingFXUtils.toFXImage(bufferedImage, null))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>javafx</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javafx</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/20200811/java/b8b0eacd/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><a href="/20201130/java/aee68e6b">java-引用</a></p>
<p><a href="/20201014/java/b4ef74d7">java-集合</a></p>
<p><a href="/20201022/java/1956c086">java-时间</a></p>
<p><a href="/20201022/java/ddadecb7">java-io</a></p>
<p><a href="/20200713/java/3a0ad540">java-随机数</a></p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p><a href="/20200801/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/11bde6ec">java多线程</a></p>
<p><a href="/20200811/java/designPatterns/56df777e">java设计模式</a></p>
<p><a href="/20201009/java/springboot/7b2ee301">SpringBoot集成使用</a></p>
<p><a href="/20210319/java/springcloud/55535">SpringCloud集成使用</a></p>
<h2 id="资料整理"><a href="#资料整理" class="headerlink" title="资料整理"></a>资料整理</h2><p><a href="https://jonesun.gitee.io/java-new-features/">Java新特性</a> Java9之后到Java14</p>
<p><a href="https://jonesun.gitee.io/java8-learning/">Java8特性介绍</a> </p>
<p><a href="https://jonesun.gitee.io/rxjava_learning/">RxJava学习</a> </p>
 <a id="more"></a>

<h1 id="开发小技巧"><a href="#开发小技巧" class="headerlink" title="开发小技巧"></a>开发小技巧</h1><p><a href="/20200812/java/java8/16e93703">java8开发小技巧-获取两个时间的时间差</a></p>
<p><a href="/20200720/java/520c60c5">JMH-Java微基准测试套件</a></p>
<blockquote>
<p>使用<code>System.getProperties().list(System.out);</code>可输出可用的环境信息列表, 或者使用System.getenv()获取map</p>
</blockquote>
<blockquote>
<p>float 和 double 类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮点运算（binary floating-point arithmetic），这是为了在广泛的数值范围上提供较为精确为快速的近似计算而精心设计的。<br>然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。<br>使用 BigDecimal、int 或者 long 进行货币计算(如果数值范围没有超过 9 为十进制数字，就可以使用 int；如果不超过 18 位数字，就可以使用 long。<br>如果数值可能超过 18 位数字，就必须使用 BigDecimal。)</p>
</blockquote>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><p>内存泄露怎么分析？怎么知道整条内存泄露的链路？</p>
<p>一般方法，jmap dump出转储文件，然后通过MAT等一些工具来做具体的分析。</p>
<p>怎么查看jvm里线程状态？</p>
<p>jstack进程ID就可以了</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/20200801/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/11bde6ec/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><blockquote>
<p>任何并发能做的事情，单进程也能够实现，只不过这种方式效率很低，它是一种顺序性的</p>
</blockquote>
<p><a href="/20200714/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/36c04c8a">java多线程1-从Thread到Future再到CompletableFuture</a></p>
<p><a href="/20200723/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/87bed628">java多线程2-线程池</a></p>
<p><a href="/20200728/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/a490755">java多线程3-fork-join框架</a></p>
<p><a href="/20200730/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/cc62b819">java多线程4-volatile&amp;synchronized</a></p>
<p><a href="/20200731/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/d2a4479b">java多线程5-并发同步器CountDownLatch&amp;CyclicBarrier&amp;Semaphore</a></p>
<p><a href="/20200811/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/57e2d1c0">java多线程6-ConcurrentHashMap</a></p>
<p><a href="/20200811/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/e45118f">java多线程7-atomic原子类</a></p>
<p><a href="/20200817/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/c9ab2479">java多线程8-locks锁</a></p>
<p><a href="/20200818/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/aa881dfa">java多线程9-BlockingQueue和BlockingDeque-待细化</a></p>
<p><a href="/20200824/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/b6038c0d">java多线程10-ThreadLocal</a></p>
 <a id="more"></a>

<h1 id="java14并发包结构"><a href="#java14并发包结构" class="headerlink" title="java14并发包结构"></a>java14并发包结构</h1><p>共计 17(atomic) + 10(locks) + 61 = 88个类</p>
<h2 id="juc-atomic-原子类"><a href="#juc-atomic-原子类" class="headerlink" title="juc-atomic 原子类"></a>juc-atomic 原子类</h2><h3 id="1-原子类"><a href="#1-原子类" class="headerlink" title="1. 原子类"></a>1. 原子类</h3><p>AtomicInteger AtomicLong AtomicBoolean</p>
<p>AtomicReference AtomicStampedReference AtomicMarkableReference</p>
<h3 id="2-原子数组"><a href="#2-原子数组" class="headerlink" title="2. 原子数组"></a>2. 原子数组</h3><p>AtomicIntegerArray AtomicLongArray AtomicReferenceArray</p>
<h3 id="3-java8优化原子类"><a href="#3-java8优化原子类" class="headerlink" title="3. java8优化原子类"></a>3. java8优化原子类</h3><p>Striped64 -&gt; DoubleAccumulator DoubleAdder LongAccumulator LongAdder</p>
<h3 id="4-属性原子修改器"><a href="#4-属性原子修改器" class="headerlink" title="4. 属性原子修改器"></a>4. 属性原子修改器</h3><p>AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</p>
<hr>
<h2 id="juc-locks-锁"><a href="#juc-locks-锁" class="headerlink" title="juc-locks 锁"></a>juc-locks 锁</h2><h2 id="1-锁与读写锁"><a href="#1-锁与读写锁" class="headerlink" title="1. 锁与读写锁"></a>1. 锁与读写锁</h2><p>Lock ReadWriteLock</p>
<h2 id="2-锁的具体实现类-可重入锁"><a href="#2-锁的具体实现类-可重入锁" class="headerlink" title="2. 锁的具体实现类(可重入锁)"></a>2. 锁的具体实现类(可重入锁)</h2><p>ReentrantLock ReentrantReadWriteLock</p>
<h3 id="3-java8新增锁"><a href="#3-java8新增锁" class="headerlink" title="3. java8新增锁"></a>3. java8新增锁</h3><p>StampedLock</p>
<h3 id="4-等待-唤醒线程类"><a href="#4-等待-唤醒线程类" class="headerlink" title="4. 等待/唤醒线程类"></a>4. 等待/唤醒线程类</h3><p>Condition</p>
<h3 id="5-辅助类"><a href="#5-辅助类" class="headerlink" title="5. 辅助类"></a>5. 辅助类</h3><p>LockSupport</p>
<p>AbstractOwnableSynchronizer AbstractQueuedSynchronizer AbstractQueuedLongSynchronizer</p>
<hr>
<h2 id="juc-sync-同步器"><a href="#juc-sync-同步器" class="headerlink" title="juc-sync 同步器"></a>juc-sync 同步器</h2><p>CountDownLatch CyclicBarrier Semaphore</p>
<p>Exchanger Phaser</p>
<hr>
<h2 id="juc-collections-集合"><a href="#juc-collections-集合" class="headerlink" title="juc-collections 集合"></a>juc-collections 集合</h2><h3 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h3><p>ConcurrentMap ConcurrentHashMap ConcurrentSkipListMap ConcurrentNavigableMap</p>
<h3 id="2-set"><a href="#2-set" class="headerlink" title="2.set"></a>2.set</h3><p>CopyOnWriteArraySet ConcurrentSkipListSet</p>
<h3 id="3-list"><a href="#3-list" class="headerlink" title="3.list"></a>3.list</h3><p>CopyOnWriteArrayList</p>
<h3 id="4-queue"><a href="#4-queue" class="headerlink" title="4.queue"></a>4.queue</h3><h4 id="4-1普通队列"><a href="#4-1普通队列" class="headerlink" title="4.1普通队列"></a>4.1普通队列</h4><p>BlockingQueue ArrayBlockingQueue ConcurrentLinkedQueue LinkedBlockingQueue LinkedTransferQueue PriorityBlockingQueue SynchronousQueue DelayQueue TransferQueue</p>
<p>Delayed</p>
<h4 id="4-2双端队列"><a href="#4-2双端队列" class="headerlink" title="4.2双端队列"></a>4.2双端队列</h4><p>BlockingDeque LinkedBlockingDeque ConcurrentLinkedDeque</p>
<hr>
<h2 id="juc-executors-执行器"><a href="#juc-executors-执行器" class="headerlink" title="juc-executors 执行器"></a>juc-executors 执行器</h2><h3 id="1-Executor线程池"><a href="#1-Executor线程池" class="headerlink" title="1.Executor线程池"></a>1.Executor线程池</h3><p>AbstractExecutorService Executor ExecutorCompletionService Executors ExecutorService ScheduledThreadPoolExecutor RejectedExecutionHandler ThreadFactory ThreadPoolExecutor ScheduledExecutorService CompletionService CompletionStage</p>
<h3 id="2-Future"><a href="#2-Future" class="headerlink" title="2.Future"></a>2.Future</h3><p>Callable CompletableFuture Future FutureTask RunnableFuture RunnableScheduledFuture ScheduledFuture</p>
<h3 id="3-Fork-Join"><a href="#3-Fork-Join" class="headerlink" title="3.Fork/Join"></a>3.Fork/Join</h3><p>ForkJoinPool ForkJoinTask ForkJoinWorkerThread RecursiveAction RecursiveTask CountedCompleter</p>
<hr>
<h2 id="jus-其他"><a href="#jus-其他" class="headerlink" title="jus-其他"></a>jus-其他</h2><h3 id="1-java9新增支持响应式编程类"><a href="#1-java9新增支持响应式编程类" class="headerlink" title="1.java9新增支持响应式编程类"></a>1.java9新增支持响应式编程类</h3><p>SubmissionPublisher Flow</p>
<h3 id="2-异常类"><a href="#2-异常类" class="headerlink" title="2.异常类"></a>2.异常类</h3><p>BrokenBarrierException CancellationException CompletionException ExecutionException RejectedExecutionException TimeoutException</p>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><p>ThreadLocalRandom TimeUnit Helpers(非公开类)</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>并发：系统能处理多个任务，但同时只能处理一个的任务处理机制</p>
<p>并行：系统能处理多个任务，且同时还能处理多个的任务处理机制</p>
<p>高并发：系统能同时并行处理很多请求的任务处理机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</span><br><span class="line"></span><br><span class="line">你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</span><br><span class="line"></span><br><span class="line">你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</span><br><span class="line"></span><br><span class="line">并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。</span><br></pre></td></tr></table></figure>

<p>JUC: java.util.concurrent简称</p>
<p>自旋锁：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，<br>用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就<br>是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数<br>是10次，可以使用-XX:PreBlockSpin设置。</p>
<p>悲观锁: synchronized是悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁.</p>
<p>乐观锁: CAS操作的就是乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止</p>
<blockquote>
<p>CAS: Compare-and-Swap, 即比较并替换</p>
</blockquote>
<p>是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值(java中使用Unsafe类来实现)<br>它包含三个操作数：</p>
<ol>
<li>变量内存地址，V表示</li>
<li>旧的预期值，A表示</li>
<li>准备设置的新值，B表示</li>
</ol>
<p><strong>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</strong></p>
<blockquote>
<p>AQS：AbstractQueuedSynchronizer，抽象的队列式同步器。</p>
</blockquote>
<p>它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，ReentrantLock Semaphore CountDownLatch CyclicBarrier等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p>
<p>AQS 定义了两种资源共享方式：<br>1.Exclusive：独占，只有一个线程能执行，如ReentrantLock<br>2.Share：共享，多个线程可以同时执行，如Semaphore CountDownLatch ReadWriteLock，CyclicBarrier</p>
<p>FIFO( First Input First Output): 指先进先出</p>
<p>FILO：指先进后出</p>
<p>红黑树</p>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt="红黑树"></p>
<ul>
<li>每个节点非红即黑</li>
<li>根节点总是黑色的</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）</li>
<li>每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li>
</ul>
<p>并发的指标一般有QPS、TPS、IOPS，这几个指标都是可归为系统吞吐率，QPS越高系统能hold住的请求数越多，但光关注这几个指标不够，我们还需要关注RT，即响应时间，也就是从发出request到收到response的时延，这个指标跟吞吐往往是此消彼长的，我们追求的是一定时延下的高吞吐。</p>
<ul>
<li><strong>PV</strong> Page View：页面访问量，每次用户访问或者刷新页面都会被计算在内</li>
<li><strong>QPS</strong> Queries Per Second： 每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</li>
<li><strong>TPS</strong> Transactions Per Second： 每秒事务数，每秒系统能够处理的事务次数。</li>
</ul>
<blockquote>
<p>事务表示客户端发起请求到收到服务端最终响应的整个过程，这是一个TPS，而在这个TPS中，为了处理第一次请求可能会引发后续多次对服务端的访问才能完成这次工作，每次访问都算一个QPS。所以，一个TPS可能包含多个QPS</p>
</blockquote>
<blockquote>
<p>一个变量是否是线程安全的，取决于它是否被多个线程访问。要使变量能够被安全访问，必须通过同步机制来对变量进行修饰</p>
</blockquote>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的</p>
<p>线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性，这里的状态反映在程序中其实可以看作是数据</p>
<p>换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：</p>
<ul>
<li>封装：通过封装，我们可以将对象内部状态隐藏、保护起来。</li>
<li>不可变：还记得我们在专栏第 3 讲强调的 final 和 immutable 吗，就是这个道理，Java 语言目前还没有真正意义上的原生不可变，但是未来也许会引入。</li>
</ul>
<p>线程安全需要保证几个基本特性：</p>
<ul>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h1 id="Spring中的多线程疑惑"><a href="#Spring中的多线程疑惑" class="headerlink" title="Spring中的多线程疑惑"></a>Spring中的多线程疑惑</h1><p>首先我们需要认清：</p>
<ul>
<li>web容器本身就是多线程的，每一个HTTP请求都会产生一个独立的线程（或者从线程池中取得创建好的线程）；<br>Spring中的bean（用@Repository、@Service、@Component和@Controller注册的bean）都是单例的，即整个程序、所有线程共享一个实例；</li>
<li>虽然bean都是单例的，但是Spring提供的模板类（XXXTemplate），在Spring容器的管理下（使用@Autowired注入），会自动使用ThreadLocal以实现多线程；</li>
<li>即使类是单例的，但是其中有可能出现并发问题的变量使用ThreadLocal实现了多线程。</li>
<li>注意除了Spring本身提供的类以外，在Bean中定义“有状态的变量”（即有存储数据的变量），其会被所有线程共享，很可能导致并发问题，需要自行另外使用ThreadLocal进行处理，或者将Bean声明为prototype型。</li>
<li>一个类中的方法实际上是独立，方法内定义的局部变量在每次调用方法时都是独立的，不会有并发问题。只有类的“有状态的”全局变量会有并发问题</li>
</ul>
<p>结论：</p>
<ul>
<li>使用Spring提供的template等类没有多线程问题！</li>
<li>一般来说只有类的属性/全局变量会导致多线程问题，而方法内的局部变量不会有并发问题</li>
<li>单例模式肯定是线程不安全的！ spring的Bean中的自定义的成员变量除非进行threadLocal封装，否则都是非线程安全的！</li>
</ul>
<blockquote>
<p>一些编程语言旨在将并发任务彼此隔离。<br>这些通常被称为_函数式语言_，其中每个函数调用不产生副作用（不会干扰到其它函数），所以可以作为独立的任务来驱动。<br><strong>Erlang</strong>就是这样一种语言，它包括一个任务与另一个任务进行通信的安全机制。如果发现程序的某一部分必须大量使用并发，并且在尝试构建该部分时遇到了过多的问题，那么可以考虑使用这些专用的并发语言创建程序的这个部分</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程10-ThreadLocal</title>
    <url>/20200824/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/b6038c0d/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景</p>
<blockquote>
<p>ThreadLocal是属于java.lang包下的，Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离</p>
</blockquote>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到实际上ThreadLocal中的值是存在其内部的ThreadLocalMap中的，而其key是ThreadLocal自身(注意不是Thread)，但ThreadLocalMap的实例却是Thread中属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br></pre></td></tr></table></figure>
<p>也就是说是把value保存到给当前线程Thread的ThreadLocalMap中，并以当前ThreadLocal的实例作为key</p>
<blockquote>
<p>ThreadLocalMap本质是每个Thread内部各存一份，互不干扰</p>
</blockquote>
<p><img src="threadLocal-set.jpg" alt="threadLocal-set"></p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="threadLocal-set.jpg" alt="threadLocal-get"></p>
<blockquote>
<p>一个Thread只能有一个ThreadLocalMap，第一次遇到的ThreadLocal会帮它创建一个Map塞进去，往后无论遇到多少个ThreadLocal，都是直接用那个Map，而且都是把自己作为key，往Map里存东西</p>
</blockquote>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取，每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了：</p>
<blockquote>
<p>虽然ThreadLocalMap是ThreadLocal的静态内部类，但它们的实例对象并不存在继承或者包裹关系。完全可以当成两个独立的实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="comment">//相当于new WeakReference&lt;&gt;(k);</span></span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到ThreadLocalMap中存放对象的Entry的key是弱引用, 所以在外部所有强引用都去除后(外面的ThreadLocal被置为null)，则当前只有弱引用指向ThreadLocal对象，那么下一次GCThreadLocal对象就会被回收，进而避免了由于ThreadLocalMap中的引用仍然指向堆中的ThreadLocal，造成ThreadLocal的内存泄露</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;ThreadLocal</span><br><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">    if (m !&#x3D; null) &#123;</span><br><span class="line">        m.remove(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ThreadLocalMap</span><br><span class="line">private void remove(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    for (Entry e &#x3D; tab[i];</span><br><span class="line">            e !&#x3D; null;</span><br><span class="line">            e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        if (e.get() &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Entry</span><br><span class="line"> public void clear() &#123;</span><br><span class="line">    this.referent &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是获取当前Thread中的ThreadLocalMap，并根据Key(即threadLocal自身)删除value值</p>
<h2 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h2><p>上面说到源码中利用将ThreadLocal放到WeakReference，以避免由于ThreadLocal存在强引用而不能及时被回收造成内存泄露的问题。但这样会存在另一个问题，即当ThreadLocal被回收后，ThreadLocalMap中Entry的key被设置为了null, 我们无法再根据key移除value了, 这就造成了Entry的内存泄露(在ThreadLocal中，进行get，set操作的时候会清除Map里所有key为null的value)</p>
<p>为了避免这种情况下引起的内存泄露，<strong>每次使用完毕需及时清除</strong></p>
<blockquote>
<p>JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; tl &#x3D; new ThreadLocal&lt;&gt;(); </span><br><span class="line">tl.set(&quot;xxx&quot;); </span><br><span class="line">&#x2F;&#x2F; ......</span><br><span class="line">tl.remove()</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><blockquote>
<p>在android中Looper、ActivityThread以及AMS中都用到了ThreadLocal。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。实际上像Spring等框架源码大量使用了ThreadLocal</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ThreadLocal&lt;User&gt; threadLocalUser &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">void processUser(user) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h2><p>每个线程需要一个独享对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）</p>
<p>每个Thread内有自己的实例副本，不共享</p>
<blockquote>
<p>比喻：教材只有一本，一起做笔记有线程安全问题。复印后没有问题，使用ThradLocal相当于复印了教材</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 使用ThreadLocal 定义一个全局的SimpleDateFormat</span><br><span class="line">*&#x2F;</span><br><span class="line">private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal &#x3D; new</span><br><span class="line">ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 用法</span><br><span class="line">String dateString &#x3D; simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure>

<h2 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h2><p>每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。Web开发时，有些信息需要从controller传到service传到dao，甚至传到util类。看起来非常不优雅，这时便可以使用ThreadLocal来优雅的实现：在拦截器的preHandle()中set，在afterCompletion()中remove()：</p>
<p>定义保存用户用的线程上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把构造函数私有化，外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; context = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        context.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除当前线程内引用，防止内存泄漏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        context.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截器中设置和管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在请求处理之前进行调用（Controller方法调用之前）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object object)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">///······</span></span><br><span class="line"></span><br><span class="line">            User user = ······ ;<span class="comment">//从请求认证服务获取用户信息,可以是根据token获取用户</span></span><br><span class="line">            UserContext.set(user);</span><br><span class="line">            <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理之后进行调用（Controller方法调用之后）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object object, ModelAndView mv)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在整个请求结束之后被调用（主要是用于进行资源清理工作）</span></span><br><span class="line"><span class="comment">     * 一定要在请求结束后调用remove清除当前线程的副本变量值，否则会造成内存泄漏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object object, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserContext.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller或者service中获取(可以改造现有项目)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoginUser user &#x3D; UserContext.get();</span><br></pre></td></tr></table></figure>

<h2 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h2><p>在编写一个功能时需要把一个共有参数(这个参数在这中间是只读状态)一路传递到所有调用方法中</p>
<blockquote>
<p>为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {…}结构，让编译器自动为我们关闭</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser();</span></span><br><span class="line">    doHandle1();</span><br><span class="line">    doHandle2();</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象，避免内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String currentUser = UserContext.currentUser(); </span><br><span class="line">   doHandle3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String currentUser = UserContext.currentUser(); </span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String currentUser = UserContext.currentUser(); </span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>在编写AOP日志时，经常会用到的RequestContextHolder，其实内部也维护了ThreadLocal(有兴趣可以看看Spring是如何做到remove的-使用过滤器)</p>
</blockquote>
<p>下面是一个使用 RequestContextHolder 重写的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECURITY_CONTEXT_ATTRIBUTES = <span class="string">&quot;SECURITY_CONTEXT&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(SecurityContext context)</span> </span>&#123;</span><br><span class="line">        RequestContextHolder.currentRequestAttributes().setAttribute(</span><br><span class="line">                SECURITY_CONTEXT_ATTRIBUTES,</span><br><span class="line">                context,</span><br><span class="line">                RequestAttributes.SCOPE_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (SecurityContext)RequestContextHolder.currentRequestAttributes()</span><br><span class="line">                .getAttribute(SECURITY_CONTEXT_ATTRIBUTES, RequestAttributes.SCOPE_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了使用 RequestContextHolder 还可以使用 Request Scope 的 Bean，或者使用 ThreadLocalTargetSource ，原理上是类似的。</p>
<blockquote>
<p>Spring Security的基本组件SecurityContextHolder默认也是使用ThreadLocal策略来存储认证信息，在Web场景下的使用Spring Security，在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息(有兴趣可以看看SecurityContextHolder源码)，这里举个使用样例:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring Security获取有关当前用户的信息</span></span><br><span class="line">Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line">String username = ((UserDetails)principal).getUsername();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">String username = principal.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="延伸-InheritableThreadLocal"><a href="#延伸-InheritableThreadLocal" class="headerlink" title="延伸-InheritableThreadLocal"></a>延伸-InheritableThreadLocal</h1><blockquote>
<p>Thread里通过两个变量持用ThreadLocalMap 对象，分别为：threadLocals和inheritableThreadLocals</p>
</blockquote>
<p>InheritableThreadLocal用于子线程能够拿到父线程往ThreadLocal里设置的值</p>
<h1 id="延伸-线程池中使用ThreadLocal注意要点"><a href="#延伸-线程池中使用ThreadLocal注意要点" class="headerlink" title="延伸-线程池中使用ThreadLocal注意要点"></a>延伸-线程池中使用ThreadLocal注意要点</h1><p>由于每个Thread一个ThreadLocalMap, 而线程池是会复用线程的，故需要注意的是，线程中的逻辑执行完毕后(类似lock的使用在finally中的处理)，一定要remove相关key，避免数据混乱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, TimeUnit seconds,  </span></span></span><br><span class="line"><span class="function"><span class="params">            ArrayBlockingQueue&lt;Runnable&gt; arrayBlockingQueue)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(i, j, k, seconds, arrayBlockingQueue);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;  </span><br><span class="line">                <span class="comment">//任务执行回调可以作为重置操作  </span></span><br><span class="line">        MyThreadLocal.currentAgentId.set(<span class="number">888</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;  </span><br><span class="line">                <span class="comment">//任务执行回调可以作为重置操作  </span></span><br><span class="line">        MyThreadLocal.currentAgentId.set(<span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="Spring-框架-Async中的使用"><a href="#Spring-框架-Async中的使用" class="headerlink" title="Spring 框架 @Async中的使用"></a>Spring 框架 @Async中的使用</h2><h3 id="没有自定义线程池"><a href="#没有自定义线程池" class="headerlink" title="没有自定义线程池"></a>没有自定义线程池</h3><ul>
<li>没有配置线程池，每执行一次都会创建新的线程处理，只需要将new ThreadLocal替换为InheritableThreadLocal 即可获取</li>
</ul>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><ul>
<li>配置线程池，每次执行都会由线程池分配线程，使用 JDK 提供的 InheritableThreadLocal 无法获取到数据，而需要使用 Alibaba 扩展 InheritableThreadLocal 的 TransmittableThreadLocal</li>
</ul>
<blockquote>
<p>pom.xml中加入引用</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/transmittable-thread-local --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改线程池配置</p>
</blockquote>
<p>线程池中传输必须配合 TransmittableThreadLocal 和 TtlExecutors 使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        return taskExecutor;</span></span><br><span class="line">        <span class="comment">// 使用 TTL 提供的 TtlExecutors</span></span><br><span class="line">        <span class="keyword">return</span> TtlExecutors.getTtlExecutor(taskExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAsyncUncaughtExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改ThreadLocal</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把构造函数私有化，外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TransmittableThreadLocal InheritableThreadLocal ThreadLocal</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; context = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        context.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除当前线程内引用，防止内存泄漏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        context.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程3-fork/join框架</title>
    <url>/20200728/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/a490755/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>JDK1.7引入了一种新的并行编程模式”fork-join”，它是实现了”分而治之”思想的Java并发编程框架。它对问题的解决思路是分而治之，先将一个问题fork（分为）几个子问题，然后子问题又分为孙子问题，直至细分为一个容易计算的问题，然后再将结果依次join(结合)为最终的答案。对程序员来说，叫递归思想更加合适。只不过普通的递归是在单线程中完成的，而这里的递归则把递归任务通过invokeAll()方法丢进了线程池中，让线程池来调度执行。</p>
<p><strong>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好</strong></p>
 <a id="more"></a>

<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>在运行线程时，它使用“work-steal”（任务偷取）算法。一般来说，fork-join会启动多个线程（由参数指定，若不指定则默认为CPU核心数量），每个线程负责一个任务队列，并依次从队列头部获得任务并执行。当某个线程空闲时，它会从其他线程的任务队列尾部偷取一个任务来执行，这样就保证了线程的运行效率达到最高</p>
<p>它面向的问题域是可以大量并行执行的计算任务，其计算对象最好是一些独立的元素，不会被其他线程访问，也没有同步、互斥要求，更不要涉及IO或者无限循环。当然此框架也可以执行普通的并发编程任务，但是这时就失去了性能优势</p>
<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><ol>
<li><p>ForkJoinTask：fork-join的任务抽象类，同时也是Future接口，并提供了fork和join方法</p>
<ul>
<li>fork()    在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务</li>
<li>join()    当任务完成的时候返回计算结果。</li>
<li>invoke()    开始执行任务，如果必要，等待计算完成</li>
<li>invokeAll() 提交多个forkJoinTasks到ForkJoinPool的便捷方式</li>
</ul>
</li>
<li><p>ForkJoinPool: fork-join的线程池，所有的ForkJoinTask任务都必须在其中运行，主要使用invoke()、invokeAll()等方法来执行任务, 当然也可以使用原有的execute()和submit()方法</p>
</li>
<li><p>RecursiveAction: ForkJoinTask的具体实现类，用于没有返回值的任务</p>
</li>
<li><p>RecursiveTask: ForkJoinTask的具体实现类，用于有返回值的任务</p>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实例化</span><br><span class="line">ForkJoinPool forkJoinPool &#x3D; ForkJoinPool.commonPool();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;任务提交</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式1： submit()或execute() </span><br><span class="line">forkJoinPool.execute(ForkJoinTask&lt;?&gt; task);</span><br><span class="line">int result &#x3D; customRecursiveTask.join();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式2: invoke()或者invokeAll()</span><br><span class="line">&#x2F;&#x2F;invoke()方法拆分任务并等待结果，并且不需要任何手动join</span><br><span class="line">&#x2F;&#x2F;invokeAll()方法是提交多个forkJoinTasks到ForkJoinPool的便捷方式。</span><br><span class="line">&#x2F;&#x2F;它将任务作为参数，forks它们将按照生成它们的顺序返回Future对象的集合</span><br><span class="line">int result &#x3D; forkJoinPool.invoke(ForkJoinTask&lt;?&gt; task);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式3：使用单独的fork()和join()</span><br><span class="line">&#x2F;&#x2F;fork()方法将任务提交到一个线程池中，但它不会触发它的执行。</span><br><span class="line">&#x2F;&#x2F;join()方法被用于触发执行。在RecursiveAction的情况下，join()只返回null ; 对于RecursiveTask &lt;V&gt;，它返回任务执行的结果</span><br><span class="line">forkJoinTask.fork();</span><br><span class="line">result &#x3D; forkJoinTask.join();</span><br></pre></td></tr></table></figure>

<p>为避免混淆，使用invokeAll()方法向ForkJoinPool提交多个任务通常是个好主意</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>计算1至1000的正整数之和</p>
<blockquote>
<p>fork-join的效率跟CPU的核数有直接关系，不同性能机器，测试结果会不一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个简单的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">sumUp</span><span class="params">(<span class="keyword">long</span>[] numbers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalculator</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ForkJoinPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当需要计算的数字小于6时，直接计算结果</span></span><br><span class="line">            <span class="keyword">if</span> (to - from &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= to; i++) &#123;</span><br><span class="line">                    total += numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> total;</span><br><span class="line">                <span class="comment">// 否则，把任务一分为二，递归计算</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = (from + to) / <span class="number">2</span>;</span><br><span class="line">                SumTask taskLeft = <span class="keyword">new</span> SumTask(numbers, from, middle);</span><br><span class="line">                SumTask taskRight = <span class="keyword">new</span> SumTask(numbers, middle+<span class="number">1</span>, to);</span><br><span class="line">                taskLeft.fork();</span><br><span class="line">                taskRight.fork();</span><br><span class="line">                <span class="keyword">return</span> taskLeft.join() + taskRight.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCalculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 也可以使用公用的 ForkJoinPool：</span></span><br><span class="line">        <span class="comment">// pool = ForkJoinPool.commonPool()</span></span><br><span class="line">        pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumUp</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.invoke(<span class="keyword">new</span> SumTask(numbers, <span class="number">0</span>, numbers.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Calculator calculator = new ForLoopCalculator();</span></span><br><span class="line"><span class="comment">//        System.out.println(calculator.sumUp(numbers)); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Calculator executorCalculator = new ExecutorServiceCalculator();</span></span><br><span class="line"><span class="comment">//        System.out.println(executorCalculator.sumUp(numbers));</span></span><br><span class="line"></span><br><span class="line">        Calculator forkJoinCalculator = <span class="keyword">new</span> ExecutorServiceCalculator();</span><br><span class="line">        System.out.println(forkJoinCalculator.sumUp(numbers)); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><ul>
<li>需使用合理的阈值将ForkJoinTask拆分为子任务</li>
<li>避免在 ForkJoinTask中出现任何阻塞</li>
</ul>
<p>ForkJoinTask在执行的时候可能会抛出异常，在主线程中是无法直接获取的，但是可以通过ForkJoinTask提供的isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了</p>
<p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的java.util.Arrays.parallelSort(array)可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程4-volatile&amp;synchronized</title>
    <url>/20200730/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/cc62b819/</url>
    <content><![CDATA[<h1 id="并发编程三要素"><a href="#并发编程三要素" class="headerlink" title="并发编程三要素"></a>并发编程三要素</h1><h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h2><p><strong>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</strong></p>
<p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作</p>
<p>可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性</p>
 <a id="more"></a>

<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><p><strong>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong></p>
<p>Java提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值</p>
<p>另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性</p>
<h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><p><strong>即程序执行的顺序按照代码的先后顺序执行</strong></p>
<p>可以通过 volatile 关键字来保证一定的有序性</p>
<p>另外可以通过 synchronized 和 Lock 来保证有序性，很显然，synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><blockquote>
<p>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象</p>
</blockquote>
<p>下面的代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//    private volatile boolean stop = false;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备工作&quot;</span>);</span><br><span class="line">        doWorkWithThread();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stop = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;可以停止工作了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorkWithThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">                <span class="comment">//doSomethings</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;正在工作...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;停止工作&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorkWithCompletableFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">                <span class="comment">//doSomethings</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;正在工作...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;停止工作&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileTest volatileTest = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        volatileTest.doWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="comment">//准备工作</span></span><br><span class="line"><span class="comment">//可以停止工作了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事实上，这段代码并不会完全运行正确，甚至使用原始的Thread可以发现，程序执行结束了并没有停止掉。这个时候volatile就派上用场了，在变量修饰符前加上volatile，可以发现程序按照既定要求执行了。</p>
<blockquote>
<p>ps: 如果把线程中的System.out.println注释去掉，这个时候可以发现，程序又执行正确了，不要奇怪，这是因为System.out.println源码中使用了synchronized，感兴趣的可以看看:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;java8 源码</span><br><span class="line">public void println(String x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;java14 源码</span><br><span class="line">public void println(String x) &#123;</span><br><span class="line">    if (getClass() &#x3D;&#x3D; PrintStream.class) &#123;</span><br><span class="line">        writeln(String.valueOf(x));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以不用volatile，可以改为AtomicBoolean达到同样的效果(通过查看源码可以发现底层同样使用的是volatile修饰的)。感兴趣的可以看看java.util.concurrent.atomic包中提供的各个类的使用: </p>
<p><img src="atomic.png" alt="image"> </p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><blockquote>
<p>synchronized保证在同一时刻最多只有一个线程执行该段代码</p>
</blockquote>
<p>上面看了volatile的用法，值得一提的是volatile只能修饰变量。那如果要保证一个操作或者方法的原子性时(防止多个线程同时执行一段代码)就得使用synchronized了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> studentsCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        studentsCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        studentsCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStudentsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">onePeopleComingRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                addStudent();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                removeStudent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronizedTest synchronizedTest = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executor.execute(synchronizedTest.onePeopleComingRunnable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;尚未结束&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共有1: &quot;</span> + synchronizedTest.getStudentsCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="comment">//不定，可能出现不同结果，这种现象就是线程不安全的一种表现</span></span><br></pre></td></tr></table></figure>

<p>我们试试给addStudent和removeStudent方法加上synchronized</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private synchronized void addStudent() &#123;</span><br><span class="line">    studentsCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private synchronized void removeStudent() &#123;</span><br><span class="line">    studentsCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印结果永远为0</span><br></pre></td></tr></table></figure>

<p><img src="synchronized.png" alt="image"> </p>
<p>使用时遵守<strong>同步锁的范围越小，效率越高</strong>原则</p>
<p>当然上面的计数的场景完全可以用AtomicInteger来代替: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private AtomicInteger studentsCountAtomicInteger &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">private void addStudent() &#123;</span><br><span class="line">    studentsCountAtomicInteger.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void removeStudent() &#123;</span><br><span class="line">    studentsCountAtomicInteger.decrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getStudentsCount() &#123;</span><br><span class="line">    return studentsCountAtomicInteger.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印结果永远为0</span><br></pre></td></tr></table></figure>

<h2 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h2><h3 id="实现单例"><a href="#实现单例" class="headerlink" title="实现单例"></a>实现单例</h3><ul>
<li>线程不安全的单例</li>
</ul>
<p>普通单线程模式下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;实例化对象&quot;</span>);</span><br><span class="line">            instance = <span class="keyword">new</span> TestSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestSingleton testSingleton = TestSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;1: &quot;</span> + testSingleton.hashCode());</span><br><span class="line"></span><br><span class="line">        TestSingleton testSingleton1 = TestSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;2: &quot;</span> + testSingleton1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出的hashCode是一样的，说明确实是同一个对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>试试多线程调用情况下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            TestSingleton testSingleton = TestSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;1: &quot;</span> + testSingleton.hashCode());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt;  completableFuture2 =  CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            TestSingleton testSingleton1 = TestSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;2: &quot;</span> + testSingleton1.hashCode());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!(completableFuture1.isDone() &amp;&amp; completableFuture2.isDone())) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果，不固定，有时候一样，有时候不一样。说明多线程情况下已不是单例了</span></span><br><span class="line"><span class="comment">//ps: 所以多线程的代码才不好调试，结果不固定，跟实际机器的环境有关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>线程安全的单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用volatile保证instance原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> TestSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用synchronized锁住类</span></span><br><span class="line">            <span class="keyword">synchronized</span> (TestSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;实例化对象&quot;</span>);</span><br><span class="line">                    instance = <span class="keyword">new</span> TestSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            TestSingleton testSingleton = TestSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;1: &quot;</span> + testSingleton.hashCode());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt;  completableFuture2 =  CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            TestSingleton testSingleton1 = TestSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;2: &quot;</span> + testSingleton1.hashCode());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!(completableFuture1.isDone() &amp;&amp; completableFuture2.isDone())) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果就是同一对象了，这样就达到了多线程情况下的单例的实现</span></span><br></pre></td></tr></table></figure>

<p>ps: 上面只是举例，如果日常真的要写线程安全的单例的话，建议：</p>
<ul>
<li>对象实例化占用资源少时</li>
</ul>
<p>//使用枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用枚举-推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TestSingleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉模式-不推荐：直接把单例对象创建出来，要用的时候直接返回即可，但如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestSingleton instance = <span class="keyword">new</span> TestSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例化对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象实例化占用资源多且需要延时(第一次使用时再实例化)-使用内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestSingleton instance = <span class="keyword">new</span> TestSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;实例化对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程6-ConcurrentHashMap</title>
    <url>/20200811/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/57e2d1c0/</url>
    <content><![CDATA[<p><img src="map%E7%BB%93%E6%9E%84.png" alt="map结构"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Map与List是我们日常开发中经常会用到的用于存放数据的容器，与list不同的是map采用key/value的数据结构。而map的实现类中最常用的就是HashMap了，对应的在多线程场景下一般会推荐使用ConcurrentHashMap</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>在看HashMap之前，我们先了解下什么是hash: </p>
<blockquote>
<p>Hash: 一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。<br>散列函数：若关键字为k，则其值存放在f(k)的位置上。因此，不用比较就可以直接通过key找到value。<br>碰撞: 再拓展下不管采用什么散列算法，都会出现两个不同的输入值，算出来的散列值是一样的，如果k1≠k2，而f(k1)=f(k2)，即对于不同的key得到了同一个散列地址，这种现象就叫做碰撞。一般碰撞的概率越小算法越优</p>
</blockquote>
<p>对应的在java中Object对象都会有hashCode这个方法(java中默认所有的类都是继承于Object)，就是为每个对象都保留生成hash的方法</p>
<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>先简单了解下HashMap的原理:</p>
<blockquote>
<p>HashMap内部是由数组+链表+红黑树构成的(java8之前采用的是数组+链表)，采用红黑树是为了提高查询效率</p>
</blockquote>
<p>是根据key而直接访问内存存储位置的数据结构。也就是说，它通过计算一个关于key的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。<br>这个映射函数称作散列函数，存放记录的数组称作散列表，也叫哈希表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient Node&lt;k,v&gt;[] table</span><br></pre></td></tr></table></figure>

<blockquote>
<p>transient: 在实现Serializable接口的对象中，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就被忽略</p>
</blockquote>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>当一个值需要存储到HashMap中时，HashMap会根据key值计算出他的hash，再将hash值通过计算转换为索引(数组下标)，将key和value存放对应位置: </p>
<ul>
<li>当数组中对应位置没有值时，则直接将当前的 key、value 封装成一个Node，存放到数组中</li>
<li>当数组中对应位置存在值时(即发生了hash碰撞，又叫hash冲突了)，就会将当前的 key、value 封装成一个新Node写入到当前Node的后面(形成链表)，如果链表的值过长(默认8)会直接转换为红黑树(即TreeNode)</li>
</ul>
<p><strong>最后判断是否需要进行扩容</strong>(扩容的判断及扩容实现较复杂, 后面重点分析下)</p>
<p>数组下标的计算方式为：通过对key hash然后与数组长度-1进行与运算((n-1)&amp;hash) (都是2的次幂所以等同于取模，但是位运算的效率更高)，找到数组中的下标</p>
<blockquote>
<p>链表长度低于6，会把红黑树转回链表</p>
</blockquote>
<p><img src="hashmap-put.jpg" alt="hashmap-put"></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>当需要从HashMap中获取value值时，同样根据key计算hash和转换得到索引值，取出value:</p>
<ul>
<li>当数组对应位置只有一个node时，判断是否是同样的key, 是则直接取出</li>
<li>当数组对应的位置存在多个时，判断是否是红黑树，是则按照红黑树的方式获取值，如果不是，则按照链表的方式遍历获取值</li>
</ul>
<h3 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h3><p>通过上面的描述，我们也就好理解了：</p>
<ul>
<li>为什么HashMap的key不可以是基本数据类型了：因为需要hash计算</li>
<li>为什么HashMap的遍历会比List(ArrayList)慢：因为判断多且结构复杂(可能会遍历数组+链表或者红黑树)</li>
</ul>
<p>通过HashMap的hash方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以得出结论，HashMap是允许key为空的</p>
<h2 id="有序的HashMap"><a href="#有序的HashMap" class="headerlink" title="有序的HashMap"></a>有序的HashMap</h2><p>由于HashMap是通过hash计算来得出存放位置的，故他是不能保证顺序的。如果需要有序的HashMap，使用LinkedHashMap：</p>
<p>LinkedHashMap属于HashMap的子类，与HashMap的区别在于LinkedHashMap保存了记录插入的顺序。TreeMap实现了SortedMap接口，TreeMap有能力对插入的记录根据key排序，默认按照升序排序，也可以自定义比较器，在使用TreeMap的时候，key应当实现Comparable(String默认已经实现了Comparable)</p>
<h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全?"></a>HashMap线程不安全?</h2><p>首先HashMap先明确下，如果是在只读环境下，那HashMap是不存在线程不安全的，所以如果业务中的使用时先初始化好map，然后在不同线程内获取值的话，HashMap也是可以直接使用的。</p>
<p>那HashMap什么情况下会造成线程不安全呢？答案就是在每次put值之后会判断是否扩容，而如果并发情况下，扩容时可能会导致节点丢失(java8之前还可能造成环形链表导致死循环)等问题，所以才说HashMap是线程不安全的</p>
<blockquote>
<p>在jdk1.7中，由于扩容时使用头插法，在并发时可能会形成环状列表，导致死循环，在jdk1.8中改为尾插法，可以避免这种问题，但是依然避免不了<strong>节点丢失</strong>的问题</p>
</blockquote>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>与HashMap类似，ConcurrentHashMap也采用了数组+链表+红黑树的方式，并使用volatile关键字来保证获取时可见性，采用了CAS + synchronized 来保证并发安全性(java8之前采用的是Segment 分段锁)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ConcurrentHashMap并不是直接继承自HashMap，而是继承了和HashMap一样的父类AbstractMap。并且<strong>ConcurrentHashMap中的key和value都不可以为空</strong>!</p>
</blockquote>
<h2 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h2><p>put方法与HashMap有一些区别: </p>
<p>根据 key计算出hashcode(这里ConcurrentHashMap的hash是使用了spread,与HashMap稍有不同)，定位出Node：</p>
<ul>
<li>如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</li>
<li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果链表数量大于8则要转换为红黑树</li>
</ul>
<h2 id="ConcurrentHashMap-VS-HashTable"><a href="#ConcurrentHashMap-VS-HashTable" class="headerlink" title="ConcurrentHashMap VS HashTable"></a>ConcurrentHashMap VS HashTable</h2><p>既然HashMap是线程不安全的，那在多线程场景下我们就可以选择HashTable或者ConcurrentHashMap了，在一般情况下推荐使用ConcurrentHashMap：HashTable在线程竞争比较激烈的情况下效率相对较低，因为他采用的是synchronized全局锁的方式，在一个线程操作时，其他线程都需要等待，不仅不能put也不能get。而ConcurrentHashMap使用了分段锁的技术来提高并发度，不在同一段的数据互相不影响，多个线程对多个不同段的操作是不会相互影响的。</p>
<blockquote>
<p>值得一提的是java8对synchronized做了很多优化，java8中ConcurrentHashMap采用的分段锁从ReentrantLock改为了synchronized</p>
</blockquote>
<p>当然HashTable也不是完全没有用了，相反由于采用了全局锁，使得每个线程获得的数据总是最实时的：比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。相对应的ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。</p>
<p><strong>应该根据自己的业务场景选择合适的HashMap</strong></p>
<h1 id="使用HashMap需注意的事项"><a href="#使用HashMap需注意的事项" class="headerlink" title="使用HashMap需注意的事项"></a>使用HashMap需注意的事项</h1><p>默认情况下HashMap的初始容量为16，默认情况下，当其size大于12(16*0.75) 时就会触发扩容当达到扩容条件时会进行扩容，从16 扩容到32、64、128…</p>
<p>如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16)</p>
<h2 id="建议初始化HashMap的容量大小"><a href="#建议初始化HashMap的容量大小" class="headerlink" title="建议初始化HashMap的容量大小"></a>建议初始化HashMap的容量大小</h2><p>如果我们没有设置初始容量大小，随着元素的不断增加，HashMap 会发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash 表，是非常影响性能的</p>
<p>项目使用时，如果引用了guava库直接使用Maps.newHashMapWithExpectedSize(x)即可，否则可以采用下面的算法来初始化:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int capacity(int expectedSize) &#123;</span><br><span class="line">        if (expectedSize &lt; 3) &#123;</span><br><span class="line">            return expectedSize + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return expectedSize &lt; 1073741824 ? (int)((float)expectedSize &#x2F; 0.75F + 1.0F) : 2147483647;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">return (int) ((float) expectedSize &#x2F; 0.75F + 1.0F);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;expectedSize就是可能会存储的元素的个数</span><br><span class="line">new HashMap(capacity(expectedSize));</span><br></pre></td></tr></table></figure>

<p>偶然间翻到HashSet的源码，HashSet内部通过维护一个HashMap来实现读取插入等功能，他对hashMap的初始化容量是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(Math.max((int) (c.size()&#x2F;.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而面试题经常问到的HashSet的值为什么不能重复, 看看add方法实现就知道了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历方式选择"><a href="#遍历方式选择" class="headerlink" title="遍历方式选择"></a>遍历方式选择</h2><p>HashMap中可以看到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    return (es &#x3D; entrySet) &#x3D;&#x3D; null ? (entrySet &#x3D; new EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故如果有人再问哪张方式遍历效率更高，直接回答entrySet的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(3);</span><br><span class="line">map.put(&quot;a&quot;, &quot;123&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;456&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;789&quot;);</span><br><span class="line">for(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(&quot;key &#x3D; &quot; + entry.getKey() + &quot;, value &#x3D; &quot; + entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果项目是java8的直接采用Map.forEach</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map1 &#x3D; new HashMap&lt;&gt;(3);</span><br><span class="line">map1.put(&quot;a&quot;, &quot;123&quot;);</span><br><span class="line">map1.put(&quot;b&quot;, &quot;456&quot;);</span><br><span class="line">map1.put(&quot;c&quot;, &quot;789&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;java8</span><br><span class="line">map1.forEach((key, value) -&gt; System.out.println(&quot;key&#x3D;&quot; + key + &quot; value&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有当只需要获取map的keys或values时，采用KeySet或者values代替entrySet</p>
</blockquote>
<h1 id="JUC中的concurrentMap"><a href="#JUC中的concurrentMap" class="headerlink" title="JUC中的concurrentMap"></a>JUC中的concurrentMap</h1><h2 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h2><p>它是一个接口，是一个能够支持并发访问的java.util.map集合。在原有java.util.map接口基础上又新提供了4种方法，进一步扩展了原有Map的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    <span class="comment">//如果插入的key相同，则不替换原有的value值</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    <span class="comment">//增加了对value的判断，如果要删除的key--value不能与Map中原有的key--value对应上，则不会删除该元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    <span class="comment">//增加了对value值的判断，如果key--oldValue能与Map中原有的key--value对应上，才进行替换操作</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    <span class="comment">//如果key存在则直接替换,不对value值的判断</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentNavigableMap"><a href="#ConcurrentNavigableMap" class="headerlink" title="ConcurrentNavigableMap"></a>ConcurrentNavigableMap</h2><p>它继承了NavigableMap和ConcurrentMap这两个接口子Map，就是两者功能的结合，既保证线程安全性，又提供导航搜索子Map视图的功能(视图就是集合中的一段数据序列)</p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>ConcurrentSkipListMap是ConcurrentNavigableMap的一个实现类。</p>
<p>ConcurrentSkipListMap的key是有序的, 所以在多线程程序中，如果需要对Map的键值进行排序时，请尽量使用ConcurrentSkipListMap，可能得到更好的并发度</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>WeakHashMap</p>
<p>在Java集合中有一种特殊的Map类型—WeakHashMap，在这种Map中存放了键对象的弱引用，当一个键对象被垃圾回收器回收时，那么相应的值对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        Map map;</span><br><span class="line">        map &#x3D; new WeakHashMap&lt;String,Object&gt;();</span><br><span class="line">        for (int i &#x3D;0;i&lt;10000;i++)&#123;</span><br><span class="line">            map.put(&quot;key&quot;+i,new byte[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;        map &#x3D; new HashMap&lt;String,Object&gt;();</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D;0;i&lt;10000;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;            map.put(&quot;key&quot;+i,new byte[i]);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　使用-Xmx2M限定堆内存，使用WeakHashMap的代码正常运行结束，而使用HashMap的代码段抛出异常：java.lang.OutOfMemoryError: Java heap space。由此可见，WeakHashMap会在系统内存紧张时使用弱引用，自动释放掉持有弱引用的内存数据。但如果WeakHashMap的key都在系统内持有强引用，那么WeakHashMap就退化为普通的HashMap，因为所有的数据项都无法被自动清理。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程8-locks锁</title>
    <url>/20200817/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/c9ab2479/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>任何一个新引入的知识都是为了<strong>解决以往系统中出现的问题</strong>，否则新引入的将变得毫无价值</p>
</blockquote>
<p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁。</p>
<p>但当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是<strong>读操作和读操作</strong>不会发生冲突现象，通过Lock就可以实现。</p>
<p>Lock接口, 提供了与synchronized一样的锁功能。虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性</p>
<blockquote>
<p>Lock必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象</p>
</blockquote>
<p><img src="locks.png" alt="locks"></p>
<blockquote>
<p>一个线程获取多少次锁，就必须释放多少次锁。这对于内置锁也是适用的，每一次进入和离开synchronized方法(代码块)，就是一次完整的锁获取和释放。</p>
</blockquote>
<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><ul>
<li><strong>悲观锁</strong>：<br>悲观锁，每次去请求数据的时候，都认为数据会被抢占更新(悲观的想法)；所以每次操作数据时都要先加上锁，其他线程修改数据时就要等待获取锁。适用于写多读少的场景，synchronized就是一种悲观锁</li>
</ul>
<ul>
<li><p><strong>乐观锁</strong>：<br>在请求数据时，觉得无人抢占修改。等真正更新数据时，才判断此期间别人有没有修改过(预先读出一个版本号或者更新时间戳，更新时判断是否变化，没变则期间无人修改)；和悲观锁不同的是，期间数据允许其他线程修改</p>
</li>
<li><p><strong>自旋锁</strong>：<br>一句话，魔力转转圈。当尝试给资源加锁却被其他线程先锁定时，不是阻塞等待而是循环再次加锁<br>在锁常被短暂持有的场景下，线程阻塞挂起导致CPU上下文频繁切换，这可用自旋锁解决；但自旋期间它占用CPU空转，因此不适用长时间持有锁的场景</p>
</li>
</ul>
<h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁。如果锁已被其他线程获取，则进行等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生():</p>
<blockquote>
<p>锁【lock.lock】必须紧跟try代码块，且unlock要放到finally第一行。</p>
</blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>可重入锁, 支持重入性，表示能够对共享资源重复加锁，即当前线程获取该锁再次获取不会被阻塞。ReentrantLock实现了Lock接口的，并且ReentrantLock提供了更多的方法</p>
<blockquote>
<p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LocksTest test = <span class="keyword">new</span> LocksTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; test.insert(Thread.currentThread())).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; test.insert(Thread.currentThread())).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般情况下通过tryLock来获取锁时是这样使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="comment">//Thread-0得到了锁</span></span><br><span class="line"><span class="comment">//Thread-1获取锁失败</span></span><br><span class="line"><span class="comment">//Thread-0释放了锁</span></span><br></pre></td></tr></table></figure>

<p>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        InterruptTest test = <span class="keyword">new</span> InterruptTest();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly();   <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InterruptTest test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(InterruptTest test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><p>ReadWriteLock也是一个接口,只有两个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作</p>
<blockquote>
<p>使用ReadWriteLock时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改, 适合读多写少的场景</p>
</blockquote>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>ReentrantReadWriteLock实现了ReadWriteLock接口，并添加了可重入的特性</p>
<blockquote>
<p>如果在系统中，读操作次数远远大于写操作，则读写锁就可以发挥最大的功效，提升系统的性能</p>
</blockquote>
<h1 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h1><p>　　总结来说，Lock和synchronized有以下几点不同：</p>
<p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
<p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>　　5）Lock可以提高多个线程进行读操作的效率。</p>
<p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择</p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。使用Condition可以实现等待/唤醒，并且能够唤醒制定线程</p>
<blockquote>
<p>Condition可以替代wait和notify；Condition对象必须从Lock对象获取</p>
</blockquote>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>LockSupport是一个工具类，可以让线程在任意位置阻塞，也可以在任意位置唤醒，它的内部其实两类主要的方法：park（停车阻塞线程）和unpark（启动唤醒线程）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 暂停当前线程</span><br><span class="line">public static void park(Object blocker); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暂停当前线程，不过有超时时间的限制</span><br><span class="line">public static void parkNanos(Object blocker, long nanos); </span><br><span class="line">public static void parkNanos(long nanos); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暂停当前线程，直到某个时间</span><br><span class="line">public static void parkUntil(Object blocker, long deadline);</span><br><span class="line">public static void parkUntil(long deadline);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无期限暂停当前线程</span><br><span class="line">public static void park(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 恢复当前线程</span><br><span class="line">public static void unpark(Thread thread);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;blocker的作用是在dump线程的时候看到阻塞对象的信息</span><br><span class="line">public static Object getBlocker(Thread t);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;java14新增了设置blocker的方法</span><br><span class="line">public static void setCurrentBlocker(Object blocker);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() +<span class="string">&quot;in &quot;</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() +<span class="string">&quot;被中断了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>LockSuport主要是针对Thread进进行阻塞处理，可以指定阻塞队列的目标对象，每次可以指定具体的线程唤醒。Object.wait()是以对象为纬度，阻塞当前的线程和唤醒单个(随机)或者所有线程</p>
</blockquote>
<blockquote>
<p>park和unpark可以实现类似wait和notify的功能，但是并不和wait和notify交叉，也就是说unpark不会对wait起作用，notify也不会对park起作用</p>
</blockquote>
<h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1><blockquote>
<p>之前的锁或多或少都存在一些缺点，比如synchronized不可中断等，ReentrantLock 未能读写分离实现，虽然ReentrantReadWriteLock能够读写分离了，但是对于其写锁想要获取的话，就必须没有任何其他读写锁存在才可以，这实现了悲观读取。而且如果读操作很多，写很少的情况下，线程有可能遭遇饥饿问题。</p>
</blockquote>
<blockquote>
<p>饥饿问题：ReentrantReadWriteLock实现了读写分离，想要获取读锁就必须确保当前没有其他任何读写锁了，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，因为当前有可能会一直存在读锁。而无法获得写锁</p>
</blockquote>
<p>所以java8引入了新的锁StampedLock，这个类没有直接实现Lock或者ReadWriteLock方法，源码中是把他当作一个单独的类来实现的。相比于普通的ReentranReadWriteLock主要多了一种乐观读的功能。当然，一个StampedLock可以通过asReadLock，asWriteLock，asReadWriteLock方法来得到全部功能的子集</p>
<h1 id="AbstractQwnableSynchronizer"><a href="#AbstractQwnableSynchronizer" class="headerlink" title="AbstractQwnableSynchronizer"></a>AbstractQwnableSynchronizer</h1><p>抽象拥有同步器，简称AOS</p>
<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架, 简称AQS</p>
<h1 id="AbstractQueuedLongSynchronizer"><a href="#AbstractQueuedLongSynchronizer" class="headerlink" title="AbstractQueuedLongSynchronizer"></a>AbstractQueuedLongSynchronizer</h1><p>扩展自AbstractQueuedSynchronizer</p>
<p>—todo 未完待续—</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程9-BlockingQueue和BlockingDeque</title>
    <url>/20200818/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/aa881dfa/</url>
    <content><![CDATA[<p><img src="BlockingQueue.png" alt="BlockingQueue"></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>
</blockquote>
<h2 id="queue-amp-deque"><a href="#queue-amp-deque" class="headerlink" title="queue&amp;deque"></a>queue&amp;deque</h2><p>queue: 先进先出队列</p>
<p>deque: 双端队列，继承自queue，可以在首尾插入或删除元素</p>
<h2 id="BlockingQueue-amp-BlockingDeque"><a href="#BlockingQueue-amp-BlockingDeque" class="headerlink" title="BlockingQueue&amp;BlockingDeque"></a>BlockingQueue&amp;BlockingDeque</h2><p>BlockingQueue: 阻塞队列</p>
<p>BlockingDeque: 阻塞双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程</p>
<blockquote>
<p>阻塞</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-中介者模式</title>
    <url>/20201105/java/designPatterns/cc119eab/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中介者模式(Mediator): 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>中介模式是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。</p>
<p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。</p>
<blockquote>
<p>Mediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。</p>
</blockquote>
<ul>
<li><p>各个UI组件互不引用，这样就减少了组件之间的耦合关系；</p>
</li>
<li><p>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；</p>
</li>
<li><p>如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。</p>
<a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们来模拟下RadioButton的实现: 单选框，需保证在同一组中的单选框只能选中一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单选框</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadioButton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> select = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RadioButton</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelect</span><span class="params">(<span class="keyword">boolean</span> select)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.select = select;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单选框组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadioGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, RadioButton&gt; radioButtonMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(RadioButton radioButton)</span> </span>&#123;</span><br><span class="line">        radioButtonMap.put(radioButton.getId(), radioButton);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(RadioButton... radioButtons)</span> </span>&#123;</span><br><span class="line">        Arrays.stream(radioButtons).forEach(<span class="keyword">this</span>::add);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(String radioId)</span> </span>&#123;</span><br><span class="line">        RadioButton radioButton = radioButtonMap.getOrDefault(radioId, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(radioButton != <span class="keyword">null</span>) &#123;</span><br><span class="line">            radioButtonMap.forEach((id, radioButton1) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(id.equals(radioId)) &#123;</span><br><span class="line">                    radioButton1.setSelect(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    radioButton1.setSelect(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RadioButton <span class="title">getSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radioButtonMap.values().stream().filter(RadioButton::isSelect).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;RadioButton&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(radioButtonMap.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadioMediatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RadioGroup radioGroup = <span class="keyword">new</span> RadioGroup();</span><br><span class="line"></span><br><span class="line">        RadioButton radioButton1 = <span class="keyword">new</span> RadioButton(<span class="string">&quot;radio1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        RadioButton radioButton2 = <span class="keyword">new</span> RadioButton(<span class="string">&quot;radio2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        RadioButton radioButton3 = <span class="keyword">new</span> RadioButton(<span class="string">&quot;radio3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        radioGroup.addAll(radioButton1, radioButton2, radioButton3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看选择情况</span></span><br><span class="line">        radioGroup.getAll().forEach(radioButton -&gt; System.out.println(radioButton.getId() + <span class="string">&quot; select: &quot;</span> + radioButton.isSelect()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选中radioButton2</span></span><br><span class="line">        radioGroup.select(radioButton2.getId());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次查看选择情况</span></span><br><span class="line">        radioGroup.getAll().forEach(radioButton -&gt; System.out.println(radioButton.getId() + <span class="string">&quot; select: &quot;</span> + radioButton.isSelect()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;选中了: &quot;</span> + radioGroup.getSelect().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">radio1 select: <span class="keyword">false</span></span><br><span class="line">radio2 select: <span class="keyword">false</span></span><br><span class="line">radio3 select: <span class="keyword">false</span></span><br><span class="line">===============================</span><br><span class="line">radio1 select: <span class="keyword">false</span></span><br><span class="line">radio2 select: <span class="keyword">true</span></span><br><span class="line">radio3 select: <span class="keyword">false</span></span><br><span class="line">选中了: radio2</span><br></pre></td></tr></table></figure>

<p>以上通过引入RadioGroup这个中介，就可以模拟实现单选按钮的功能，同样的可以再加上其他组件实现单选的话，只要在中介类中引入即可，组件之间相互不关联</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-享元模式</title>
    <url>/20201102/java/designPatterns/5903f011/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>享元模式(Flyweight): 主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。享元模式的设计思想是尽量复用已创建的对象，常用于工厂方法内部的优化。</p>
<p>如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<blockquote>
<p>总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p>
</blockquote>
<p>在学习享元模式之前需要先了解一下 细粒度 和享元对象中的 内部状态、外部状态 这三个概念：</p>
<ul>
<li>内部状态：不随环境改变而改变的状态，内部状态可以共享，例如人的性别，不管任何环境下都不会改变</li>
<li>外部状态：随着环境改变而改变的状态，不可以共享的状态，享元对象的外部状态通常由客户端保存，并在享元对象创建后，需要的时候传入享元对象内部，不同的外部状态是相互独立的。例如衣服和鞋子，人在不同的环境下会穿不同的衣服和鞋子，但是衣服和鞋子又是相互独立不受彼此影响的</li>
<li>细粒度：较小的对象，所包含的内部状态较小</li>
</ul>
<p>java中的string字符的不变性其实就是享元模式的应用！</p>
 <a id="more"></a>

<p>通过查看Integer类的源码我们可以看到Integer会把[-128, 127]之间的数字直接返回共享池中的对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;IntegerCache.low &#x3D; -128</span><br><span class="line">&#x2F;&#x2F;IntegerCache.high &#x3D; 127</span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象享元角色</span></span><br><span class="line"><span class="comment"> * 父接口，以规定出所有具体享元角色需要实现的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体享元角色</span></span><br><span class="line"><span class="comment"> * 实现抽象享元角色所规定出的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Character intrinsicState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(Character state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//内部状态不变</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.toString() + <span class="string">&quot;intrinsicState is : &quot;</span> + intrinsicState);</span><br><span class="line">        <span class="comment">//外部状态实时变化</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.toString() + <span class="string">&quot;extrinsicState is : &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 享元工厂</span></span><br><span class="line"><span class="comment"> * 本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。</span></span><br><span class="line"><span class="comment"> * 当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。</span></span><br><span class="line"><span class="comment"> * - 如果已经有了，享元工厂角色就应当提供这个已有的享元对象；</span></span><br><span class="line"><span class="comment"> * - 如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FlyweightFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FlyweightFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Flyweight&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">factory</span><span class="params">(Character character)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = cache.get(character);</span><br><span class="line">        <span class="keyword">if</span>(flyweight == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(character);</span><br><span class="line">            cache.put(character, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 享元模式测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flyweight fly = FlyweightFactory.getInstance().factory(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        fly.operation(<span class="string">&quot;First Call&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fly = FlyweightFactory.getInstance().factory(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        fly.operation(<span class="string">&quot;Second Call&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fly = FlyweightFactory.getInstance().factory(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        fly.operation(<span class="string">&quot;Third Call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">com.jonesun.tool.pattern.flyweight.ConcreteFlyweight@<span class="number">78e03</span>bb5intrinsicState is : a</span><br><span class="line">com.jonesun.tool.pattern.flyweight.ConcreteFlyweight@<span class="number">78e03</span>bb5extrinsicState is : First Call</span><br><span class="line">com.jonesun.tool.pattern.flyweight.ConcreteFlyweight@<span class="number">6</span>ae40994intrinsicState is : b</span><br><span class="line">com.jonesun.tool.pattern.flyweight.ConcreteFlyweight@<span class="number">6</span>ae40994extrinsicState is : Second Call</span><br><span class="line">com.jonesun.tool.pattern.flyweight.ConcreteFlyweight@<span class="number">78e03</span>bb5intrinsicState is : a</span><br><span class="line">com.jonesun.tool.pattern.flyweight.ConcreteFlyweight@<span class="number">78e03</span>bb5extrinsicState is : Third Call</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然客户端申请了三个享元对象，但是实际创建的享元对象只有两个，这就是共享的含义</p>
</blockquote>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>我们再看一个具体一点的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书-相当于Flyweight</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">borrowBy</span><span class="params">(String studentName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backFrom</span><span class="params">(String studentName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现的图书-相当于ConcreteFlyweight</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBook</span> <span class="keyword">implements</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteBook</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">borrowBy</span><span class="params">(String studentName)</span> </span>&#123;</span><br><span class="line">        System.out.println(studentName + <span class="string">&quot;借了: &quot;</span> + bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backFrom</span><span class="params">(String studentName)</span> </span>&#123;</span><br><span class="line">        System.out.println(studentName + <span class="string">&quot;归还了: &quot;</span> + bookName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书馆-相当于FlyweightFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookLibrary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BookLibrary instance = <span class="keyword">new</span> BookLibrary();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BookLibrary <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BookLibrary</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bookMap.containsKey(bookName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bookMap.get(bookName);</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> ConcreteBook(bookName);</span><br><span class="line">        bookMap.put(bookName, book);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bookSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookLibraryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book book1 = BookLibrary.getInstance().getBook(<span class="string">&quot;图书1&quot;</span>);</span><br><span class="line">        book1.borrowBy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Book book2 = BookLibrary.getInstance().getBook(<span class="string">&quot;图书2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        book2.borrowBy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Book book3 = BookLibrary.getInstance().getBook(<span class="string">&quot;图书3&quot;</span>);</span><br><span class="line">        book3.borrowBy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一段时间后张三还完书，李四过来借阅</span></span><br><span class="line">        book1.backFrom(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        book2.backFrom(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        book3.backFrom(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Book book4 = BookLibrary.getInstance().getBook(<span class="string">&quot;图书1&quot;</span>);</span><br><span class="line">        book4.borrowBy(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Book book5 = BookLibrary.getInstance().getBook(<span class="string">&quot;图书2&quot;</span>);</span><br><span class="line">        book5.borrowBy(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总共借出: &quot;</span> + BookLibrary.getInstance().bookSize() + <span class="string">&quot;本图书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">张三借了: 图书<span class="number">1</span></span><br><span class="line">张三借了: 图书<span class="number">2</span></span><br><span class="line">张三借了: 图书<span class="number">3</span></span><br><span class="line">张三归还了: 图书<span class="number">1</span></span><br><span class="line">张三归还了: 图书<span class="number">2</span></span><br><span class="line">张三归还了: 图书<span class="number">3</span></span><br><span class="line">李四借了: 图书<span class="number">1</span></span><br><span class="line">李四借了: 图书<span class="number">2</span></span><br><span class="line">总共借出: <span class="number">3</span>本图书</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用的时候只需要记住享元模式的核心思想，然后根据自己的业务需求来选择，因为大多情况下都不会使用一种设计模式，而是<strong>多种设计模式的组合</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-代理模式</title>
    <url>/20200716/java/designPatterns/c3cf574b/</url>
    <content><![CDATA[<blockquote>
<p>设计模式是为了可扩展性，不要为了使用设计模式而使用</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问</p>
</blockquote>
<p>代理模式包含如下角色：</p>
<ul>
<li>Subject:抽象主题角色。可以是接口，也可以是抽象类。</li>
<li>RealSubject:真实主题角色。业务逻辑的具体执行者。</li>
<li>ProxySubject:代理主题角色。内部含有RealSubject的引用,负责对真实角色的调用，并在真实主题角色处理前后做预处理和善后工作</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>主要可以用于：日志记录，性能统计，安全控制，事务处理，异常处理等场景</p>
 <a id="more"></a>

<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><blockquote>
<p>适合预先确定了代理与被代理者的关系，需要一个接口(表示要完成的功能)，一个真实对象和一个代理对象(两者都需实现这个接口)</p>
</blockquote>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个程序员接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICoder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 实现需求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实现结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">implDemands</span><span class="params">(String demands)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个java程序员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCoder</span> <span class="keyword">implements</span> <span class="title">ICoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;java程序员&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">implDemands</span><span class="params">(String demands)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s收到需求[%s]&quot;</span>, name, demands));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s需求[%s]实现完成&quot;</span>, name, demands));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个项目经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoderProxy</span> <span class="keyword">implements</span> <span class="title">ICoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;项目经理&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICoder coder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoderProxy</span><span class="params">(ICoder coder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coder = coder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">implDemands</span><span class="params">(String demands)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s收到需求[%s]&quot;</span>, name, demands));</span><br><span class="line">        <span class="keyword">if</span>(demands.contains(<span class="string">&quot;像淘宝&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s回复: [%s]无法实现&quot;</span>, name, demands));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Boolean result = coder.implDemands(demands);</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s需求[%s]实现完成&quot;</span>, name, demands));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户提出需求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个客户</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到一个产品经理(底下一个java程序员)</span></span><br><span class="line">        CoderProxy coderProxy = <span class="keyword">new</span> CoderProxy(<span class="keyword">new</span> JavaCoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提出需求</span></span><br><span class="line"></span><br><span class="line">        customer.putDemands(coderProxy, <span class="string">&quot;做个管理系统&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        customer.putDemands(coderProxy, <span class="string">&quot;做个网站，像淘宝一样就行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 提出需求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> demands</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDemands</span><span class="params">(ICoder coder, String demands)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;客户提出需求[%s]&quot;</span>, demands));</span><br><span class="line">        Boolean result = coder.implDemands(demands);</span><br><span class="line">        <span class="keyword">if</span>(result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;感谢!!!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不能实现啊，好吧!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>OnJava8中的样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProxyBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ProxyBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ProxyBase implementation;</span><br><span class="line"></span><br><span class="line">    Proxy() &#123;</span><br><span class="line">        implementation = <span class="keyword">new</span> Implementation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pass method calls to the implementation:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; implementation.f(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; implementation.g(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; implementation.h(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">ProxyBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Implementation.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Implementation.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Implementation.h()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy p = <span class="keyword">new</span> Proxy();</span><br><span class="line">        p.f();</span><br><span class="line">        p.g();</span><br><span class="line">        p.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体实现不需要与代理对象具有相同的接口;只要代理对象以某种方式“代表具体实现的方法调用，那么基本思想就算实现了。然而，拥有一个公共接口是很方便的，因此具体实现必须实现代理对象调用的所有方法</p>
</blockquote>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote>
<p>代理类在程序运行时创建的代理方式被成为动态代理</p>
</blockquote>
<p>使用java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个老师接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 老师讲课</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bookName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">teach</span><span class="params">(String bookName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个英语老师</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnglishTeacher</span> <span class="keyword">implements</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">teach</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;英语老师准备上课&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;今天讲: &quot;</span> + bookName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bookName + <span class="string">&quot;讲完了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个动态代理类用于记录上课时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRecordProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicRecordProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始记录&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;记录完成，花费: &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DynamicRecordProxy dynamicRecordProxy = <span class="keyword">new</span> DynamicRecordProxy();</span><br><span class="line">        </span><br><span class="line">        Teacher teacher = (Teacher) dynamicRecordProxy.bind(<span class="keyword">new</span> EnglishTeacher());</span><br><span class="line">        teacher.teach(<span class="string">&quot;Oxford University Press&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是JDK帮我们自动编写了类（不需要源码，可以直接生成字节码）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(&quot;morning&quot;, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CgLib"><a href="#CgLib" class="headerlink" title="CgLib"></a>CgLib</h2><blockquote>
<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现</p>
</blockquote>
<p>如果是spring 项目直接使用就行，非spring项目可引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个普通类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;用户准备登录, 密码为: &quot;</span> + password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义cglib代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">//注意这里需使用methodProxy.invokeSuper</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line"></span><br><span class="line">        UserService userService = (UserService) cglibProxy.getProxy(UserService.class);</span><br><span class="line">        userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;admin123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以定义代理工厂，方便多个类使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getGcLibDynProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy());</span><br><span class="line">        Object targetProxy = enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> targetProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h1><p>在Spring的AOP编程中:</p>
<ul>
<li>如果加入容器的目标对象有实现接口,用JDK代理</li>
<li>如果目标对象没有实现接口,用Cglib代理</li>
</ul>
<p>不过需要注意：</p>
<ul>
<li>代理的类不能为final,否则报错</li>
<li>目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-单例模式</title>
    <url>/20201105/java/designPatterns/49fe4565/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单例模式Singleton: 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>
<p>单例模式的要点有三个：</p>
<ul>
<li><p>一是某个类只能有一个实例</p>
</li>
<li><p>二是它必须自行创建这个实例</p>
</li>
<li><p>三是它必须自行向整个系统提供这个实例</p>
<a id="more"></a>

</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>全局只有一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一枚举</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用</span></span><br><span class="line">        EnumSingleton enumSingleton = EnumSingleton.INSTANCE;</span><br><span class="line">        enumSingleton.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器编译出的class大概就像这样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingleton INSTANCE = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。延迟加载会遇到线程安全问题</p>
</blockquote>
<p>非要实现的话最好借助内部类来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static class LazyHolder &#123;</span><br><span class="line">         private static LazySingleton INSTANCE &#x3D; new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        return LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void hello()  &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h1><p><strong>Spring框架下使用@Component即可实现单例，不需要刻意去实现</strong>，如果需要懒加载再加上@Lazy，即实现了Bean对象在第一次使用时才创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySpringTestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;执行构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpringTestBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MySpringTestBean mySpringTestBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySpringTestBeanTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mySpringTestBean.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用注解的默认实例化方式:</p>
<ul>
<li>@Component默认单例</li>
<li>@Bean默认单例</li>
<li>@Repository默认单例</li>
<li>@Service默认单例</li>
<li>@Controller默认多例</li>
</ul>
<blockquote>
<p>如果想声明成多例对象可以使用@Scope(“prototype”)</p>
</blockquote>
<p>另外如果需要保证每个线程中都只有一个的话，借助<a href="/20200824/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/b6038c0d">ThreadLocal</a>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadSingleton&gt; THREAD_LOCAL = ThreadLocal.withInitial(ThreadSingleton::<span class="keyword">new</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadSingleton threadSingleton = THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span>(threadSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threadSingleton = <span class="keyword">new</span> ThreadSingleton();</span><br><span class="line">            THREAD_LOCAL.set(threadSingleton);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-原型模式</title>
    <url>/20201106/java/designPatterns/2933c5b8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原型模式(Prototype): 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。使用Java标准库提供的clone方法：</p>
<ul>
<li><p>定义对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="keyword">private</span> Long score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(<span class="keyword">int</span> id, String mobile, Long score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMobile</span><span class="params">(String mobile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Long score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserInfo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, mobile=&#x27;&quot;</span> + mobile + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getEnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnable</span><span class="params">(Boolean enable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enable = enable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, enable=&quot;</span> + enable +</span><br><span class="line">                <span class="string">&quot;, userInfo=&quot;</span> + userInfo +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意如果对象支持复制需要<strong>实现Cloneable接口(空接口)并重写Object的clone方法</strong></p>
</blockquote>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setId(<span class="number">1000</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">20</span>);</span><br><span class="line">        user1.setEnable(<span class="keyword">true</span>);</span><br><span class="line">        user1.setUserInfo(<span class="keyword">new</span> UserInfo(<span class="number">1</span>,<span class="string">&quot;12345678901&quot;</span>, <span class="number">111L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user2 = (User) user1.clone();</span><br><span class="line">            System.out.println(<span class="string">&quot;user1: &quot;</span> + user1);</span><br><span class="line">            System.out.println(<span class="string">&quot;user2: &quot;</span> + user2);</span><br><span class="line">            user1.setId(<span class="number">2000</span>);</span><br><span class="line">            user1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            user1.setAge(<span class="number">30</span>);</span><br><span class="line">            user1.setEnable(<span class="keyword">false</span>);</span><br><span class="line">            user1.getUserInfo().setId(<span class="number">11</span>);</span><br><span class="line">            user1.getUserInfo().setMobile(<span class="string">&quot;98746543210&quot;</span>);</span><br><span class="line">            user1.getUserInfo().setScore(<span class="number">11111111L</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;修改user1后&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user1: &quot;</span> + user1);</span><br><span class="line">            System.out.println(<span class="string">&quot;user2: &quot;</span> + user2);</span><br><span class="line"></span><br><span class="line">            user2.setId(<span class="number">3000</span>);</span><br><span class="line">            user2.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">            user2.setAge(<span class="number">40</span>);</span><br><span class="line">            user2.setEnable(<span class="keyword">true</span>);</span><br><span class="line">            user1.getUserInfo().setId(<span class="number">12</span>);</span><br><span class="line">            user2.getUserInfo().setMobile(<span class="string">&quot;14785236974&quot;</span>);</span><br><span class="line">            user1.getUserInfo().setScore(<span class="number">12121212L</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;修改user2后&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user1: &quot;</span> + user1);</span><br><span class="line">            System.out.println(<span class="string">&quot;user2: &quot;</span> + user2);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">            user1.setUserInfo(<span class="keyword">new</span> UserInfo(<span class="number">22</span>,<span class="string">&quot;888888888&quot;</span>, <span class="number">22222L</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;修改user1的UserInfo&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user1: &quot;</span> + user1);</span><br><span class="line">            System.out.println(<span class="string">&quot;user2: &quot;</span> + user2);</span><br><span class="line"></span><br><span class="line">            user2.setUserInfo(<span class="keyword">new</span> UserInfo(<span class="number">33</span>, <span class="string">&quot;999999&quot;</span>, <span class="number">333333L</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;修改user2的UserInfo&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user1: &quot;</span> + user1);</span><br><span class="line">            System.out.println(<span class="string">&quot;user2: &quot;</span> + user2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">user1: User&#123;id=<span class="number">1000</span>, age=<span class="number">20</span>, name=<span class="string">&#x27;张三&#x27;</span>, enable=<span class="keyword">true</span>, userInfo=UserInfo&#123;id=<span class="number">1</span>, mobile=<span class="string">&#x27;12345678901&#x27;</span>, score=<span class="number">111</span>&#125;&#125;</span><br><span class="line">user2: User&#123;id=<span class="number">1000</span>, age=<span class="number">20</span>, name=<span class="string">&#x27;张三&#x27;</span>, enable=<span class="keyword">true</span>, userInfo=UserInfo&#123;id=<span class="number">1</span>, mobile=<span class="string">&#x27;12345678901&#x27;</span>, score=<span class="number">111</span>&#125;&#125;</span><br><span class="line">修改user1后</span><br><span class="line">user1: User&#123;id=<span class="number">2000</span>, age=<span class="number">30</span>, name=<span class="string">&#x27;李四&#x27;</span>, enable=<span class="keyword">false</span>, userInfo=UserInfo&#123;id=<span class="number">11</span>, mobile=<span class="string">&#x27;98746543210&#x27;</span>, score=<span class="number">11111111</span>&#125;&#125;</span><br><span class="line">user2: User&#123;id=<span class="number">1000</span>, age=<span class="number">20</span>, name=<span class="string">&#x27;张三&#x27;</span>, enable=<span class="keyword">true</span>, userInfo=UserInfo&#123;id=<span class="number">11</span>, mobile=<span class="string">&#x27;98746543210&#x27;</span>, score=<span class="number">11111111</span>&#125;&#125;</span><br><span class="line">修改user2后</span><br><span class="line">user1: User&#123;id=<span class="number">2000</span>, age=<span class="number">30</span>, name=<span class="string">&#x27;李四&#x27;</span>, enable=<span class="keyword">false</span>, userInfo=UserInfo&#123;id=<span class="number">12</span>, mobile=<span class="string">&#x27;14785236974&#x27;</span>, score=<span class="number">12121212</span>&#125;&#125;</span><br><span class="line">user2: User&#123;id=<span class="number">3000</span>, age=<span class="number">40</span>, name=<span class="string">&#x27;王五&#x27;</span>, enable=<span class="keyword">true</span>, userInfo=UserInfo&#123;id=<span class="number">12</span>, mobile=<span class="string">&#x27;14785236974&#x27;</span>, score=<span class="number">12121212</span>&#125;&#125;</span><br><span class="line">======================</span><br><span class="line">user1的UserInfo重新创建</span><br><span class="line">user1: User&#123;id=<span class="number">2000</span>, age=<span class="number">30</span>, name=<span class="string">&#x27;李四&#x27;</span>, enable=<span class="keyword">false</span>, userInfo=UserInfo&#123;id=<span class="number">22</span>, mobile=<span class="string">&#x27;888888888&#x27;</span>, score=<span class="number">22222</span>&#125;&#125;</span><br><span class="line">user2: User&#123;id=<span class="number">3000</span>, age=<span class="number">40</span>, name=<span class="string">&#x27;王五&#x27;</span>, enable=<span class="keyword">true</span>, userInfo=UserInfo&#123;id=<span class="number">12</span>, mobile=<span class="string">&#x27;14785236974&#x27;</span>, score=<span class="number">12121212</span>&#125;&#125;</span><br><span class="line">user2的UserInfo重新创建</span><br><span class="line">user1: User&#123;id=<span class="number">2000</span>, age=<span class="number">30</span>, name=<span class="string">&#x27;李四&#x27;</span>, enable=<span class="keyword">false</span>, userInfo=UserInfo&#123;id=<span class="number">22</span>, mobile=<span class="string">&#x27;888888888&#x27;</span>, score=<span class="number">22222</span>&#125;&#125;</span><br><span class="line">user2: User&#123;id=<span class="number">3000</span>, age=<span class="number">40</span>, name=<span class="string">&#x27;王五&#x27;</span>, enable=<span class="keyword">true</span>, userInfo=UserInfo&#123;id=<span class="number">33</span>, mobile=<span class="string">&#x27;999999&#x27;</span>, score=<span class="number">333333</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可见，复制后的两个对象中任一对象中所有基本类型的修改都不会影响另一个对象。</p>
<p>而如果对象的属性中包含对象：</p>
<ul>
<li>修改了任一对象中的该属性的值，另一个对象中的该属性的值也会被一同修改</li>
<li>将任一对象中的该属性重新赋值(new新对象), 则另一个对象中的该属性就不会被修改了</li>
</ul>
<blockquote>
<p>Java提供的引用类型因为都是重新赋值了，故修改也不会相互影响</p>
</blockquote>
<p><strong>所以如果使用了浅复制的方法，要注意分辨</strong></p>
<p>常用场景: 实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制</p>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底，要实现深复制就要借助于io流了：</p>
<ul>
<li><p>在User对象中加入实现深复制的方法，并把所有关联的自定义的对象都实现<strong>Serializable</strong>接口(如果不实现会出现序列化异常)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object deepClone() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">       &#x2F;* 写入当前对象的二进制流 *&#x2F;</span><br><span class="line">       ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">       ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">       objectOutputStream.writeObject(this);</span><br><span class="line"></span><br><span class="line">       &#x2F;* 读出二进制流产生的新对象 *&#x2F;</span><br><span class="line">       ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span><br><span class="line">       ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(byteArrayInputStream);</span><br><span class="line">       return objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
</li>
</ul>
<p>只需要把测试类PrototypeTest中的clone改成deepClone即可，这样无论对象属性如何修改都不会影响另一个对象，具体代码就不放出来了</p>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-命令模式</title>
    <url>/20201103/java/designPatterns/c08d175c/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>命令模式(Command): 把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p>
<p>命令模式是对命令的封装。<strong>命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</strong></p>
<p>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>
<p>命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：</p>
<ul>
<li>命令模式使新的命令很容易地被加入到系统里</li>
<li>允许接收请求的一方决定是否要否决请求</li>
<li>能较容易地设计一个命令队列</li>
<li>可以容易地实现对请求的撤销和恢复</li>
<li>在需要的情况下，可以较容易地将命令记入日志</li>
</ul>
<p>命令模式涉及到五个角色，它们分别是：</p>
<ul>
<li><p>客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。</p>
</li>
<li><p>命令(Command)角色：声明了一个给所有具体命令类的抽象接口。</p>
</li>
<li><p>具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</p>
</li>
<li><p>请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。</p>
</li>
<li><p>接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</p>
<a id="more"></a>

<p>命令模式的优点</p>
</li>
<li><p>更松散的耦合: 命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</p>
</li>
<li><p>更动态的控制: 命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</p>
</li>
<li><p>很自然的复合命令: 命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</p>
</li>
<li><p>更好的扩展性: 由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1></li>
</ul>
<ul>
<li>定义接收者-及实际执行者Receiver</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Receiver是被调用者（士兵）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;撤销执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义命令Command</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.unAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Invoker调用者（司令员）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求者-要求该命令执行这个请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Command&gt; commandList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commandList.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commandList.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commandList.forEach(Command::execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commandList.remove(command);</span><br><span class="line">        command.undo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建命令对象，设定它的接收者</span></span><br><span class="line">        Command command1 = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        Command command2 = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建请求者，把命令对象设置进去</span></span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(command1);</span><br><span class="line">        invoker.addCommand(command2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撤销某个命令</span></span><br><span class="line">        invoker.undo(command1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-工厂方法模式</title>
    <url>/20201027/java/designPatterns/8dc1e828/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂方法(Factory Method)是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道, 目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体产品-邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过邮件发送: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体产品-短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过短信发送: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h2><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建，根据传递参数绝对创建哪个产品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">product</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;email&quot;</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EmailSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;SMS&quot;</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SMSSender();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid factory name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品工厂测试类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SenderFactory senderFactory = <span class="keyword">new</span> SenderFactory();</span><br><span class="line">            Sender sender = senderFactory.product(<span class="string">&quot;SMS&quot;</span>);</span><br><span class="line">            sender.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多个工厂方法模式"><a href="#多个工厂方法模式" class="headerlink" title="多个工厂方法模式"></a>多个工厂方法模式</h2><p>对普通工厂模式进行升级，提供多个工厂方法，分别创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">productSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SMSProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">productEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmailProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品工厂测试类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SenderFactory senderFactory = <span class="keyword">new</span> SenderFactory();</span><br><span class="line">        Sender emailSender = senderFactory.productEmail();</span><br><span class="line">        emailSender.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Sender smsSender = senderFactory.productSMS();</span><br><span class="line">        smsSender.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="静态工厂方法模式"><a href="#静态工厂方法模式" class="headerlink" title="静态工厂方法模式"></a>静态工厂方法模式</h2><p>多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Sender <span class="title">productSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SMSProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Sender <span class="title">productEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmailProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有时候也可以这么实现</span></span><br><span class="line"><span class="comment">     * 好处在于只有一个工厂方法</span></span><br><span class="line"><span class="comment">     * 缺点就是如果传入的name有误，就不能正确创建对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Sender <span class="title">product</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;email&quot;</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EmailSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;SMS&quot;</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SMSSender();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid factory name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品工厂测试类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sender emailSender = SenderFactory.productEmail();</span><br><span class="line">        emailSender.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Sender smsSender = SenderFactory.productSMS();</span><br><span class="line">        smsSender.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sender sender = SenderFactory.product(<span class="string">&quot;SMS&quot;</span>);</span><br><span class="line">            sender.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>工厂方法还有一个好处是可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">fromInt</span><span class="params">(<span class="keyword">int</span> yyyyMMdd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//内部优化不是每次都创建对象</span></span><br><span class="line">        <span class="keyword">return</span> LocalDate.of(yyyyMMdd / <span class="number">10000</span>, yyyyMMdd / <span class="number">100</span> % <span class="number">100</span>, yyyyMMdd % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDateFactory.fromInt(<span class="number">20201002</span>);</span><br><span class="line">        System.out.println(localDate.format(DateTimeFormatter.ISO_LOCAL_DATE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大多数情况下选用<strong>静态工厂方法模式</strong>，实际上静态工厂方法广泛地应用在Java标准库中(如List.of()、Integer.valueOf())</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p><strong>工厂方法模式是简单工厂模式的进一步抽象和推广</strong></p>
<p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。</p>
<p>这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<p><strong>优点：</strong></p>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
<li>类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了<strong>闭包原则</strong>，所以，从设计角度考虑，有一定的问题。</li>
</ul>
<p>这个时候就要用到<a href="/20201027/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5ee502d3">抽象工厂模式</a>，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<blockquote>
<p>需要注意得是，如果不是特别复杂得工厂产品创建，一般静态工厂方法就够了，只有像多个供应商负责提供一系列类型的产品时才需要用到抽象工厂模式</p>
</blockquote>
<blockquote>
<p>见名思意，无论是自己编写还是看到别人代码中的类是以Factory结尾的都应联想到是否是使用了工厂模式</p>
</blockquote>
<h1 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h1><p>改写Sender的两个实现类，加上@Component：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;email&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过邮件发送: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;SMS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过短信发送: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String , Sender&gt; senderMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSenderByName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> senderMap.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringSenderFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpringSenderFactory senderFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSenderByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        senderFactory.getSenderByName(<span class="string">&quot;email&quot;</span>).send(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        senderFactory.getSenderByName(<span class="string">&quot;SMS&quot;</span>).send(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-外观模式</title>
    <url>/20201030/java/designPatterns/4f40d3f3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>外观模式(Facade)，又叫门面模式，是为了解决类与类之家的依赖关系的，给客户端提供一个统一入口，并对外屏蔽内部子系统的调用细节。像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度</p>
<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个RestApiController，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cpu start work!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disk start load!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;memory start connect!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Disk disk;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">        disk = <span class="keyword">new</span> Disk();</span><br><span class="line">        memory = <span class="keyword">new</span> Memory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start the computer!&quot;</span>);</span><br><span class="line">        cpu.work();</span><br><span class="line">        memory.connect();</span><br><span class="line">        disk.load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.startup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算机内部零部件特别多，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，而用户使用计算机就只要和计算机这个类打交道，这就是外观模式的特点</p>
<blockquote>
<p>SLF4J使用的就是外观模式(门面)</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-备忘录模式</title>
    <url>/20201105/java/designPatterns/df30fde2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>备忘录模式(Memento): 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p>标准的备忘录模式有这么几种角色：</p>
<ul>
<li>Memonto：备忘录类，备份原始类中的信息</li>
<li>Originator：原始类</li>
<li>Caretaker：存储备忘录的类</li>
</ul>
<blockquote>
<p>备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。</p>
</blockquote>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li>定义备忘录类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义原始类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveToMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        status = memento.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义存取备忘录的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存取者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一步</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getPrev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(mementoList.size() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(mementoList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有历史</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Memento&gt; <span class="title">getHistory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建存储备忘录的类</span></span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建原始类</span></span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置并保存状态值</span></span><br><span class="line">        originator.setStatus(<span class="string">&quot;status1&quot;</span>);</span><br><span class="line">        save(caretaker, originator);</span><br><span class="line"></span><br><span class="line">        originator.setStatus(<span class="string">&quot;status2&quot;</span>);</span><br><span class="line">        save(caretaker, originator);</span><br><span class="line"></span><br><span class="line">        originator.setStatus(<span class="string">&quot;status3&quot;</span>);</span><br><span class="line">        save(caretaker, originator);</span><br><span class="line"></span><br><span class="line">        originator.setStatus(<span class="string">&quot;status4&quot;</span>);</span><br><span class="line">        save(caretaker, originator);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态: &quot;</span> + originator.getStatus());</span><br><span class="line">        <span class="comment">//撤销当前状态(返回上一步状态)</span></span><br><span class="line">        originator.restoreFromMemento(caretaker.getPrev());</span><br><span class="line">        save(caretaker, originator);</span><br><span class="line">        System.out.println(<span class="string">&quot;撤销后，当前状态: &quot;</span> + originator.getStatus());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新从备忘录中获取当前状态</span></span><br><span class="line">        Originator originator1 = <span class="keyword">new</span> Originator();</span><br><span class="line">        originator1.setStatus(caretaker.getCurrent().getStatus());</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后当前状态: &quot;</span> + originator1.getStatus());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取操作历史</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===============操作历史=================&quot;</span>);</span><br><span class="line">        caretaker.getHistory().forEach(memento -&gt; System.out.println(<span class="string">&quot;memento: &quot;</span> + memento.getStatus()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Caretaker caretaker, Originator originator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存状态</span></span><br><span class="line">        Memento memento1 = originator.saveToMemento();</span><br><span class="line">        caretaker.addMemento(memento1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">当前状态: status4</span><br><span class="line">撤销后，当前状态: status3</span><br><span class="line">恢复后当前状态: status3</span><br><span class="line">===============操作历史=================</span><br><span class="line">memento: status1</span><br><span class="line">memento: status2</span><br><span class="line">memento: status3</span><br><span class="line">memento: status4</span><br><span class="line">memento: status3</span><br></pre></td></tr></table></figure>

<p>以上就实现了一个简单的备忘录，可以进行再一次封装，如加上每步的操作时间、地点、人物等, 或者指定恢复到某个进度</p>
<blockquote>
<p>简单的对象，用一个String就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-建造者模式</title>
    <url>/20201105/java/designPatterns/e2a6f58b/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>建造者模式(Builder): 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们借助于Lombok的@Builder反编译出来的代码来看如何自己编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//反编译后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    User(String username, String password) &#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username; <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User.<span class="function">UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User.UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        UserBuilder() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">username</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">password</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="keyword">this</span>.username, <span class="keyword">this</span>.password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User.UserBuilder(username=&quot;</span> + <span class="keyword">this</span>.username + <span class="string">&quot;, password=&quot;</span> + <span class="keyword">this</span>.password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">User user = User.builder().username(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).build();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-模板方法模式</title>
    <url>/20201103/java/designPatterns/295e2dfa/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>模板方法(TemplateMethod): 它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>
<p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法的核心思想是：<strong>父类定义骨架，子类实现某些细节</strong>。模板方法是一种高层定义骨架，底层实现细节的设计模式，<strong>适用于流程固定，但某些步骤不确定或可替换的情况</strong>。</p>
<blockquote>
<p>为了防止子类重写父类的骨架方法，可以<strong>在父类中对骨架方法使用final</strong>。对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。</p>
</blockquote>
<p>Java标准库也有很多模板方法的应用。在集合类中，AbstractList和AbstractQueuedSynchronizer都定义了很多通用操作，子类只需要实现某些必要方法。</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li><p>定义模板类</p>
<p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现init()和startPlay()、endPlay()这三个方法就交给子类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 游戏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备中...&quot;</span>);</span><br><span class="line">        init();</span><br><span class="line">        startPlay();</span><br><span class="line">        endPlay();</span><br><span class="line">        saveRecord();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存进度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进度已保存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体实现类</p>
</li>
</ul>
<p>子类其实并不关心核心代码pay()的逻辑，甚至如何保存记录saveRecord()，它只需要关心如何完成三个子方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 足球游戏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FootballGame</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;足球游戏正在加载中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始玩足球游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束足球游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试验证</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//玩足球游戏</span></span><br><span class="line">        Game footballGame = <span class="keyword">new</span> FootballGame();</span><br><span class="line">        footballGame.pay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面如果要增加新的游戏，再继承Game实现具体的玩法，然后更换游戏即可</p>
<p>项目中经常用到的从数据库中或者值，为了提高速度，先从缓存中获取，那么获取值的逻辑就可以认为是骨架方法，这个从缓存中获取的方法就可以抽象到子类中实现，由具体的子类来实现用哪个缓存</p>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-抽象工厂模式</title>
    <url>/20201027/java/designPatterns/5ee502d3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>抽象工厂模式(Abstract Factory)是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；</p>
<blockquote>
<p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。<br>此时，我们可以考虑将一些相关的产品组成一个”产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想</p>
</blockquote>
<p>抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                ┌────────┐</span><br><span class="line">                             ─ &gt;│ProductA│</span><br><span class="line">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class="line">│ Client │─ ─&gt;│ Factory │─ ─</span><br><span class="line">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class="line">                   ▲         ─ &gt;│ProductB│</span><br><span class="line">           ┌───────┴───────┐    └────────┘</span><br><span class="line">           │               │</span><br><span class="line">      ┌─────────┐     ┌─────────┐</span><br><span class="line">      │Factory1 │     │Factory2 │</span><br><span class="line">      └─────────┘     └─────────┘</span><br><span class="line">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class="line">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class="line">           │   └─────────┘ │   └─────────┘</span><br><span class="line">               ┌─────────┐     ┌─────────┐</span><br><span class="line">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class="line">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种模式有点类似于多个供应商负责提供一系列类型的产品</p>
</blockquote>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Html处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toHtml</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Word处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WordDocument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">HtmlDocument <span class="title">createHtml</span><span class="params">(String md)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">WordDocument <span class="title">createWord</span><span class="params">(String md)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fast提供得Html处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastHtmlDocument</span> <span class="keyword">implements</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String md;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastHtmlDocument</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.md = md;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用fast转换Html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;html&gt;&quot;</span> + md + <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        md = toHtml();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用fast保存Html内容: &quot;</span> + md +  <span class="string">&quot;&gt;&gt;到: &quot;</span> + path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fast提供得Word处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastWordDocument</span> <span class="keyword">implements</span> <span class="title">WordDocument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String md;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastWordDocument</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.md = md;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用fast保存Word内容: &quot;</span> + md + <span class="string">&quot;&gt;&gt;到: &quot;</span> + path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fast提供得工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HtmlDocument <span class="title">createHtml</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastHtmlDocument(md);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordDocument <span class="title">createWord</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastWordDocument(md);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AbstractFactory factory = <span class="keyword">new</span> FastFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成Html文档:</span></span><br><span class="line">        HtmlDocument html = factory.createHtml(<span class="string">&quot;#Hello World&quot;</span>);</span><br><span class="line">        html.save(Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.html&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成Word文档:</span></span><br><span class="line">        WordDocument word = factory.createWord(<span class="string">&quot;#Hello World&quot;</span>);</span><br><span class="line">        word.save(Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.doc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然也可以把创建工厂的方法写到抽象工厂类中(类似工厂方法模式的写法)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">createFactory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;fast&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FastFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;good&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GoodFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid factory name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Factory的创建可以使用单例模式，保证全局一个工厂</p>
</blockquote>
<p>抽象工厂方法模式的好处就是，如果需要替换Fast库为Google库，只要分别实现各个产品定义类和抽象工厂即可，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-桥接模式</title>
    <url>/20201030/java/designPatterns/eeac3187/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>桥接模式通过分离一个抽象接口和它的实现部分，使得设计可以按两个维度独立扩展</p>
</blockquote>
<p>桥接模式(Bridge): 将抽象化与实现化解耦，使得二者可以独立变化。是为了避免直接继承带来的子类爆炸</p>
<p>像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>汽车由引擎与品牌组成，但引擎与品牌独立变化，在两个变化维度中任意扩展一个，都不需要修改原有系统</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引擎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 混合发动机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HybridEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;混合发动机启动......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汽车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌汽车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrandCar</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getEngine().start();</span><br><span class="line">        System.out.println(<span class="string">&quot;正在驾驶： &quot;</span> + brand() + <span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 品牌名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">brand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奔驰品牌汽车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenBrandCar</span> <span class="keyword">extends</span> <span class="title">BrandCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BenBrandCar</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">brand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;奔驰&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BrandCar brandCar = <span class="keyword">new</span> BenBrandCar(<span class="keyword">new</span> HybridEngine());</span><br><span class="line">        brandCar.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果要增加一个品牌车，只需要针对BrandCar派生一个子类，任何BrandCar的子类都可以和任何一种Engine自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌───────────┐</span><br><span class="line">       │    Car    │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐       ┌─────────┐</span><br><span class="line">       │BrandCar   │ ─ ─ ─&gt;│ Engine  │</span><br><span class="line">       └───────────┘       └─────────┘</span><br><span class="line">             ▲                  ▲</span><br><span class="line">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class="line">    │                 │         ├─│  FuelEngine  │</span><br><span class="line">┌────────────┐    ┌───────────┐ │ └──────────────┘</span><br><span class="line">│AudiBrandCar│    │BenBrandCar│ │ ┌──────────────┐</span><br><span class="line">└────────────┘    └───────────┘ ├─│ElectricEngine│</span><br><span class="line">                                │ └──────────────┘</span><br><span class="line">                                │ ┌──────────────┐</span><br><span class="line">                                └─│ HybridEngine │</span><br><span class="line">                                  └──────────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能</p>
</blockquote>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>画笔，可以画正方形、长方形、圆形……又可以对这些不同形状上不同颜色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paint</span><span class="params">(String shape)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 白色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteColor</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用白色画: &quot;</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 蓝色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueColor</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用蓝色画: &quot;</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 形状</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 圆形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleShape</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getColor().paint(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正方形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareShape</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getColor().paint(<span class="string">&quot;正方形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintBridgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义白色</span></span><br><span class="line">        Color white = <span class="keyword">new</span> WhiteColor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义圆形</span></span><br><span class="line">        Shape circle = <span class="keyword">new</span> CircleShape();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用白色画圆形</span></span><br><span class="line">        circle.setColor(white);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再定义蓝色</span></span><br><span class="line">        Color blue = <span class="keyword">new</span> BlueColor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用蓝色画圆形</span></span><br><span class="line">        circle.setColor(blue);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义正方形</span></span><br><span class="line">        Shape square = <span class="keyword">new</span> SquareShape();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用蓝色画正方形</span></span><br><span class="line">        square.setColor(blue);</span><br><span class="line">        square.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用白色画正方形</span></span><br><span class="line">        square.setColor(white);</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上形状类Shape就像一个桥接，可以组合任一形状和颜色进行绘画，同时可以分别拓展形状(继承Shape类)和颜色(实现Color接口)</p>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-状态模式</title>
    <url>/20201105/java/designPatterns/3255402d/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>状态模式(State): 当对象的状态改变时，同时改变其行为，设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；</p>
<p>状态模式的实现关键在于状态转换。<strong>简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。</strong></p>
<blockquote>
<p>状态模式经常用在<strong>带有状态的对象</strong>中</p>
</blockquote>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li>定义几种状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  UserStatus &#123;</span><br><span class="line"></span><br><span class="line">    ONLINE, OFFLINE, BUSY</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义用户对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserStatus userStatus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">//默认在线</span></span><br><span class="line">        userStatus = UserStatus.ONLINE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserStatus <span class="title">getUserStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserStatus</span><span class="params">(UserStatus userStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userStatus = userStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义不同状态时的处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回复消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">reply</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在线上&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">reply</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 离线状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfflineState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已下线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">reply</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 忙碌状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正忙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">reply</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正忙，稍后回复你的消息: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义用于切换状态的上下文</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态切换上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">updateState</span><span class="params">(UserStatus userStatus)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个是Java14的写法，Java8的话老老实实写if/else吧</span></span><br><span class="line">        State state = <span class="keyword">switch</span> (userStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> BUSY -&gt; <span class="keyword">new</span> BusyState();</span><br><span class="line">            <span class="keyword">case</span> ONLINE -&gt; <span class="keyword">new</span> OnlineState();</span><br><span class="line">            <span class="keyword">case</span> OFFLINE -&gt; <span class="keyword">new</span> OfflineState();</span><br><span class="line">        &#125;;</span><br><span class="line">        state.init();</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        State state = StateContext.updateState(user.getUserStatus());</span><br><span class="line">        state.reply(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换到忙碌状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        user.setUserStatus(UserStatus.BUSY);</span><br><span class="line">        state = StateContext.updateState(user.getUserStatus());</span><br><span class="line">        state.reply(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换到离线状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        user.setUserStatus(UserStatus.OFFLINE);</span><br><span class="line">        state = StateContext.updateState(user.getUserStatus());</span><br><span class="line">        state.reply(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">我在线上</span><br><span class="line">收到消息: 你好</span><br><span class="line">============================</span><br><span class="line">我正忙</span><br><span class="line">我正忙，稍后回复你的消息: 你好</span><br><span class="line">============================</span><br><span class="line">我已下线</span><br></pre></td></tr></table></figure>

<p>所以状态模式的核心是定义一个上下文，根据传递对象的不同状态，切换不同处理(行为)，后续加入新的状态，再新增对应状态的处理逻辑(行为)即可</p>
<blockquote>
<p>状态模式可以使用枚举定义value的方式,逐级加1以便进入下个状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Step &#123;</span><br><span class="line">    DOUGH(<span class="number">4</span>), ROLLED(<span class="number">1</span>), SAUCED(<span class="number">1</span>), CHEESED(<span class="number">2</span>),</span><br><span class="line">    TOPPED(<span class="number">5</span>), BAKED(<span class="number">2</span>), SLICED(<span class="number">1</span>), BOXED(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> effort;<span class="comment">// Needed to get to the next step</span></span><br><span class="line"></span><br><span class="line">    Step(<span class="keyword">int</span> effort) &#123;</span><br><span class="line">        <span class="keyword">this</span>.effort = effort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Step <span class="title">forward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (equals(BOXED)) <span class="keyword">return</span> BOXED;</span><br><span class="line">        <span class="keyword">return</span> values()[ordinal() + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-策略模式</title>
    <url>/20201103/java/designPatterns/ca7def2a/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>策略模式(Strategy): 定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类）即使用策略(指定一个策略或者使用默认策略)的上下文</p>
<p>它实际上指，在一个方法中，<strong>流程是确定的</strong>，但是，某些<strong>关键步骤的算法依赖调用方传入的策略</strong>，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。</p>
<blockquote>
<p>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p>
</blockquote>
<p>策略模式的核心思想是在一个计算方法中<strong>把容易变化的算法抽出来作为“策略”参数传进去</strong>，从而使得新增策略不必修改原有逻辑。通过扩展策略，不必修改主逻辑，即可获得新策略的结果。</p>
<p>策略模式在Java标准库中应用非常广泛，如Arrays.sort(T[] a, Comparator&lt;? super T&gt; c), 通过传入不同的Comparator实现不同的排序算法就是一种非常典型的策略模式</p>
 <a id="more"></a>


<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现商品折扣计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────┐      ┌─────────────────┐</span><br><span class="line">│DiscountContext│─ ─ ─&gt;│DiscountStrategy │</span><br><span class="line">└───────────────┘      └─────────────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│ VipDiscountStrategy │</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                └─│OverDiscountStrategy │</span><br><span class="line">                                  └─────────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折扣策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigDecimal <span class="title">getDiscount</span><span class="params">(BigDecimal total)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会员折扣策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VipDiscountStrategy</span> <span class="keyword">implements</span> <span class="title">DiscountStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getDiscount</span><span class="params">(BigDecimal total)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会员打8折</span></span><br><span class="line">        <span class="keyword">return</span> total.multiply(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>)).setScale(<span class="number">2</span>, RoundingMode.DOWN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 满减折扣策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverDiscountStrategy</span> <span class="keyword">implements</span> <span class="title">DiscountStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getDiscount</span><span class="params">(BigDecimal total)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 满100减20优惠:</span></span><br><span class="line">        <span class="keyword">return</span> total.compareTo(BigDecimal.valueOf(<span class="number">100</span>)) &gt;= <span class="number">0</span> ? BigDecimal.valueOf(<span class="number">20</span>) : BigDecimal.ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折扣策略上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategyContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置默认策略</span></span><br><span class="line">    <span class="keyword">private</span> DiscountStrategy strategy = <span class="keyword">new</span> OverDiscountStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(DiscountStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calculatePrice</span><span class="params">(BigDecimal total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total.subtract(<span class="keyword">this</span>.strategy.getDiscount(total)).setScale(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略模式测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DiscountStrategyContext discountStrategyContext = <span class="keyword">new</span> DiscountStrategyContext();</span><br><span class="line"></span><br><span class="line">        BigDecimal bigDecimal1 = discountStrategyContext.calculatePrice(<span class="keyword">new</span> BigDecimal(<span class="number">105</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;使用默认策略(满100减20)时: &quot;</span> + bigDecimal1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改使用会员策略</span></span><br><span class="line">        discountStrategyContext.setStrategy(<span class="keyword">new</span> VipDiscountStrategy());</span><br><span class="line">        BigDecimal bigDecimal2 = discountStrategyContext.calculatePrice(<span class="keyword">new</span> BigDecimal(<span class="number">105</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;使用会员策略时: &quot;</span> + bigDecimal2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-组合模式</title>
    <url>/20201102/java/designPatterns/6719cec9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>组合模式(Composite): 将多个对象组合在一起进行操作，常用于表示树形结构中。为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p>
<blockquote>
<p>Composite模式使得叶子对象和容器对象具有一致性，从而形成统一的树形结构，并用一致的方式去处理它们</p>
</blockquote>
<p>听起来有点不好理解，我们举个例子就好理解了: 在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。又例如我们开发GUI时用到的Android或者其他技术里的各个布局编写，每个布局都是独立的，但可以任意组合排列成开发者想要的大布局，即横向布局里可以放任意横向/纵向布局，纵向布局里也可以放任意横向/纵向布局，开发者先定义一个根布局，然后在内部添加任意布局</p>
 <a id="more"></a>

<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>模拟xml节点：</p>
<ul>
<li><p>定义节点接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Node&gt; <span class="title">getChildren</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toXml</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义容器节点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementNode</span> <span class="keyword">implements</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElementNode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        nodeList.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodeList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String start = <span class="string">&quot;&lt;&quot;</span> + name + <span class="string">&quot;&gt;\n&quot;</span>;</span><br><span class="line">        String end = <span class="string">&quot;&lt;/&quot;</span> + name + <span class="string">&quot;&gt;\n&quot;</span>;</span><br><span class="line">        StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;&quot;</span>, start, end);</span><br><span class="line">        nodeList.forEach(node -&gt; &#123;</span><br><span class="line">            sj.add(node.toXml() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义文本节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextNode</span> <span class="keyword">implements</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextNode</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;不支持添加节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义注释节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommentNode</span> <span class="keyword">implements</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommentNode</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;不支持添加节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;!--&quot;</span> + text + <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试验证</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node studentsNode = <span class="keyword">new</span> ElementNode(<span class="string">&quot;students&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Node studentNode1 = <span class="keyword">new</span> ElementNode(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        studentsNode.add(studentNode1);</span><br><span class="line"></span><br><span class="line">        studentNode1.add(<span class="keyword">new</span> TextNode(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Node studentNode2 = <span class="keyword">new</span> ElementNode(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        studentsNode.add(studentNode2);</span><br><span class="line"></span><br><span class="line">        studentNode2.add(<span class="keyword">new</span> TextNode(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加注释</span></span><br><span class="line">        studentNode2.add(<span class="keyword">new</span> CommentNode(<span class="string">&quot;这位同学叫李四&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(studentsNode.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&lt;students&gt;</span><br><span class="line">&lt;student&gt;</span><br><span class="line">张三</span><br><span class="line">&lt;/student&gt;</span><br><span class="line"></span><br><span class="line">&lt;student&gt;</span><br><span class="line">李四</span><br><span class="line">&lt;!--这位同学叫李四&gt;</span><br><span class="line">&lt;/student&gt;</span><br><span class="line"></span><br><span class="line">&lt;/students&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过以上代码就可以实现简易版的xml布局了</p>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-装饰器模式</title>
    <url>/20201029/java/designPatterns/87feaab1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>装饰器模式(Decorator)，是一种在运行期动态给某个对象的实例增加功能的方法。</p>
</blockquote>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>
<p>实际上Java标准库中对于IO流的处理就应用了装饰器模式: 通过FileInputStream获取原始文件流，如果需要增加缓冲功能就用BufferedInputStream包装下，如果还需要解压缩功能就再用GZIPInputStream包装下…, 无论包装多少次，得到的对象始终是InputStream。</p>
<p>使用Decorator模式<strong>实际上把核心功能和附加功能给分开了</strong>。核心功能指FileInputStream这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。</p>
<ul>
<li>如果我们要新增核心功能，就增加Component的子类，例如ByteInputStream。</li>
<li>如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。</li>
</ul>
<p>两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<blockquote>
<p>装饰模式在不改变原先核心功能的情况下，可以实现增强，并且不会产生很多继承类，按照业务模块划分，通过不同的方法进行装饰。</p>
</blockquote>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们以给汽车加装饰来举例</p>
<ul>
<li>定义一辆车</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汽车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奥迪车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奥迪车启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义装饰器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汽车装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarDecorator</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarDecorator</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车灯装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarLightDecorator</span> <span class="keyword">extends</span> <span class="title">CarDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarLightDecorator</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;改装一个大灯&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车贴装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarStickerDecorator</span> <span class="keyword">extends</span> <span class="title">CarDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarStickerDecorator</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;贴上一个车贴&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试验证</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> AudiCar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改装大灯-带改装大灯的车</span></span><br><span class="line">        car = <span class="keyword">new</span> CarLightDecorator(car);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//贴上车贴-带车贴的车</span></span><br><span class="line">        car = <span class="keyword">new</span> CarStickerDecorator(car);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动</span></span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面如果想要增加带新的装饰的车只要编写新类继承CarDecorator即可，想要增加新车则编写新类继承Car。互不影响</p>
<p>或者不想有车贴，直接去除CarStickerDecorator即可</p>
<blockquote>
<p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-观察者模式</title>
    <url>/20201103/java/designPatterns/8603fba1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>观察者模式(Observer): 又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>
<p>Java标准库虽然提供了java.util.Observer和java.util.Observable这两个类用于实现观察者模式，但是Java9开始已经废弃java.util.Observer和java.util.Observable这两个类, 实现观察者模式的时候不推荐使用:</p>
<blockquote>
<p>此类和Observer接口已被弃用。 Observer和Observable支持的事件模型非常有限，Observable传递的通知顺序未指定，并且状态更改与通知不一一对应。 对于更丰富的事件模型，请考虑使用java.beans包。 为了在线程之间进行可靠且有序的消息传递，请考虑使用java.util.concurrent包中的并发数据结构之一。 有关反应式流样式的编程，请参阅Flow API。</p>
</blockquote>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="java-bean实现"><a href="#java-bean实现" class="headerlink" title="java.bean实现"></a>java.bean实现</h2><p>从java.beans包使用PropertyChangeEvent和PropertyChangeListener(Listeners，类型很多，它们都有回调方法，不需要强制转换)</p>
<h3 id="PropertyChangeSupport"><a href="#PropertyChangeSupport" class="headerlink" title="PropertyChangeSupport"></a>PropertyChangeSupport</h3><ul>
<li>addPropertyChangeListener(PropertyChangeListener listener)<br>顾名思义，添加对bean的监听。</li>
<li>removePropertyChangeListener(PropertyChangeListener listener)<br>移除监听。</li>
<li>firePropertyChange(String propertyName, int oldValue, int newValue)<br>添加对bean内某个变量的监听，第一个参数最好是变量名，第二个是变量改变前的值，第二个是变量改变后的值</li>
</ul>
<h3 id="PropertyChangeEvent"><a href="#PropertyChangeEvent" class="headerlink" title="PropertyChangeEvent"></a>PropertyChangeEvent</h3><ul>
<li>getPropertyName() 获取发生改变的变量名。</li>
<li>getSource() 获取改变的bean对象</li>
<li>getOldValue() 获取发生改变的变量的旧值。</li>
<li>getNewValue() 获取发生改变的变量的新值</li>
</ul>
<blockquote>
<p>当bean很多的时候特别好用，用propertyChangeEvent.getSource()就能区分是哪个bean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertyChangeSupport propertyChangeSupport = <span class="keyword">new</span> PropertyChangeSupport(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        Integer oldValue = <span class="keyword">this</span>.id;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="comment">// Fires a property change event</span></span><br><span class="line">        propertyChangeSupport.firePropertyChange(<span class="string">&quot;id&quot;</span>, oldValue, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String oldValue = <span class="keyword">this</span>.name;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// Fires a property change event</span></span><br><span class="line">        propertyChangeSupport.firePropertyChange(<span class="string">&quot;name&quot;</span>, oldValue, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyChangeSupport <span class="title">getPropertyChangeSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyChangeSupport;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">        product.getPropertyChangeSupport().addPropertyChangeListener(evt -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;发生了变化: &quot;</span> + evt.getPropertyName() + <span class="string">&quot; 旧值: &quot;</span> + evt.getOldValue() + <span class="string">&quot; 新值: &quot;</span> + evt.getNewValue())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以直接值监听某个熟悉</span></span><br><span class="line">        product.getPropertyChangeSupport().addPropertyChangeListener(<span class="string">&quot;name&quot;</span>, evt -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name发生了变化: &quot;</span> + evt.getPropertyName() + <span class="string">&quot; 旧值: &quot;</span> + evt.getOldValue() + <span class="string">&quot; 新值: &quot;</span> + evt.getNewValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        product.setId(<span class="number">1</span>);</span><br><span class="line">        product.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        product.setName(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出打印</span></span><br><span class="line"><span class="comment">//发生了变化: id 旧值: null 新值: 1</span></span><br><span class="line"><span class="comment">//发生了变化: name 旧值: null 新值: admin</span></span><br><span class="line"><span class="comment">//name发生了变化: name 旧值: null 新值: admin</span></span><br><span class="line"><span class="comment">//发生了变化: name 旧值: admin 新值: user1</span></span><br><span class="line"><span class="comment">//name发生了变化: name 旧值: admin 新值: user1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是初次赋值时oldvalue是null，记得判空，否则会导致后续监听失败</p>
</blockquote>
<h2 id="Flow实现"><a href="#Flow实现" class="headerlink" title="Flow实现"></a>Flow实现</h2><p>Java9提供了java.util.concurrent.Flow(熟悉RxJava库的朋友对于这种用法应该非常熟悉)</p>
<p>Flow是一类在Java中9中引入并具有4个相互关联的接口：</p>
<ul>
<li>Publisher：发布者，负责发布消息；</li>
<li>Subscriber：订阅者，负责订阅处理消息；</li>
<li>Subscription：订阅控制类，可用于发布者和订阅者之间通信；</li>
<li>Processor：处理者，同时充当Publisher和Subscriber的角色</li>
</ul>
<p>Flow类还包含defaultBufferSize()静态方法，它返回发布者和订阅者使用的缓冲区的默认大小。 目前，它返回256。</p>
<blockquote>
<p>另外还有SubmissionPublisher<T>类是Flow.Publisher<T>接口的实现类。 该类实现了AutoCloseable接口，因此可以使用try-with-resources块来管理其实例。 SubmissionPublisher<T>是Flow.Publisher<T>的实现，她可以灵活的生产数据，同时与Reactive Stream兼容:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SubmissionPublisher()</span><br><span class="line">SubmissionPublisher(Executor executor, int maxBufferCapacity)</span><br><span class="line">SubmissionPublisher(Executor executor, int maxBufferCapacity, BiConsumer&lt;? super Flow.Subscriber&lt;? super T&gt;,? super Throwable&gt; handler)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;简单的例子</span><br><span class="line"> SubmissionPublisher&lt;String&gt; publisher &#x3D; new SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        publisher.subscribe(new Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Flow.Subscription subscription) &#123;</span><br><span class="line">                logger.debug(&quot;onSubscribe&quot;);</span><br><span class="line">                &#x2F;&#x2F;反向控制获取数据个数</span><br><span class="line">                subscription.request(10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(String item) &#123;</span><br><span class="line">                logger.debug(&quot;onNext: &quot; + item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable throwable) &#123;</span><br><span class="line">                logger.debug(&quot;onError: &quot; + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                logger.debug(&quot;onComplete&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发布单个数据</span><br><span class="line">        publisher.submit(&quot;11111&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发布多个数据</span><br><span class="line">        String[] items &#x3D; &#123;&quot;1&quot;, &quot;x&quot;, &quot;2&quot;, &quot;x&quot;, &quot;3&quot;, &quot;x&quot;&#125;;</span><br><span class="line">        Arrays.stream(items).forEach(publisher::submit);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;关闭发布, 关闭publisher，没有该函数则Subscriber.onComplete()不会被调用</span><br><span class="line">        publisher.close();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意Flow是异步的流处理, 故可以结合线程池一起处理, 有关Flow的文章后续整理下(尽管Flow API允许程序员开始编写响应式程序，但是生态系统仍然需要发展)</p>
</blockquote>
<h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>当然也可以自己来实现，不过需要注意的是:</p>
<ul>
<li>如果设计成各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知</li>
<li>如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者</li>
</ul>
<p><strong>注意实际使用观察者模式需关注背压问题(即消费速度赶不上生产速度)</strong></p>
<h1 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h1><p>如果是使用的Spring框架，推荐直接使用Spring中实现的观察者模式：</p>
<ul>
<li>自定义需要发布的事件类，需要继承 ApplicationEvent 类或 PayloadApplicationEvent (该类也仅仅是对 ApplicationEvent 的一层封装)</li>
<li>使用 @EventListener 来监听事件或者实现 ApplicationListener 接口。</li>
<li>使用 ApplicationEventPublisher 来发布自定义事件（@Autowired注入即可）</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>编写自定义事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new &#123;<span class="doctag">@code</span> ApplicationEvent&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the object on which the event initially occurred or with</span></span><br><span class="line"><span class="comment">     *               which the event is associated (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编写自定义listener, 收到事件后的处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationListener</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Async</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        String source = (String) event.getSource();</span><br><span class="line">        logger.info(<span class="string">&quot;我是: &#123;&#125;, 收到更新数据为：&#123;&#125;s\n&quot;</span>, <span class="keyword">this</span>.name, source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>模拟定义几个事件接收者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyApplicationListener <span class="title">readerListener1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyApplicationListener(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyApplicationListener <span class="title">readerListener2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyApplicationListener(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyApplicationListener <span class="title">readerListener3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyApplicationListener(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编写测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringObserverTest</span> <span class="keyword">extends</span> <span class="title">AbstractJUnit4SpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEventTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试用例，可以在控制台中看到打印了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是: 张三, 收到更新数据为：Hello Worlds</span><br><span class="line"></span><br><span class="line">我是: 李四, 收到更新数据为：Hello Worlds</span><br><span class="line"></span><br><span class="line">我是: 王五, 收到更新数据为：Hello Worlds</span><br></pre></td></tr></table></figure>

<p>如果业务逻辑中需要发送事件，可以实现ApplicationEventPublisherAware接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123; <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 执行注册逻辑</span></span><br><span class="line">        logger.info(<span class="string">&quot;[register][执行用户(&#123;&#125;) 的注册逻辑]&quot;</span>, username);</span><br><span class="line">        <span class="comment">// &lt;2&gt; ... 发布</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, username));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-解释器模式</title>
    <url>/20201105/java/designPatterns/2ce89565/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>解释器模式(Interpreter): 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</p>
<p>解释器模式是一种针对特定问题设计的一种解决方案， 一般主要应用在OOP开发中的编译器的开发中</p>
<p>java中正则表达式以及SQL中SQL语句的具体实现就是解析器模式的典型体现：</p>
<ul>
<li>把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器</li>
<li>当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-访问者模式</title>
    <url>/20201105/java/designPatterns/7892876e/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>访问者模式(Visitor)是为了抽象出作用于一组复杂对象的操作，并且后续可以新增操作而不必对现有的对象结构做任何改动</p>
<p>访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<p>访问者模式适用于数据结构相对稳定的系统，把<strong>数据结构和算法解耦</strong></p>
<p>Java标准库提供的Files.walkFileTree()就实现了一个访问者模式</p>
<p>对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点</p>
 <a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们来模拟遍历文件夹不同情况的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件访问者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitFile</span><span class="params">(File file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitDir</span><span class="params">(File dir)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件扫描器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(File file, FileVisitor fileVisitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">            fileVisitor.visitDir(file);</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File f : files) &#123;</span><br><span class="line">                scan(f, fileVisitor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileVisitor.visitFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileVisitorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileScanner.scan(<span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>), <span class="keyword">new</span> FileVisitor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件名: &quot;</span> + file.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件夹名: &quot;</span> + dir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把递归遍历文件夹的过程封装起来，外部根据自己的实际要求获取所有的文件和文件夹或者只获取特定类型的文件</p>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-适配器模式</title>
    <url>/20201028/java/designPatterns/e9e2ac5d/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器模式是Adapter，也称Wrapper(所以如果看到源码中有以这两个结尾的类，那么大概率使用了适配器模式), java中实现适配器模式共有三种：</p>
<ul>
<li><p>类适配器: 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可</p>
</li>
<li><p>对象适配器: 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。使用组合替代继承，故相比较类适配器，<strong>对象适配器更加常用</strong>。</p>
</li>
<li><p>接口适配器: 当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可</p>
<a id="more"></a>

</li>
</ul>
<p>适配器是为了解决类兼容性问题的，实际上java标准库中也有很多地方使用了适配器模式，典型的线程池中为了能让Thread可以调用Callable接口使用了RunnableAdapter这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot;[Wrapped task = &quot;</span> + task + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们以给手机充电来举例说明适配器的用途</p>
<ul>
<li>定义220V的电源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中国的电源-220V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerWith220V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">discharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;220V的电源正在放电...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义充电器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 充电器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Charger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接入电源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> powerWith220V</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">connectPower</span><span class="params">(PowerWith220V powerWith220V)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际充电器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargerImpl</span> <span class="keyword">implements</span> <span class="title">Charger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PowerWith220V powerWith220V;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">connectPower</span><span class="params">(PowerWith220V powerWith220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.powerWith220V = powerWith220V;</span><br><span class="line">        System.out.println(<span class="string">&quot;充电器接入电源成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>定义手机</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Charger charger)</span> </span>&#123;</span><br><span class="line">        Integer outVoltage = charger.discharge();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在充电...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟下手机充电<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个手机</span></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone(<span class="string">&quot;vivo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个220v电源</span></span><br><span class="line">        PowerWith220V powerWith220V = <span class="keyword">new</span> PowerWith220V();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个充电器</span></span><br><span class="line">        Charger charger = <span class="keyword">new</span> ChargerImpl();</span><br><span class="line">        <span class="comment">//充电器接入电源</span></span><br><span class="line">        charger.connectPower(powerWith220V);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手机充电</span></span><br><span class="line">        phone.charge(charger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以上没有问题，但突然某一天手机的使用者来到了美国，而美国的电源都是110V的，如果是以上设计，明显就无法满足需求了</p>
<p>所以为了能成功给手机充电，我们就需要一个<strong>适配器</strong>：</p>
<ul>
<li>先定义一个110V的电源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerWith110V</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">discharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;110V的电源正在放电...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">110</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>定义适配器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新充电器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewCharger</span> <span class="keyword">extends</span> <span class="title">Charger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接入电源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> powerWith110V</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">connectPower</span><span class="params">(PowerWith110V powerWith110V)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 充电适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargerAdapter</span> <span class="keyword">implements</span> <span class="title">NewCharger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Charger charger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PowerWith110V powerWith110V;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChargerAdapter</span><span class="params">(Charger charger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charger = charger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">connectPower</span><span class="params">(PowerWith110V powerWith110V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.powerWith110V = powerWith110V;</span><br><span class="line">        System.out.println(<span class="string">&quot;充电器接入110V电源成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">connectPower</span><span class="params">(PowerWith220V powerWith220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> charger.connectPower(powerWith220V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>继续充电</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个手机</span></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone(<span class="string">&quot;vivo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个220v电源</span></span><br><span class="line">        PowerWith220V powerWith220V = <span class="keyword">new</span> PowerWith220V();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个充电器</span></span><br><span class="line">        Charger charger = <span class="keyword">new</span> ChargerImpl();</span><br><span class="line">        <span class="comment">//接入220V电源</span></span><br><span class="line">        charger.connectPower(powerWith220V);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手机充电</span></span><br><span class="line">        phone.charge(charger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个110V的电源</span></span><br><span class="line">        PowerWith110V powerWith110V = <span class="keyword">new</span> PowerWith110V();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义适配器</span></span><br><span class="line">        NewCharger newCharger = <span class="keyword">new</span> ChargerAdapter(charger);</span><br><span class="line">        <span class="comment">//接入110V电源</span></span><br><span class="line">        newCharger.connectPower(powerWith110V);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手机充电</span></span><br><span class="line">        phone.charge(newCharger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样可以接入220V电源</span></span><br><span class="line">        newCharger.connectPower(powerWith220V);</span><br><span class="line"></span><br><span class="line">        phone.charge(newCharger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实这个示例中可以理解为: </p>
<p>为了能将电源的电提供给手机，使用了适配器-创建一个充电器(转换电源)</p>
<p>为了能兼容220V和110V的电源，使用了适配器-创建了一个充电适配器(转换不同电源)</p>
<blockquote>
<p>市面上常用的各种转接头如果用代码实现的话，也可以认为是适配器模式</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式</title>
    <url>/20200811/java/designPatterns/56df777e/</url>
    <content><![CDATA[<blockquote>
<p>设计模式是为了可扩展性，不要为了使用设计模式而使用</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式关注点是<strong>如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换</strong>，共五种：</p>
<ul>
<li><a href="/20201027/java/designPatterns/8dc1e828">工厂方法模式FactoryMethod</a>: 定义一个用于创建产品的接口，由子类决定生产什么产品</li>
<li><a href="/20201027/java/designPatterns/5ee502d3">抽象工厂模式AbstractFactory</a>: 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品</li>
<li><a href="/20201105/java/designPatterns/49fe4565">单例模式Singleton</a>: 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式</li>
<li><a href="/20201105/java/designPatterns/e2a6f58b">建造者模式Builder</a>: 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象</li>
<li><a href="/20201106/java/designPatterns/2933c5b8">原型模式Prototype</a>: 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式主要涉及<strong>如何组合各种对象以便获得更好、更灵活的结构</strong>，共七种：</p>
<ul>
<li><a href="/20201028/java/designPatterns/e9e2ac5d">适配器模式Adapter</a>: 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</li>
<li><a href="/20201029/java/designPatterns/87feaab1">装饰器模式Decorator</a>: 动态的给对象增加一些职责，即增加其额外的功能</li>
<li><a href="/20200716/java/designPatterns/c3cf574b">代理模式Proxy</a>: 为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性</li>
<li><a href="/20201030/java/designPatterns/4f40d3f3">外观模式Facade</a>: 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问</li>
<li><a href="/20201030/java/designPatterns/eeac3187">桥接模式Bridge</a>: 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</li>
<li><a href="/20201102/java/designPatterns/6719cec9">组合模式Composite</a>: 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性</li>
<li><a href="/20201102/java/designPatterns/5903f011">享元模式Flyweight</a>: 运用共享技术来有效地支持大量细粒度对象的复用</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式主要涉及算法和对象间的职责分配。这些设计模式是特别侧重于对象之间的通信，<strong>通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务</strong>，共十一种：</p>
<ul>
<li><a href="/20201103/java/designPatterns/ca7def2a">策略模式Strategy</a>: 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户</li>
<li><a href="/20201103/java/designPatterns/295e2dfa">模板方法模式TemplateMethod</a>: 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</li>
<li><a href="/20201103/java/designPatterns/8603fba1">观察者模式Observer</a>: 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为</li>
<li>迭代器模式Iterator: 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</li>
<li><a href="/20200927/java/designPatterns/7e2ffbc9">责任链模式Chain of Responsibility</a>: 把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合</li>
<li><a href="/20201103/java/designPatterns/c08d175c">命令模式Command</a>: 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开</li>
<li><a href="/20201105/java/designPatterns/df30fde2">备忘录模式Memento</a>: 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它</li>
<li><a href="/20201105/java/designPatterns/3255402d">状态模式State</a>: 允许一个对象在其内部状态发生改变时改变其行为能力</li>
<li><a href="/20201105/java/designPatterns/7892876e">访问者模式Visitor</a>: 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问</li>
<li><a href="/20201105/java/designPatterns/cc119eab">中介者模式Mediator</a>: 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解</li>
<li><a href="/20201105/java/designPatterns/2ce89565">解释器模式Interpreter</a>: 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器</li>
</ul>
<blockquote>
<p>见名思意, 代码中出现了类名存在如Adapter、Factory、Decorator等，可以联想到对应的设计模式，无论自己编写还是查阅他人代码</p>
</blockquote>
<p>设计模式需要满足：</p>
<ul>
<li>开闭原则(Open Close Principle): 软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的</li>
<li>里氏替换原则(Liskov Substitution Principle): 即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行</li>
<li>依赖倒转原则(Dependence Inversion Principle): 针对接口编程，依赖于抽象而不依赖于具体</li>
<li>接口隔离原则(Interface Segregation Principle): 使用多个隔离的接口，比使用单个接口要好</li>
<li>迪米特法则(Demeter Principle): 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</li>
<li>合成复用原则(Composite Reuse Principle): 尽量使用合成/聚合的方式，而不是使用继承</li>
</ul>
<p><strong>特别感谢<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528">廖雪峰老师的文章</a>推荐学习!</strong></p>
 <a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;todo</span><br></pre></td></tr></table></figure>

<h1 id="模式间的区别"><a href="#模式间的区别" class="headerlink" title="模式间的区别"></a>模式间的区别</h1><h2 id="装饰器模式VS代理模式"><a href="#装饰器模式VS代理模式" class="headerlink" title="装饰器模式VS代理模式"></a>装饰器模式VS代理模式</h2><p><strong>装饰模式</strong> 注重对对象功能的扩展，它不关心外界如何调用，只注重对对象功能的加强，<strong>装饰后还是对象本身</strong></p>
<p><strong>代理模式</strong> 注重对对象某一功能的流程把控和辅助。它可以控制对象做某些事，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制，重心是为了<strong>借用对象的功能完成某一流程</strong>，而非对象功能如何。</p>
<h2 id="建造者模式VS桥接模式"><a href="#建造者模式VS桥接模式" class="headerlink" title="建造者模式VS桥接模式"></a>建造者模式VS桥接模式</h2><p>最终目标都是构造大对象</p>
<p><strong>建造者模式</strong>：初始化每个变量的时候，都返回了最终的对象，就是你可以<strong>不完全链式的点完所有变量</strong>，亦可得到可使用的对象；每个成员变量在构造时是同层次的</p>
<p><strong>桥接模式</strong>: 初始化时，<strong>每个部分缺一不可</strong>；每个成员变量的层级不同，使用最小的部件，逐层往上初始化直至整个对象，类似于用 发动机-&gt; 引擎模块 -&gt;  引擎模块 + 车壳（类比文中品牌）-&gt; 完整的汽车 【一级连接一级，有点桥接的意思】</p>
<h2 id="享元模式VS单例模式"><a href="#享元模式VS单例模式" class="headerlink" title="享元模式VS单例模式"></a>享元模式VS单例模式</h2><ul>
<li><p>享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。</p>
</li>
<li><p>享元模式是为了节约内存空间，提升程序性能，而单例模式则主要是出于共享状态的目的。</p>
</li>
</ul>
<h2 id="工厂方法模式VS抽象工厂模式VS模板方法模式"><a href="#工厂方法模式VS抽象工厂模式VS模板方法模式" class="headerlink" title="工厂方法模式VS抽象工厂模式VS模板方法模式"></a>工厂方法模式VS抽象工厂模式VS模板方法模式</h2><ul>
<li>简单工厂能把具体实现包装起来，让客户端真正达到面向接口编程 </li>
<li>工厂方法可以在高层进行编码，让服务端的产品线真正达到面向接口编程 </li>
<li>抽象工厂能聚合整个产品簇，让整个服务端的多个产品线真正达到面向接口编程 </li>
<li>模板方法同样是在高层进行编码，也同样是面向接口编程。 </li>
</ul>
<p>但工厂方法及抽象工厂方法着重抽象的是产品，而模板方法着重抽象的是步骤。<br>而我们通常会两者一起结合起来使用。</p>
<blockquote>
<p>GOF是设计模式的经典名著Design Patterns: Elements of Reusable Object-Oriented Software（中译本名为《设计模式——可复用面向对象软件的基础》）的四位作者，他们分为是：Elich Gamma、Richard Helm、Ralph Johnson、以及John Vlissides。这四个人常被称为Gang of Four， 即四人组，简称Gof</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>java随机数</title>
    <url>/20200713/java/3a0ad540/</url>
    <content><![CDATA[<h1 id="1-Random"><a href="#1-Random" class="headerlink" title="1.Random"></a>1.Random</h1><p>Random从java1.0开始就已经引入，是线程安全的。</p>
<a id="more"></a>

<blockquote>
<p>初始化</p>
</blockquote>
<p>Random初始化时，默认采用seeduniquifier方法生成的seed和获取到的当前原子时钟的当前时间的与操作后的值来初始化一个随机数种子。因为System.nanoTime()是一直变化的，所以种子一定是每次都不一样的，默认初始化的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Random() &#123;</span><br><span class="line">        this(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* seedUniquifier解释</span><br><span class="line">* 该方法是一个类似while(true)的无限循环for (;;)</span><br><span class="line">* 循环结束的条件是把seedUniquifier和一个常量值的乘积赋值给seedUniquifier，然后判断是否等于seedUniquifier.get()</span><br><span class="line">*&#x2F;</span><br><span class="line">  private static long seedUniquifier() &#123;</span><br><span class="line">        &#x2F;&#x2F; L&#39;Ecuyer, &quot;Tables of Linear Congruential Generators of</span><br><span class="line">        &#x2F;&#x2F; Different Sizes and Good Lattice Structure&quot;, 1999</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            long current &#x3D; seedUniquifier.get();</span><br><span class="line">            long next &#x3D; current * 1181783497276652981L;</span><br><span class="line">            if (seedUniquifier.compareAndSet(current, next))</span><br><span class="line">                return next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final AtomicLong seedUniquifier</span><br><span class="line">        &#x3D; new AtomicLong(8682522807148012L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机方法</p>
</blockquote>
<p>其核心方法是 next方法，不管是调用了nextDouble还是nextInt还是nextBoolean，底层都是调这个next(int bits)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，以保证原子更新一个数。</span><br><span class="line">* 当然也可以看出多个线程如果更新设置失败，会不停的在while循环执行，并且由于采用了多个线程共享一个 Random 实例。这样就会导致多个线程争用，出现性能上的问题</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    AtomicLong seed &#x3D; this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed &#x3D; seed.get();</span><br><span class="line">        nextseed &#x3D; (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-ThreadLocalRandom"><a href="#2-ThreadLocalRandom" class="headerlink" title="2.ThreadLocalRandom"></a>2.ThreadLocalRandom</h1><p>为了在多线程并发情况下，减少多线程资源竞争，保证线程的安全性。java1.7新增了ThreadLocalRandom，继承于Random。</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>因为构造器是默认访问权限，只能在java.util包中创建对象，故提供了一个方法ThreadLocalRandom.current()用于返回当前类的对象, 可以看到每个线程都持有一个本地的种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下计算新种子时，是根据自己线程内维护的种子变量进行更新，这就完全杜绝了线程间的竞争问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ThreadLocalRandom current() &#123;</span><br><span class="line">    if (U.getInt(Thread.currentThread(), PROBE) &#x3D;&#x3D; 0)</span><br><span class="line">        localInit();</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final void localInit() &#123;</span><br><span class="line">    int p &#x3D; probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    int probe &#x3D; (p &#x3D;&#x3D; 0) ? 1 : p; &#x2F;&#x2F; skip 0</span><br><span class="line">    long seed &#x3D; mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    U.putLong(t, SEED, seed);</span><br><span class="line">    U.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机方法</p>
</blockquote>
<p>ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final long nextSeed() &#123;</span><br><span class="line">    Thread t; long r; &#x2F;&#x2F; read and update per-thread seed</span><br><span class="line">    U.putLong(t &#x3D; Thread.currentThread(), SEED,</span><br><span class="line">                r &#x3D; U.getLong(t, SEED) + GAMMA);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="使用JMH进行测试"><a href="#使用JMH进行测试" class="headerlink" title="使用JMH进行测试"></a>使用JMH进行测试</h1><h2 id="随机0-10"><a href="#随机0-10" class="headerlink" title="随机0-10"></a>随机0-10</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@BenchmarkMode(Mode.AverageTime) &#x2F;&#x2F;平均时间</span><br><span class="line">@State(Scope.Benchmark) &#x2F;&#x2F;所有测试线程共享一个实例</span><br><span class="line">@OutputTimeUnit(TimeUnit.NANOSECONDS) &#x2F;&#x2F;统计结果的时间单位</span><br><span class="line">@Warmup(iterations &#x3D; 3, time &#x3D; 1, timeUnit &#x3D; TimeUnit.SECONDS) &#x2F;&#x2F;预热迭代3次，每次1s</span><br><span class="line">@Measurement(iterations &#x3D; 5, time &#x3D; 1, timeUnit &#x3D; TimeUnit.SECONDS) &#x2F;&#x2F;实际测试5次，每次1s</span><br><span class="line">@Fork(2) &#x2F;&#x2F;进行 fork 的次数</span><br><span class="line">&#x2F;&#x2F;@Threads(4)</span><br><span class="line">public class RandomTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws RunnerException &#123;</span><br><span class="line">        Options opt &#x3D; new OptionsBuilder()</span><br><span class="line">                .include(RandomTest.class.getSimpleName())</span><br><span class="line">                .result(&quot;random-result.json&quot;)</span><br><span class="line">                .resultFormat(ResultFormatType.JSON).build();</span><br><span class="line">        new Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Benchmark</span><br><span class="line">    public void testRandom(Blackhole blackhole) &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        int result &#x3D; random.nextInt(10);</span><br><span class="line">        System.out.println(&quot;random随机数: &quot; + result);</span><br><span class="line">        &#x2F;&#x2F;JVM 可能会认为变量 result 从来没有使用过，从而进行优化把整个方法内部代码移除掉，这就会影响测试结果。</span><br><span class="line">        &#x2F;&#x2F; JMH 提供了两种方式避免这种问题，一种是将这个变量作为方法返回值 return a，一种是通过 Blackhole 的 consume 来避免 JIT 的优化消除</span><br><span class="line">        blackhole.consume(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Benchmark</span><br><span class="line">    public void testThreadLocalRandom(Blackhole blackhole) &#123;</span><br><span class="line">        ThreadLocalRandom threadLocalRandom &#x3D; ThreadLocalRandom.current();</span><br><span class="line">        int result &#x3D; threadLocalRandom.nextInt(10);</span><br><span class="line">        blackhole.consume(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://github.com/jonesun/blog/blob/master/source/image/jmh/JMH-Visual-Chart-Random.png?raw=true" alt="image"> </p>
<p>可以看到ThreadLocalRandom效率最高</p>
<h1 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h1><p>使用Random创建的是伪随机数，只要给定一个初始的种子，产生的随机数序列是完全一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Random r &#x3D; new Random(12345);</span><br><span class="line">       for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">           System.out.println(r.nextInt(100));</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 51, 80, 41, 28, 55...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>不指定种子的话，默认的统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同</p>
<blockquote>
<p>Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子</p>
</blockquote>
<p>而在有些场景中我们需要安全的随机数，即不能被预测到的，这个时候就需要用SecureRandom</p>
<blockquote>
<p>SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SecureRandom sr &#x3D; new SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(100));</span><br><span class="line"></span><br><span class="line">SecureRandom sr &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    sr &#x3D; SecureRandom.getInstanceStrong(); &#x2F;&#x2F; 获取高强度安全随机数生成器</span><br><span class="line">&#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">    sr &#x3D; new SecureRandom(); &#x2F;&#x2F; 获取普通的安全随机数生成器</span><br><span class="line">&#125;</span><br><span class="line">byte[] buffer &#x3D; new byte[16];</span><br><span class="line">sr.nextBytes(buffer); &#x2F;&#x2F; 用安全随机数填充buffer</span><br><span class="line">System.out.println(Arrays.toString(buffer));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins使用</title>
    <url>/20210706/jenkins/9b38587/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>话说不会偷懒的程序员不是好的程序员，笔者就时常如果有一个软件能够帮我把日常的体力工作都给干了，这样就可以有时间做更多的脑力工作了。<br>逛博客的时候，经常看到DevOps和CI/CD的相关文章，抱着试试看的想法研究下如何实现。当然跟很多初次看到这几个单词都一脸懵的朋友一样，肯定搜索下都是什么意思:</p>
<blockquote>
<p>DevOps: DevOps是Development和Operations的组合，是一种重视软件开发人员（Dev）和运维人员（Ops）之间沟通合作的文化，运动和惯例，用于促进应用开发、应用运维和质量保障（QA）部门之间的沟通、协作与整合。以期打破传统开发和运营之间的壁垒和鸿沟。 通过自动化软件交付和架构变更的流程，使构建，测试，发布软件能够更快，频繁和可信。</p>
</blockquote>
<blockquote>
<p>CI: 持续集成（Continuous Integration，简称 CI），开发人员各自编写自己负责部分的代码，然后上传到源代码库中合并，CI服务器负责构建软件并测试是否能正常运行，将测试结果反馈给开发人员。</p>
</blockquote>
<blockquote>
<p>CD: 持续交付（Continuous Delivery，简称 CD）和持续部署(Continuous Deployment)，是在持续集成的基础上将集成后的代码部署到更贴近真实运行的环境中去进行进一步的测试，并可以在多种不同的配置上测试代码，运行额外的性能测试，并自动化每个步骤直到部署到生产环境。</p>
</blockquote>
<p>需要注意的是: 持续交付并不是指软件每一个改动都要尽快部署到产品环境中，它指的是<strong>任何的代码修改都可以在任何时候实施部署</strong>，持续部署是作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。</p>
<p>好像有点意思了，按照笔者的理解：平常我们写完代码完成自测后提交代码后，就有工具可以帮我们自动编译和测试，如果没有问题就自动打包并部署到实际的生产环境中。看上去很不错的样子，那么怎么实现呢？</p>
 <a id="more"></a>

<p><img src="jenkins-logo.jpg" alt="jenkins-logo"></p>
<p><a href="https://www.jenkins.io/zh//">Jenkins</a> 著名的可扩展的开源CI/CD工具，可以自动执行与软件的构建，测试，部署，集成和发布有关的任务。Jenkins完全用Java编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Jenkins可在macOS，Windows和各种UNIX版本（例如OpenSUSE，Ubuntu，Red Hat等）上使用。除了通过本机安装软件包进行安装外，它还可以独立安装或作为Docker在任何有Java Runtime Environment（JRE）的计算机上安装。</p>
<h2 id="Windows上安装"><a href="#Windows上安装" class="headerlink" title="Windows上安装"></a>Windows上安装</h2><p>由于笔者平常工作使用的是Windows系统，下面就从Windows开始尝试一步一步安装，详细移步这篇文章：<a href="/20210706/jenkins/a15eda66/">windows上安装jenkins</a></p>
<h2 id="Docker-Desktop上安装"><a href="#Docker-Desktop上安装" class="headerlink" title="Docker Desktop上安装"></a>Docker Desktop上安装</h2><p>现在Docker也比较火，Jenkins在Docker上的安装也是比较简单的，我们直接在Windows上使用Docker Desktop来进行安装</p>
<p>拉取最新镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:latest //最新版</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins -p 8040:8080 -p 50000:50000 -v /d/env/docker/jenkins_home:/var/jenkins_home -v /d/env/Java/jdk1.8.0_231:/usr/local/jdk -v /d/env/apache-maven-3.8.1:/usr/local/maven jenkins/jenkins:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>-d：后台运行容器</li>
<li>–name：指定容器启动的名称</li>
<li>-p：指定映射的端口，这里是将服务器的8040端口映射到容器的8080以及50000映射到容器的50000。</li>
<li>-v：挂载本地的数据卷到docker容器中，注意： 需要将JDK和maven的所在的目录挂载。</li>
</ul>
<blockquote>
<p>注意： 8040和50000一定要是开放的且未被占用，如果用的是云服务器，还需要在管理平台开放对应的规则。</p>
</blockquote>
<h2 id="Ubuntu上安装"><a href="#Ubuntu上安装" class="headerlink" title="Ubuntu上安装"></a>Ubuntu上安装</h2><p>macOS买不起相关设备，就再尝试下Ubuntu下的安装吧</p>
<p>由于包含在默认Ubuntu软件包中的Jenkins版本往往落后于项目本身的最新版本。 为了利用最新的修复和功能，我们将使用项目维护的软件包来安装Jenkins</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先安装jdk</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line">wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -</span><br><span class="line">sudo sh -c &#x27;echo deb https://pkg.jenkins.io/debian-stable binary/ &gt; \</span><br><span class="line">    /etc/apt/sources.list.d/jenkins.list&#x27;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install jenkins</span><br><span class="line"></span><br><span class="line">sudo systemctl start jenkins</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  设置开机自启动</span></span><br><span class="line">sudo systemctl enable jenkins</span><br></pre></td></tr></table></figure>

<p>确认端口</p>
<p>Jenkins 默认使用8080端口，如果你的8080端口被占用了，请修改配置文件/etc/sysconfig/jenkins，将JENKINS_PORT字段配置成你想要的端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JENKINS_PORT=&quot;8040&quot;</span><br></pre></td></tr></table></figure>

<p>修改用户</p>
<p>Jenkins 默认以 jenkins 用户运行，在实际运行过程中会导致一些权限问题，所以要改成以root 用户运行，修改 /etc/sysconfig/jenkins 中 JENKINS_USER 字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JENKINS_USER=&quot;root&quot;</span><br></pre></td></tr></table></figure>

<p>修改好配置后重启Jenkins:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart jenkins</span><br></pre></td></tr></table></figure>

<h1 id="构建部署"><a href="#构建部署" class="headerlink" title="构建部署"></a>构建部署</h1><p>我们以现在比较流行的SpringBoot项目来演示下从构建、打包到部署服务器，备份重启等一系列的工作的自动化。</p>
<p>安装完成后我们需要模拟实际的生产环境</p>
<p><a href="/20210706/jenkins/5b02ceab/">windows上使用jenkins构建并部署springboot项目</a></p>
<p>当然很多公司是不止一台服务器的，并且很多项目使用了SpringCloud等微服务的做法，将业务拆分为了很多子项目分别部署到不同的服务器中，这个时候就需要部署到远程Linux服务器中</p>
<p>个人建议，如果可以尽量给Jenkins一个相对独立的运行服务器，通过SSH的方式部署到不同的服务器中，没有必要每台服务器都安装Jenkins</p>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>Jenkins还可以完成其他有意思的事情，如构建流水线(有兴趣可以探究下)，另外Jenkins团队还有一个名为Jenkins X的子项目，专门和Kubernetes一起使用。Jenkins X是基于 Kubernetes 的CI&amp;CD平台，复用Jenkins自身的能力，以解决微服务架构下云原生应用的持续交付的问题，简化整个云原生应用的开发、运行和部署过程。</p>
<p>后面有时间继续探究下Kubernetes</p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot多环境配置</title>
    <url>/20210712/java/springboot/5ca3dffb/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日常项目中经常会针对不同环境进行不同配置，比如数据库配置，在开发的时候，我们一般用测试数据库，而在生产环境的时候，我们是用正式的数据。或者像日志的配置等等……<br>这时候，我们可以利用profile在不同的环境下配置不同的配置文件</p>
<p>而在SpringBoot中是允许约定按照一定的格式(application-{profile}.yml)来定义多个配置文件，然后通过在application.yml中通过指定spring.profiles.active来具体激活一个或者多个配置文件。</p>
<blockquote>
<p>如果没有没有指定任何profile的配置文件的话，spring boot默认会启动application-default.yml</p>
</blockquote>
 <a id="more"></a>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>现在大多流行4个环境配置，具体看项目的大小(较小的项目直接dev+prod):</p>
<ul>
<li>dev: 开发环境，一般是供开发人员日常编写代码自测使用</li>
<li>test(或者sit): 测试环境，用于给测试人员验证功能时使用</li>
<li>pre: 预发布环境，使用真实的数据进行上线前的功能流程验证用，基本上模拟了真实的生产环境</li>
<li>prod: 生产环境，实际的生产环境</li>
</ul>
<p>下面我就看下如何在maven下进行配置</p>
<h2 id="yml多环境配置"><a href="#yml多环境配置" class="headerlink" title="yml多环境配置"></a>yml多环境配置</h2><p>在resources中分别新建不同环境用的yml(如果项目使用的是properties则修改yml后缀并改写配置为properties格式即可)配置（演示方便只分别设置不同端口）</p>
<ul>
<li>application-dev.yml:</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application-test.yml:</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application-prod.yml:</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br></pre></td></tr></table></figure>

<h1 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h1><p>这时需要在pom.xml中加入多环境配置(如果是多模块的项目则在最外层的pom.xml中配置即可，无需每个模块都配置)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--默认打包环境--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再在原有application.yml加入(注意一定要配置pom.xml，不然会报类似@profileActive@找不到的错误):</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@profileActive@</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不想定义多个yml，也可以直接在application.yml中配置多个环境</p>
</blockquote>
<p>通过—可以把一个yml文档分割为多个，并可以通过 spring.profiles.active 属性指定使用哪个配置文件</p>
<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@profileActive@</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="comment">#spring:</span></span><br><span class="line"><span class="comment">#  profiles: dev</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="comment">#spring:</span></span><br><span class="line"><span class="comment">#  profiles: prod</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>springBoot 2.4开始废弃了原有的spring.profiles, 改为了spring.config.activate.on-profile，故如果项目的springBoot版本是2.4+的推荐用新的配置</p>
</blockquote>
<h1 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h1><p>这个使用就默认使用dev环境进行运行，如果要开发中切换环境修改pom.xml中的默认打包环境即可(如切换为test环境):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profiles.active</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profiles.active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认打包环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者使用idea的话，配置启动配置(推荐):</p>
<p><img src="idea-config.png" alt="idea-config"></p>
<p>不过一般我们也很少会在开发中更改环境，更多是打包时指定环境，这个时候就要使用mvn命令了:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true -Ptest   #测试环境</span><br><span class="line"></span><br><span class="line">mvn clean package -Dmaven.test.skip=true -Pprod #生产环境</span><br></pre></td></tr></table></figure>

<h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p>在某些情况下除了静态配置，某些业务如发送邮件仅生产环境中才实际执行，而开发环境里则不发送以免向用户发送无意义的垃圾邮件。</p>
<p>可以借助Spring的注解 <strong>@Profile</strong> 实现这样的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEmailService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">IEmailService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试方便，仅仅打印日志</span></span><br><span class="line">        logger.info(<span class="string">&quot;发送邮件: &#123;&#125;&quot;</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    IEmailService emailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(emailService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;当前环境：&#123;&#125; 不支持发送邮件&quot;</span>,env);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            emailService.send(<span class="string">&quot;这是一封测试邮件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切换环境，可以发现只有设置为prod环境时才会打印发送邮件的日志</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>网上还有一种配置的方式，就是不配置pom.xml，通过Java名称进行环境指定: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=test # 运行测试环境的配置</span><br><span class="line">java -jar xxx.jar --spring.profiles.active=prod # 运行生产环境的配置</span><br></pre></td></tr></table></figure>

<p>这种也是可以的</p>
<p>另外如果有些配置不方便放到源码管理中，可以指定加载外部配置的方式(当然如果使用了springCloud的话可以用springConfig或者nacosConfig):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.config.location=application-prod.yml</span><br></pre></td></tr></table></figure>


<p>如果jar(或者war)包会分发到客户机器中，由于jar可以直接当成zip解压，就会暴露不同环境的配置</p>
<p><img src="jar-%E6%9C%AA%E8%BF%87%E6%BB%A4%E7%89%88%E6%9C%AC.png" alt="jar-未过滤版本"></p>
<p>这个时候就得根据不同环境过滤打包后的文件了，在pom.xml中加入过滤相关配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-**.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profileActive&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次打包，可以发现</p>
<p><img src="jar-%E5%B7%B2%E8%BF%87%E6%BB%A4%E7%89%88%E6%9C%AC.png" alt="jar-已过滤版本"></p>
<p>最后同样附上<a href="https://github.com/jonesun/mybatis-sample">样例代码</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>windows上使用jenkins构建并部署springboot项目</title>
    <url>/20210706/jenkins/5b02ceab/</url>
    <content><![CDATA[<h1 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h1><p>在<a href="/20210706/jenkins/a15eda66/">安装并配置好Jenkins</a>后，我们来构建并部署springboot项目</p>
<p>创建任务首先准备一个SpringBoot项目上传到上面凭据所在的git托管网站中，以便Jenkins可以正常拉取源码</p>
<p>新建Item-选择【构建一个Maven项目】(如果这里没有这个选项，回到上篇安装插件Maven Integration并重启Jenkins)</p>
<p><img src="new-job.png" alt="new-job"></p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>选择该项目构建时的Java版本(如果这里没有所需的版本，回到上篇配置配置JDK、Maven、Git环境，新增即可)</p>
<h2 id="源码管理中"><a href="#源码管理中" class="headerlink" title="源码管理中"></a>源码管理中</h2><p>选择Git，填写仓库地址，选择之前添加的凭证</p>
<h2 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h2><p>这里先选择Build whenever a SNAPSHOT dependency is built</p>
<p>如果需要自动构建则勾选对应webhook，这里我们选择Gitee webhook(如果没有这个选项需要安装Gitee插件)，生成Gitee WebHook 密码</p>
<p><img src="gitee-webhook.png" alt="gitee-webhook"></p>
<p>使用浏览器打开码云对应的项目点开【管理】-【Webhook】,添加相关配置</p>
<p><img src="add-webhook.png" alt="add-webhook"></p>
<h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><p>勾选Add timestamps to the Console Output， 代码构建的过程中会将日志打印出来</p>
<h2 id="Pre-Steps"><a href="#Pre-Steps" class="headerlink" title="Pre Steps"></a>Pre Steps</h2><h3 id="部署本地"><a href="#部署本地" class="headerlink" title="部署本地"></a>部署本地</h3><p>点击add-pre-build-step,选择【Execute Windows batch command】</p>
<p><img src="add-pre-build-step.png" alt="add-pre-build-step"></p>
<p>添加批处理所在路径xxx/stop.bat(先将批处理放置到对应目录中)</p>
<p><img src="execute-windows-batch-command.png" alt="execute-windows-batch-command"></p>
<h3 id="部署远程Windows-Server"><a href="#部署远程Windows-Server" class="headerlink" title="部署远程Windows Server"></a>部署远程Windows Server</h3><p>点击add-pre-build-step,选择【Send files or execute commands over SSH】</p>
<p>选择之前配置的SSH Server的远程windows服务器，在Exec command中添加批处理所在路径xxx/stop.bat</p>
<blockquote>
<p>使用SSH Publishers时一定要勾选【高级】-【Verbose output in console】, 输出日志便于出错时查看具体原因</p>
</blockquote>
<p>这个批处理是在构建项目前执行的，一般是停止服务备份jar等，以下是笔者的stop.bat(供参考):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo stop</span><br><span class="line">set str_time_first_bit=&quot;%time:~0,1%&quot;</span><br><span class="line">if %str_time_first_bit%==&quot; &quot; (    </span><br><span class="line">set str_date_time=%date:~0,4%%date:~5,2%%date:~8,2%0%time:~1,1%%time:~3,2%%time:~6,2%</span><br><span class="line">)else (     </span><br><span class="line">set str_date_time=%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2%</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">set port=8081</span><br><span class="line">for /f &quot;tokens=1-5&quot; %%i in (&#x27;netstat -ano^|findstr &quot;:%port%&quot;&#x27;) do (</span><br><span class="line">    echo kill the process %%m who use the port </span><br><span class="line">    taskkill /pid %%m -t -f</span><br><span class="line">    goto start</span><br><span class="line">)</span><br><span class="line">:start</span><br><span class="line"></span><br><span class="line">cd /d %~dp0</span><br><span class="line"></span><br><span class="line">if not exist backup md backup</span><br><span class="line"></span><br><span class="line">copy mybatis-sample-0.0.1-SNAPSHOT.jar backup\mybatis-sample-0.0.1-SNAPSHOT-%str_date_time%.jar.jar</span><br><span class="line"> </span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>port=8081是因为我的这个项目的运行端口是8081</p>
<h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>在Build中，填写 Root POM 和 Goals and options，也就是构建项目的命令</p>
<p><img src="build.png" alt="build"></p>
<p>一般SpringBoot项目的命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>

<h2 id="Post-Steps"><a href="#Post-Steps" class="headerlink" title="Post Steps"></a>Post Steps</h2><p>构建后可以做的事情，这里我们选择【Run only if build succeeds】，即构建成功后触发</p>
<h3 id="部署本地-1"><a href="#部署本地-1" class="headerlink" title="部署本地"></a>部署本地</h3><p>点击add-post-build-step,选择【Execute Windows batch command】,添加批处理所在路径</p>
<p>这个批处理一般是启动项目，以下是笔者的start.bat(供参考):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set BUILD_ID=dontKillMe  </span><br><span class="line">echo start</span><br><span class="line"></span><br><span class="line">cd /d %~dp0</span><br><span class="line">START javaw -jar mybatis-sample-0.0.1-SNAPSHOT.jar &amp; exit</span><br></pre></td></tr></table></figure>

<h3 id="部署远程Windows-Server-1"><a href="#部署远程Windows-Server-1" class="headerlink" title="部署远程Windows Server"></a>部署远程Windows Server</h3><p>点击add-post-build-step,选择【Send files or execute commands over SSH】</p>
<p>选择之前配置的SSH Server的远程windows服务器，在Exec command中添加批处理所在路径xxx/start.bat</p>
<blockquote>
<p>Transfer set</p>
</blockquote>
<ul>
<li>name:前面添加的SSH Server</li>
<li>Source files:要推送的文件</li>
<li>Remove prefix:文件路径中要去掉的前缀</li>
<li>Remote directory:要推送到目标服务器上的哪个目录下</li>
<li>Exec command:目标服务器上要执行的脚本</li>
</ul>
<h3 id="部署远程Linux"><a href="#部署远程Linux" class="headerlink" title="部署远程Linux"></a>部署远程Linux</h3><p>点击add-post-build-step,选择【Send files or execute commands over SSH】,选择之前配置的SSH Server的远程Linux服务器</p>
<p><img src="ssh-ser-ubuntu.png" alt="ssh-ser-ubuntu"></p>
<p>startup.sh(先将sh放置到对应目录中)与windows版的start.bat不太一样(供参考)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">export</span> BUILD_ID=dontKillMe这一句很重要，这样指定了，项目启动之后才不会被Jenkins杀掉。</span></span><br><span class="line">export BUILD_ID=dontKillMe</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -ile</span></span><br><span class="line">project=mybatis-sample-0.0.1-SNAPSHOT.jar</span><br><span class="line">pathName=mybatis-sample-0.0.1-SNAPSHOT</span><br><span class="line">cd /root/home/mybatis-sample/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ ! -d &quot;backup&quot; ];then</span><br><span class="line">    mkdir backup</span><br><span class="line">else</span><br><span class="line">    echo &quot;backup is exist&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">rm -rf backup/$project</span><br><span class="line">cp  $project backup/$project</span><br><span class="line"></span><br><span class="line">pid=`ps -ef | grep $dir$project | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ -n &quot;$pid&quot; ]</span><br><span class="line">then</span><br><span class="line">   kill -9 $pid</span><br><span class="line">   echo &quot;kill&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;run&quot;</span><br><span class="line">BUILD_ID=dontkillMe nohup java -jar $project &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo &quot;run success&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果远程执行遇到权限问题，执行chmod +x startup.sh</p>
</blockquote>
<h2 id="构建设置"><a href="#构建设置" class="headerlink" title="构建设置"></a>构建设置</h2><p>可以配置邮件通知等</p>
<h2 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h2><p>可以添加很多操作</p>
<p><img src="build-after.png" alt="build-after"></p>
<h1 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h1><p>点击 立即构建 可以开始构建任务，控制台可以看到log输出，如果构建失败，在log中会输出原因</p>
<p><img src="start-build.png" alt="start-build"></p>
<p>构建成功后就可以浏览器中打开项目测试，至此便完成jenkins构建并部署springboot项目的流程<del>~</del></p>
<p>如果配置的自动构建的地址，则使用idea编写好代码提交到git后，Jenkins便会自动构建项目</p>
<p><img src="auto-build.png" alt="auto-build"></p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>windows上安装jenkins</title>
    <url>/20210706/jenkins/a15eda66/</url>
    <content><![CDATA[<h1 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h1><h2 id="下载配置jdk"><a href="#下载配置jdk" class="headerlink" title="下载配置jdk"></a>下载配置jdk</h2><p>从Jenkins的官网可以看到</p>
<p><img src="jenkins-jdk.png" alt="jenkins-jdk"></p>
<p>较新的Jenkins需要运行在Java 8 或者 Java 11上，我们安装java8版本，由于Oracle下载jdk需要注册账户，我们下载openjdk，这里推荐 <a href="https://bell-sw.com/pages/downloads/">Liberica OpenJDK</a></p>
<p>直接下载zip版本，并在环境变量中配置JAVA_HOME，使用cmd执行java -version查看是否配置成功</p>
<blockquote>
<p>如果电脑里已经安装了Java环境，直接用java -version验证是否Java8+版本</p>
</blockquote>
<h2 id="下载安装Git"><a href="#下载安装Git" class="headerlink" title="下载安装Git"></a>下载安装Git</h2><p>我们需要使用Jenkins拉取项目源码，故需要先安装下git</p>
<p>从<a href="http://git-scm.com/downloads">git</a> 官网下载安装即可</p>
<p>命令行输入git –version验证安装是否成功</p>
<h2 id="下载配置Maven"><a href="#下载配置Maven" class="headerlink" title="下载配置Maven"></a>下载配置Maven</h2><p>目前大多数SpringBoot项目都采用的是Maven的方式进行构建，故为了进行自动构建，需要安装</p>
<p>可以<a href="http://maven.apache.org/download.cgi">官网</a> 直接下载zip，配置环境变量M2_HOME即可</p>
<p><img src="maven_home.png" alt="maven_home"></p>
<p>命令行输入mvn -v验证</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>windows版直接<a href="https://www.jenkins.io/download/">官网</a> 下载最新版本即可，如果是实际生产环境建议下载LTS(长期支持版本)</p>
<p>按照提示直接安装即可</p>
<p><img src="step1.png" alt="step1"></p>
<p><img src="step2.png" alt="step2"></p>
<p><img src="step3.png" alt="这里直接选择本地用户即可"></p>
<p><img src="step4.png" alt="Jenkins默认端口为8080，可能会与其他软件冲突，可以修改为其他端口，点击【Test-Port】通过即可"></p>
<p><img src="step5.png" alt="Java运行环境这里默认会显示JAVA_HOME所在的目录"></p>
<p><img src="step6.png" alt="step6"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果前面安装的时候没有修改默认端口为，可以打开配置(Windows版的配置在安装目录的jenkins.xml中)进行配置, 修改–httpPort=8080为其他端口</p>
<p>如果使用nginx代理的话需要加上 –prefix=/jenkins</p>
<p>以下是笔者的配置，供参考(省略了其他配置，不要直接复制，重点在arguments中的修改)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jenkins<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Jenkins<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>This service runs Jenkins automation server.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">&quot;JENKINS_HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%LocalAppData%\Jenkins\.jenkins&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executable</span>&gt;</span>D:\env\Java\jdk1.8.0_231\bin\java.exe<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arguments</span>&gt;</span>-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar &quot;C:\Program Files\Jenkins\jenkins.war&quot; --prefix=/jenkins --httpPort=8080 --webroot=&quot;%LocalAppData%\Jenkins\war&quot;<span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是Windows版的Jenkins的默认工作目录在C:\Windows\System32\config\systemprofile\AppData\Local\Jenkins.jenkins，如果需要修改，同样在jenkins.xml中搜索修改JENKINS_HOME即可(可修改为env name=”JENKINS_HOME” value=”%JENKINS_HOME%”，然后环境变量加入JENKINS_HOME)</p>
<p>以上工作完成后，就可以运行jenkins了，需要注意的是Windows的安装版的Jenkins安装时会注册为Windows服务，需要从任务管理器-服务中找到Jenkins重启</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>浏览器打开<a href="http://localhost:8080/(%E5%A6%82%E6%9E%9C%E9%85%8D%E7%BD%AE%E4%BA%86prefix%EF%BC%8C%E5%88%99%E4%B8%BAhttp://localhost:8080/jenkins/)">http://localhost:8080/(如果配置了prefix，则为http://localhost:8080/jenkins/)</a></p>
<p><img src="init1.png" alt="init1"></p>
<p><img src="init2.png" alt="init2"></p>
<p><img src="init3.png" alt="init3"></p>
<p><img src="init4.png" alt="init4"></p>
<p><img src="init5.png" alt="init5"></p>
<p><img src="init6.png" alt="init6"></p>
<p><img src="init7.png" alt="init7"></p>
<p>按照步骤一步步配置即可，需要注意的插件安装推荐的插件如果有安装失败的，一般是网络原因，重试几次即可(如果还不行，可以后面到插件管理里再安装)</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>除了初始化配置中安装的插件外，还需要安装：</p>
<ul>
<li>Maven Integration：便于新建maven任务</li>
<li>Publish Over SSH: 用于远程连接服务器</li>
<li><a href="https://gitee.com/help/articles/4193">Gitee</a>: 如果是使用码云作为托管网站的推荐安装</li>
</ul>
<p>打开系统管理(Manage Jenkins) -&gt; 插件管理(Manage Plugins)，选择可选插件，勾选中 Maven Integration 和 Publish Over SSH，点击直接安装</p>
<p><img src="install-plugin.png" alt="install-plugin"></p>
<p>在安装界面勾选上安装完成后重启 Jenkins</p>
<p><img src="install-plugin-2.png" alt="install-plugin2"></p>
<h2 id="配置JDK、Maven、Git环境"><a href="#配置JDK、Maven、Git环境" class="headerlink" title="配置JDK、Maven、Git环境"></a>配置JDK、Maven、Git环境</h2><p>Jenkins集成需要用到Maven、JDK、Git环境， 打开系统管理(Manage Jenkins) -&gt; 全局工具配置(Global Tool Configuration)</p>
<p><img src="config.png" alt="config"></p>
<p><strong>新增JDK时，需要去掉自动安装(Install automatically)勾选，才能配置本地Java环境，这里可以配置多个jdk，主要是为了构建项目时使用，与Jenkins运行时的jdk不是一个概念</strong></p>
<h2 id="添加凭据"><a href="#添加凭据" class="headerlink" title="添加凭据"></a>添加凭据</h2><p>添加凭据用来从 Git 仓库拉取代码的，打开 凭据 -&gt; 系统 -&gt; 全局凭据 -&gt; 添加凭据, 直接使用用户名和密码，设置Github或者码云等git托管网站的账户信息</p>
<p><img src="new-credentials.png" alt="new-credentials"></p>
<h2 id="添加-SSH-Server"><a href="#添加-SSH-Server" class="headerlink" title="添加 SSH Server"></a>添加 SSH Server</h2><p>SSH Server 是用来连接部署服务器的，用于在项目构建完成后将你的应用推送到服务器中并执行相应的脚本。</p>
<p>打开 (Manage Jenkins) -&gt; 系统配置，找到 Publish Over SSH 部分，选择新增</p>
<p><img src="ssh-server.png" alt="ssh-server"></p>
<p>这里需要远程服务器支持ssh连接</p>
<h3 id="远程Windows-Server配置SSH"><a href="#远程Windows-Server配置SSH" class="headerlink" title="远程Windows Server配置SSH"></a>远程Windows Server配置SSH</h3><p>如果服务器是Windows的，可以下载并安装<a href="http://www.freesshd.com/?ctt=download">freeSSHD</a>，安装流程可以参考这篇文章 <a href="https://blog.csdn.net/yangdan1025/article/details/81985903">本机（Windows）通过SSH软件工具freeSSHD、puTTY远程连接虚拟机（Windows）</a></p>
<blockquote>
<p>这里推荐freeSSHD是因为远程执行bat比较稳定，之前使用openSSH时总会有些莫名的问题，可能时我配置的有问题，就不继续探究的。</p>
</blockquote>
<p>配置好后，点击【Test Configuration】出现 “Success”即可保存，如果出现的是异常日志，首先检查远程服务器是否支持ssh连接，再检查配置是否正确尤其用户名密码和端口号</p>
<blockquote>
<p>ssh客户端如果使用的是windows10推荐直接使用powershell</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.197.129 -p 22</span><br></pre></td></tr></table></figure>

<h3 id="远程Linux配置SSH"><a href="#远程Linux配置SSH" class="headerlink" title="远程Linux配置SSH"></a>远程Linux配置SSH</h3><p>一般云服务都支持SSH连接，可以用SSH的客户端连接测试(注意可能有些云服务器的安全组未开放端口，配置下即可)。当然如果确实没有安装ssh server，可以打开Terminal：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新软件下载源</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装ssh服务</span></span><br><span class="line">sudo apt install openssh-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启防火墙ssh的服务端口</span></span><br><span class="line">sudo ufw allow ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启ssh服务</span></span><br><span class="line">systemctl start ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开启自启</span></span><br><span class="line">sudo systemctl enable ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ssh服务状态</span></span><br><span class="line">systemctl status ssh</span><br></pre></td></tr></table></figure>

<p>修改sshd_config，主要是放开”PasswordAuthentication yes”和“PermitRootLogin yes”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">    <span class="variable">$OpenBSD</span>: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the sshd server system-wide configuration file.  See</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sshd_config(5) <span class="keyword">for</span> more information.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The strategy used <span class="keyword">for</span> options <span class="keyword">in</span> the default sshd_config shipped with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OpenSSH is to specify options with their default value <span class="built_in">where</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> possible, but leave them commented.  Uncommented options override the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> default value.</span></span><br><span class="line"></span><br><span class="line">Include /etc/ssh/sshd_config.d/*.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Port 22</span></span><br><span class="line"><span class="meta">#</span><span class="bash">AddressFamily any</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ListenAddress 0.0.0.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ListenAddress ::</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">HostKey /etc/ssh/ssh_host_rsa_key</span></span><br><span class="line"><span class="meta">#</span><span class="bash">HostKey /etc/ssh/ssh_host_ecdsa_key</span></span><br><span class="line"><span class="meta">#</span><span class="bash">HostKey /etc/ssh/ssh_host_ed25519_key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ciphers and keying</span></span><br><span class="line"><span class="meta">#</span><span class="bash">RekeyLimit default none</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Logging</span></span><br><span class="line"><span class="meta">#</span><span class="bash">SyslogFacility AUTH</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LogLevel INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line"></span><br><span class="line">LoginGraceTime 2m</span><br><span class="line">PermitRootLogin yes </span><br><span class="line">StrictModes yes</span><br><span class="line"><span class="meta">#</span><span class="bash">MaxAuthTries 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MaxSessions 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">PubkeyAuthentication yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Expect .ssh/authorized_keys2 to be disregarded by default <span class="keyword">in</span> future.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">AuthorizedKeysFile    .ssh/authorized_keys .ssh/authorized_keys2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">AuthorizedPrincipalsFile none</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">AuthorizedKeysCommand none</span></span><br><span class="line"><span class="meta">#</span><span class="bash">AuthorizedKeysCommandUser nobody</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> For this to work you will also need host keys <span class="keyword">in</span> /etc/ssh/ssh_known_hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash">HostbasedAuthentication no</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Change to yes <span class="keyword">if</span> you don<span class="string">&#x27;t trust ~/.ssh/known_hosts for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HostbasedAuthentication</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IgnoreUserKnownHosts no</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Don<span class="string">&#x27;t read the user&#x27;</span>s ~/.rhosts and ~/.shosts files</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IgnoreRhosts yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">disable</span> tunneled clear text passwords, change to no here!</span></span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"><span class="meta">#</span><span class="bash">PermitEmptyPasswords no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Change to yes to <span class="built_in">enable</span> challenge-response passwords (beware issues with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> some PAM modules and threads)</span></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Kerberos options</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosAuthentication no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosOrLocalPasswd yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosTicketCleanup yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosGetAFSToken no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GSSAPI options</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIAuthentication no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPICleanupCredentials yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIStrictAcceptorCheck yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIKeyExchange no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set this to <span class="string">&#x27;yes&#x27;</span> to <span class="built_in">enable</span> PAM authentication, account processing,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and session processing. If this is enabled, PAM authentication will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be allowed through the ChallengeResponseAuthentication and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PasswordAuthentication.  Depending on your PAM configuration,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PAM authentication via ChallengeResponseAuthentication may bypass</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the setting of <span class="string">&quot;PermitRootLogin without-password&quot;</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you just want the PAM account and session checks to run without</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PAM authentication, <span class="keyword">then</span> <span class="built_in">enable</span> this but <span class="built_in">set</span> PasswordAuthentication</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and ChallengeResponseAuthentication to <span class="string">&#x27;no&#x27;</span>.</span></span><br><span class="line">UsePAM yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">AllowAgentForwarding yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">AllowTcpForwarding yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GatewayPorts no</span></span><br><span class="line">X11Forwarding yes</span><br><span class="line"><span class="meta">#</span><span class="bash">X11DisplayOffset 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash">X11UseLocalhost yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PermitTTY yes</span></span><br><span class="line">PrintMotd no</span><br><span class="line"><span class="meta">#</span><span class="bash">PrintLastLog yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">TCPKeepAlive yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PermitUserEnvironment no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Compression delayed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ClientAliveInterval 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ClientAliveCountMax 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">UseDNS no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PidFile /var/run/sshd.pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MaxStartups 10:30:100</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PermitTunnel no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ChrootDirectory none</span></span><br><span class="line"><span class="meta">#</span><span class="bash">VersionAddendum none</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> no default banner path</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Banner none</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Allow client to pass locale environment variables</span></span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> override default of no subsystems</span></span><br><span class="line">Subsystem    sftp    /usr/lib/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example of overriding settings on a per-user basis</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Match User anoncvs</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    X11Forwarding no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    AllowTcpForwarding no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    PermitTTY no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ForceCommand cvs server</span></span><br></pre></td></tr></table></figure>

<h1 id="配置Nginx代理"><a href="#配置Nginx代理" class="headerlink" title="配置Nginx代理"></a>配置Nginx代理</h1><p><strong>如果需要配置了Nginx代理，必须设置Jenkins的配置中加入–prefix=/jenkins</strong></p>
<p>nginx中server加入配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;jenkins&#x2F; &#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;jenkins&#x2F;;</span><br><span class="line">  proxy_set_header X-Forwarded-Host $host:$server_port;</span><br><span class="line">  proxy_set_header X-Forwarded-Server $host;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置Jenkins Location中的Jenkins URL地址为<a href="http://xxx/jenkins/">http://xxx/jenkins/</a>, 如果有公网地址添加公网地址(没有可以用类似花生壳的内网穿透软件代理下)</p>
<p>这里最好有公网地址，不然无法做到自动构建(自动构建需要结合webhook功能)。</p>
<h1 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h1><p>使用官方默认地址安装插件的速度比较慢，可以配置国内的镜像地址</p>
<p>Dashboard -&gt; Manage jenkins -&gt; 点击右下角的中文社区jenkins中文社区(如果没有则先安装首先安装 Localization: Chinese (Simplified)插件)</p>
<p>点击【使用】按钮，再点击【设置更新中心地址】，在最底部填入镜像的代理地址 <a href="https://updates.jenkins-zh.cn/update-center.json">https://updates.jenkins-zh.cn/update-center.json</a></p>
<p><img src="update-url.png" alt="update-url"></p>
<p>下面我们看下如何在<a href="/20210706/jenkins/5b02ceab/">Windows上使用Jenkins构建并部署SpringBoot项目</a></p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>思维改变生活</title>
    <url>/20210224/uncategorized/9fdd9683/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天翻查以前的笔记，偶然看到了记录的关于积极心理相关的摘录，防止以后丢了，写到文章中了，与有缘人共同分享，希望看到了同学都能拥有积极的心态，让思维改变生活。</p>
 <a id="more"></a>

<h1 id="一、认知行为治疗-CBT"><a href="#一、认知行为治疗-CBT" class="headerlink" title="一、认知行为治疗-CBT"></a>一、认知行为治疗-CBT</h1><p>这个网上查了下，是由A.T.Beck在60年代发展出的心理治疗方法，主要针对抑郁症、焦虑症等心理疾病和不合理认知导致的心理问题。它的主要着眼点，放在患者不合理的认知问题上，通过改变患者对已，对人或对事的看法与态度来改变心理问题。</p>
<p>例如，一个人一直“认为”自己表现得不够好，连自己的父母也不喜欢他，因此，做什么事都没有信心，很自卑，心情也很不好。<br>治疗的策略，便在于帮助他重新构建认知结构，重新评价自己，重建对自己的信心，更改认为自己“不好”的认知。</p>
<ul>
<li>认知行为治疗是基于: 认知-我们的思想和观念-在很大程度上决定了我们的情感。很多痛苦的情绪(像愤怒、焦虑、抑郁、自责和自卑)是由自我挫败的，不切实际的认知造成的。</li>
<li>CBT所关注的焦点：是形成实事求是的认知，从而尽量减少我们的不安情绪。我们可直接这样做-通过质疑那些使我们感到难受的想法和观念；也可以间接这样做-通过改变某些影响和强化消极认知的行为。</li>
<li>CBT的目标：不是消除所有的痛苦情绪，而是帮助我们对可能引起痛苦的情况作出恰当的反应。</li>
<li>CBT与“积极思考”不同-我们的目标是形成实事求是的思维，而不是形成满怀渴望的想法。</li>
</ul>
<h1 id="二、识别错误想法"><a href="#二、识别错误想法" class="headerlink" title="二、识别错误想法"></a>二、识别错误想法</h1><ul>
<li>愤怒、内疚、焦虑、抑郁和挫折感等不安情绪常常是由消极的、不合理的观念造成并延续的。这些观念是我们内心僵化的原则或期待。</li>
<li>消极观念可以使我们产生糟糕的情绪，以及自我挫败的行为。</li>
<li>大多数人都有一些导致不必要困扰的思维模式，常常称为不良思维模式，包括：恐怖化、非黑即白的思维、以偏概全、自找罪受、滤除信息、草率得出负面结论、责备和感到大祸临头。</li>
<li>为了形成健康一些的思维方式，我们需要辨认自己那些导致不安情绪的观念和思维模式，这样做的最好办法就是我们感到不安时检测我们的认知活动。</li>
</ul>
<h1 id="三、辩驳消极认知"><a href="#三、辩驳消极认知" class="headerlink" title="三、辩驳消极认知"></a>三、辩驳消极认知</h1><ul>
<li>要驳斥无益的认知，逻辑辩驳是最常用的技术。这就是辨认我们思维中的消极方面，盘查那些认知，得出更实际、更有益的方法来理解我们的处境。</li>
<li>写出我们的消极认知以及辩驳性的陈述，通常有助于整理并澄清我们的认知。思维检测表是有用的辅助工具。</li>
<li>可以采用苏格拉底式发问来进行逻辑辩驳，也就是通过提问来帮助我们明白自己的某些认知缺乏逻辑。我们也可以不再把事情想成一场灾难-采用提问和陈述来提醒我们后果其实没那么严重。</li>
<li>逻辑辩驳的另一种方法是检查证据。这就是通过向自己提问4个关键问题，来评估支持或者反对我们想法的证据。</li>
<li>另一种不同的驳斥技术叫行为驳斥。也就是采取某些行动来驳斥我们某些无益的认知。</li>
<li>最后，用目标引导思维可以激励我们改变认知。这就要我们注意思维中的自我挫败性质，明白当前的认知并不会让我们心情好起来，也不会让我们得到想要的东西。</li>
</ul>
<h1 id="四、-征服挫折"><a href="#四、-征服挫折" class="headerlink" title="四、 征服挫折"></a>四、 征服挫折</h1><ul>
<li>挫败感是我们得不到想要的东西之后体验到的情绪。</li>
<li>挫折耐受力低下(LFT)是因为我们总希望自己的生活轻松舒适。这种期待使我们在需要得不到满足的情况下变得过于烦躁。</li>
<li>LFT还会导致惰性以及自我挫败的行为。例如我们会选择满足自己即可的需要，而非追寻长期的最佳的益处。</li>
<li>在我们感到受挫的情况下，首先需要考虑怎样解决问题。</li>
<li>为了提高我们耐受挫折的能力，我们需要挑战那些导致LFT的观念。我们可以用逻辑或者行动来驳斥那些观念。</li>
</ul>
<h1 id="五、控制愤怒"><a href="#五、控制愤怒" class="headerlink" title="五、控制愤怒"></a>五、控制愤怒</h1><ul>
<li>当我们觉得某件事情很糟糕或者不公平时，我们就可能感到愤怒。有时候，愤怒可以激励我们采取果敢的行动或者解决问题，但是愤怒也有很多负面的后果。频繁的或者长期的发怒可能损害我们的人际关系，还可能影响我们的健康，并且让我们活得不开心。</li>
<li>与对待其他的情绪不同，人们往往想要保持愤怒，因为他们认为自己的愤怒是正当的。然而，愤怒伤害得更多得是我们自己而非别人。要释放怒气，首先就要认识到保持愤怒的代价，并决心消除怒气。</li>
<li>为了释放怒气，我们可以采用一些认知策略，包括思维监测和辩驳，用目标引导思维，驳斥我们认为事情应该怎么样的观念，运用换位思考和幽默，以及放弃责备。明白有时候不公正是不可避免的，明白有时候”公平”是主观性的，也可以帮助我们释放怒气。</li>
<li>控制愤怒还可以用到一些行为策略，包括深度放松技术、解决问题的技巧和有效的沟通。</li>
</ul>
<h1 id="六、对付焦虑"><a href="#六、对付焦虑" class="headerlink" title="六、对付焦虑"></a>六、对付焦虑</h1><ul>
<li>焦虑是一种情绪，是当事人感到将要出事时的担忧。它通常伴随着生理唤起和肌肉紧张，这是对威胁的原始反应-搏斗或逃跑反应的症状。</li>
<li>每个人都会偶尔体验到状态性焦虑。性格中容易焦虑的人却经常体验到持续的焦虑。还有的人患有焦虑障碍，这会对他们的社会功能和情感状态产生严重影响。</li>
<li>焦虑常常由于某些认知方面的习惯而引起并维持，这些习惯包括灾难化的想法，对赞赏的过度追求、对控制的过度追求以及关注潜在威胁的倾向。焦虑还常常因为我们逃避自己害怕的情境而持续不断。</li>
<li>可以用来控制焦虑的认知策略包括思维监测和辩驳，不再把遇到的事情当成灾难、权衡依据、风险评估和应对性陈述。</li>
<li>可以用来控制焦虑的行为策略包括置身于我们害怕的情境(真正这么做，或者先进行想象)，解决问题、分散注意力和深度放松技术。</li>
</ul>
<h1 id="七、维护自尊"><a href="#七、维护自尊" class="headerlink" title="七、维护自尊"></a>七、维护自尊</h1><ul>
<li>自尊是我们感知自身价值的一种方式。这种感知显著影响到我们生活的很多方面，包括我们的幸福感。</li>
<li>影响自尊的因素包括我们内在的个性特征、我们的生活经历(特别是童年经历)、我们从别人那里接收到的信息以及大众传播媒介所推崇的价值标准。</li>
<li>贬低自尊的常见的错误思维模式包括: 把自己跟别人比较，以成就论价值，过度追求别人的赞赏，以偏概全以及给自己贴标签。</li>
<li>健康的自尊可以通过自我接纳来保持。自我接纳意味着接纳自己所觉察到的缺陷，不再把自己标记为”有缺陷”或者”不好的”。另外灵活应变，不要求每个人都喜欢我们，用具体化而非整体化的言辞来思考，也都有助于我们保持良好的自我评价。</li>
</ul>
<h1 id="八、恢复快乐"><a href="#八、恢复快乐" class="headerlink" title="八、恢复快乐"></a>八、恢复快乐</h1><ul>
<li>抑郁症的诱因往往是生活当中的困境，但是认知用来对付困境的资源以及生物学方面的因素对抑郁症的发病和病程也有作用。</li>
<li>抑郁症使我们的认知变得更加消极，反过来又使得抑郁状态加重并且持续不断。它还可能导致续发性抑郁，也就是我们因为自己的抑郁症而变得更加抑郁。</li>
<li>要想驳斥抑郁症所伴随的消极认知，我们仍然要保持活跃。给我们带来愉快感或者成就感的任何活动，都能够减轻沮丧、提升情绪。社交活动和体育运动也特别有帮助。</li>
<li>抑郁症较难通过自己的努力来治愈，往往有必要去看合格的精神卫生执业者。对于某些患者，抗抑郁药联合运用CBT可以起到最好的治疗效果。</li>
</ul>
]]></content>
      <tags>
        <tag>积极心理</tag>
      </tags>
  </entry>
  <entry>
    <title>帮手-Helper</title>
    <url>/20161108/app/c43615b/</url>
    <content><![CDATA[<h2 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h2><p>实用工具-帮手，包含当前城市天气、日历、便签、物流查询、手机管理及手电筒、3d相册等功能。简单发布，欢迎试用，后续继续更新.</p>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>从github上下载<a href="https://github.com/jonesun/Helper/blob/master/apk/helper.apk?raw=true">v3.1.1 helper.apk</a></p>
<p>从<a href="http://shouji.baidu.com/software/9060658.html">百度手机助手</a>上下载</p>
 <a id="more"></a>

<p><a href="https://github.com/jonesun/Helper">源码</a></p>
<h2 id="Compile-environment"><a href="#Compile-environment" class="headerlink" title="Compile environment"></a>Compile environment</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compileSdkVersion&#x3D;23</span><br><span class="line">buildToolsVersion&#x3D;24.0.0 rc1</span><br><span class="line"></span><br><span class="line">minSdkVersion&#x3D;14</span><br><span class="line">targetSdkVersion&#x3D;23</span><br></pre></td></tr></table></figure>


<h2 id="App-preview"><a href="#App-preview" class="headerlink" title="App preview"></a>App preview</h2><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/0.png" alt="pic_0"></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/1.png" alt="pic_1"></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/2.png" alt="pic_2"></h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/3.png" alt="pic_3"></h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/4.png" alt="pic_4"></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/5.png" alt="pic_5"></h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/jonesun/Helper/master/screenshots/6.png" alt="pic_6"></h1><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul>
<li><p><strong>3.1.1 2016.03.18</strong></p>
<ul>
<li>首页局部调整</li>
<li>网络图片列表优化显示</li>
<li>便签列表优化显示</li>
<li>修复bug</li>
</ul>
</li>
<li><p><strong>3.1.0 2016.02.16</strong></p>
<ul>
<li>首页调整加入未来三天天气预报</li>
<li>新增历史上的今天</li>
<li>更多设备信息展示</li>
<li>修复bug</li>
</ul>
</li>
<li><p><strong>3.0.9 2016.02.01</strong></p>
<ul>
<li>图片列表优化显示</li>
<li>新增保存图片到本地</li>
<li>新增设置图片为壁纸</li>
<li>修复bug</li>
</ul>
</li>
<li><p><strong>3.0.8 2016.01.27</strong></p>
<ul>
<li>新增夜间模式</li>
<li>新增主题皮肤可选择</li>
<li>新增图片列表</li>
</ul>
</li>
<li><p><strong>3.0.7 2015.11.16</strong></p>
</li>
<li><p><strong>3.0.6 2015.10.30</strong></p>
</li>
<li><p><strong>3.0.5 2015.09.18</strong></p>
</li>
<li><p><strong>3.0.4 2015.08.29</strong></p>
</li>
<li><p><strong>3.0.3 2015.08.18</strong></p>
</li>
<li><p><strong>3.0.2 2015.04.10</strong></p>
</li>
<li><p><strong>3.0.1 2015.03.12</strong></p>
</li>
<li><p><strong>2.0 2014.09.24</strong></p>
</li>
<li><p><strong>1.0 2014.09.18</strong></p>
</li>
</ul>
<h4 id="Contacts"><a href="#Contacts" class="headerlink" title="Contacts"></a>Contacts</h4><ul>
<li>Github: <a href="https://github.com/jonesun">https://github.com/jonesun</a></li>
<li>Email: <a href="mailto:sunr922@163.com">sunr922@163.com</a></li>
</ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><pre><code>Copyright (C) 2016 Jone Sun

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</code></pre>
]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>app</tag>
        <tag>helper</tag>
      </tags>
  </entry>
  <entry>
    <title>杂言</title>
    <url>/20171109/uncategorized/338ef0f4/</url>
    <content><![CDATA[<h4 id="世界上只有一种英雄主义-就是看清生活的真相之后依然热爱生活。"><a href="#世界上只有一种英雄主义-就是看清生活的真相之后依然热爱生活。" class="headerlink" title="世界上只有一种英雄主义,就是看清生活的真相之后依然热爱生活。####"></a>世界上只有一种英雄主义,就是看清生活的真相之后依然热爱生活。####</h4><h4 id="心随精英，口随大众。生活不仅仅只有电脑、手机和电视。。。"><a href="#心随精英，口随大众。生活不仅仅只有电脑、手机和电视。。。" class="headerlink" title="心随精英，口随大众。生活不仅仅只有电脑、手机和电视。。。####"></a>心随精英，口随大众。生活不仅仅只有电脑、手机和电视。。。####</h4><p>第一次为idea 提出<a href="https://youtrack.jetbrains.com/issue/IDEA-246570">issus</a>，并很快得到解决，赞！</p>
<p>广播里听到的，还挺有意思</p>
<blockquote>
<p>敬酒不吃，那就只有罚酒伺候了</p>
</blockquote>
<p><strong>在这个信息爆炸的世界，永远不缺少新奇而又短命的事物。大部分所谓的新技术都只是昙花一现：出现了，被看到了；大部分人“哦”了一声，已阅但表示不感兴趣；小部分人惊叹于它的奇思妙想，激动地点了个赞后，回过头来该用什么还是什么。真正决定新技术是否能转化为新生产力的，永远不是技术本身有多么优秀和华丽，而是它是否真的被需要</strong></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]黑客伦理HackerEthic</title>
    <url>/20210428/uncategorized/24677810/</url>
    <content><![CDATA[<p><strong>以下内容抄录自硅谷创业之父Paul Graham编写并由阮一峰大佬翻译的经典巨著《黑客与画家》</strong>，很有意思备份下来便于以后查阅</p>
<p>1984年，《新闻周刊》的作者史蒂文·利维出版的《Hackers: Heroes of the Computer Revolution》(黑客: 计算机革命的英雄)是历史上第一本介绍黑客的著作。<br>在该书中，他总结了六条“黑客伦理”作为黑客的价值观参考：</p>
<ol>
<li>使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。<blockquote>
<p>Access to computers-and anything that might teach you something about the way the world works-should be unlimited and total. Always yield to the Hands-On Imperative!</p>
</blockquote>
</li>
<li>信息应该全部免费。<blockquote>
<p>All information should be free.</p>
</blockquote>
</li>
<li>不信任权威，提倡去中心化。<blockquote>
<p>Mistrust Authority-Promote Decentralization.</p>
</blockquote>
</li>
<li>判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或者地位等其他标准。<blockquote>
<p>Hackers should be judged by their hacking, not bogus criteria such as degrees,age,race,or position.</p>
</blockquote>
</li>
<li>你可以用计算机创造美和艺术。<blockquote>
<p>You can create art and beauty on a computer.</p>
</blockquote>
</li>
<li>计算机使生活更美好。<blockquote>
<p>Computers can change your life for the better.</p>
</blockquote>
</li>
</ol>
<p>根据这六条“黑客伦理”，黑客价值观的核心原则可以概括成这样几点：<strong>分享、开放、民主、计算机的自由使用、进步</strong>。</p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成Mybatis</title>
    <url>/20200929/java/springboot/c091a644/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis</a> 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<a id="more"></a>

<h1 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h1><p>新建SpringBoot 2.x项目</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在pom.xml中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencys</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为演示方便，这里使用H2来代替Mysql</p>
<p>H2可以兼容很多数据库, 通过url后缀MODE参数来设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oracle jdbc:h2:~&#x2F;test;MODE&#x3D;Oracle或SQL语句SET MODE Oracle</span><br><span class="line">Mysql jdbc:h2:~&#x2F;test;MODE&#x3D;MySQL;DATABASE_TO_LOWER&#x3D;TRUE</span><br><span class="line">PostgreSQL jdbc:h2:~&#x2F;test;MODE&#x3D;PostgreSQL;DATABASE_TO_LOWER&#x3D;TRUE</span><br><span class="line">MS SQL Server jdbc:h2:~&#x2F;test;MODE&#x3D;MSSQLServer或SQL语句SET MODE MSSQLServer</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><p>application.yml中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.jonesun.mybatis.entity</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 打印sql日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="comment"># 开启驼峰命名</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>application-dev.yml中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mybatis-normal-demo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># h2配置(日常开发改为mysql配置即可)</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">classpath:db/schema-h2.sql</span></span><br><span class="line">    <span class="attr">data:</span> <span class="string">classpath:db/data-h2.sql</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/console</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  日志输出级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com:</span></span><br><span class="line">      <span class="attr">jonesun:</span></span><br><span class="line">        <span class="attr">mybatis:</span></span><br><span class="line">          <span class="attr">dao:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用配置说明</p>
</blockquote>
<ul>
<li>application-dev.yml：开发环境</li>
<li>application-test.yml：测试环境</li>
<li>application-prod.yml：生产环境</li>
</ul>
<p>初始化数据库：db/schema-h2.sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">users</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    create_time DATETIME <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;创建日期&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>初始化表数据: db/data-h2.sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span> (<span class="keyword">id</span>, <span class="string">`name`</span>, age, email, create_time) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;jone@163.com&#x27;</span>, <span class="string">&#x27;2020-02-09 08:20:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;jack@163.com&#x27;</span>, <span class="string">&#x27;2020-02-10 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;tom@163.com&#x27;</span>, <span class="string">&#x27;2020-03-11 06:10:00&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;sandy@163.com&#x27;</span>, <span class="string">&#x27;2020-04-12 05:30:00&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;billie@163.com&#x27;</span>, <span class="string">&#x27;2020-05-13 03:40:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编写mapper"><a href="#编写mapper" class="headerlink" title="编写mapper"></a>编写mapper</h3><p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jonesun.mybatis.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter、setter    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>dao</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jonesun.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateById</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">selectList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>mapper.xml</strong></p>
<p>resources\mapper\user\UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.jonesun.mybatis.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;BASE_TABLE&quot;</span>&gt;</span></span><br><span class="line">        users</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;BASE_COLUMN&quot;</span>&gt;</span></span><br><span class="line">        id, name, age, email, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_TABLE&quot;</span>/&gt;</span></span><br><span class="line">        (name, age, email, create_time)</span><br><span class="line">        values (#&#123;name&#125;, #&#123;age&#125;, #&#123;email&#125;, now())</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">        delete</span><br><span class="line">        from</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_TABLE&quot;</span>/&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateById&quot;</span>&gt;</span></span><br><span class="line">        update</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_TABLE&quot;</span>/&gt;</span></span><br><span class="line">        set name = #&#123;name&#125;,</span><br><span class="line">        age = #&#123;age&#125;,</span><br><span class="line">        email = #&#123;email&#125;</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jonesun.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_COLUMN&quot;</span>/&gt;</span></span><br><span class="line">        FROM</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_TABLE&quot;</span>/&gt;</span></span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jonesun.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_COLUMN&quot;</span>/&gt;</span></span><br><span class="line">        FROM</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BASE_TABLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jonesun.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jonesun.mybatis.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    @Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;Jone Sun&quot;</span>, <span class="number">30</span>, <span class="string">&quot;sunjoner7@gmail.com&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> result = userDao.insert(user);</span><br><span class="line">        assertNotNull(user.getId(), <span class="string">&quot;用户插入失败&quot;</span>);</span><br><span class="line">        assertTrue(result &gt; <span class="number">0</span>, <span class="string">&quot;用户插入失败&quot;</span>);</span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userDao.deleteById(<span class="number">5</span>);</span><br><span class="line">        assertTrue(result &gt; <span class="number">0</span>, <span class="string">&quot;用户删除失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selectById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userDao.selectById(<span class="number">1</span>);</span><br><span class="line">        assertEquals(user.getName(), <span class="string">&quot;Jone&quot;</span>, <span class="string">&quot;用户名错误&quot;</span>);</span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userDao.selectById(<span class="number">1</span>);</span><br><span class="line">        user.setAge(<span class="number">21</span>);</span><br><span class="line">        <span class="keyword">int</span> result = userDao.updateById(user);</span><br><span class="line">        assertTrue(result &gt; <span class="number">0</span>, <span class="string">&quot;用户更新失败&quot;</span>);</span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selectList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userDao.selectList();</span><br><span class="line">        assertFalse(list.isEmpty(), <span class="string">&quot;列表为空&quot;</span>);</span><br><span class="line">        log.debug(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/jonesun/mybatis-sample">样例代码</a></p>
<h1 id="常用动态SQL标签"><a href="#常用动态SQL标签" class="headerlink" title="常用动态SQL标签"></a>常用动态SQL标签</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>只有判断条件为true才会执行其中的SQL语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.jonesun.springredis.entity.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE</span><br><span class="line">    users</span><br><span class="line">    SET</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password = #&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    nick_name = #&#123;nickName&#125;</span><br><span class="line">    WHERE</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当if中出现多个判断条件时, 使用and:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.jonesun.springredis.entity.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE</span><br><span class="line">    users</span><br><span class="line">    SET</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null and password !=&#x27;&#x27;&quot;</span>&gt;</span>password = #&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    nick_name = #&#123;nickName&#125;</span><br><span class="line">    WHERE</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>XML中对大于＞、＜这种特殊字符串需要做转义处理:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&#x27;id != null and id gt 28&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">大于：<span class="symbol">&amp;gt;</span></span><br><span class="line">小于：<span class="symbol">&amp;lt;</span></span><br><span class="line">大于等于：<span class="symbol">&amp;gt;</span>=</span><br><span class="line">小于等于：<span class="symbol">&amp;lt;</span>=</span><br><span class="line"></span><br><span class="line">sql中也可以使用  &lt;![CDATA[ &gt;= ]]&gt;</span><br></pre></td></tr></table></figure>

<h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句，choose 为 switch，when 为 case，otherwise 则为default:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;defaultDetailMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    users.*</span><br><span class="line">    from users</span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex == &#x27;男&#x27;&quot;</span>&gt;</span></span><br><span class="line">            users.sex=0</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex == &#x27;女&#x27;&quot;</span>&gt;</span></span><br><span class="line">            users.sex=1</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            users.sex IS NOT NULL</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>where 元素只会在子元素返回任何内容的情况下才插入 WHERE 子句。而且，若子句的开头为 AND 或 OR，where 元素也会将它们去除:</p>
<p>当遇到如下场景，status恰好为空时，则会报错(where后面没有条件了): </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时使用<where>可解决：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span>  <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>使用 set 标签可以将动态的配置 set 关键字，和剔除追加到条件末尾的任何不相关的逗号</p>
<p>当遇到如下场景，hobby恰好为空时，则会报错(最后会多一个,): </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>&gt;</span></span><br><span class="line">    UPDATE STUDENT    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            NAME = #&#123;name&#125;,        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            MAJOR = #&#123;major&#125;,        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            HOBBY = #&#123;hobby&#125;        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时使用<set>可解决：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>&gt;</span></span><br><span class="line">    UPDATE STUDENT    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            NAME = #&#123;name&#125;,        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            MAJOR = #&#123;major&#125;,        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            HOBBY = #&#123;hobby&#125;        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach是用来对集合的遍历，这个和Java中的功能很类似。通常处理SQL中的in语句</p>
<p>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;defaultDetailMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    users.*</span><br><span class="line">    from users</span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;statusList != null&quot;</span>&gt;</span></span><br><span class="line">            users.status IN</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;statusList&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">                #&#123;item&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            users.status IS NOT NULL</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>在实际开发中会遇到许多相同的SQL，比如根据某个条件筛选，这个筛选很多地方都能用到，我们可以将其抽取出来成为一个公用的部分，这样修改也方便，一旦出现了错误，只需要改这一处便能处处生效了，此时就用到了<sql>这个标签了</p>
<p>当多种类型的查询语句的查询字段或者查询条件相同时，可以将其定义为常量，方便调用。为求 <select> 结构清晰也可将 sql 语句分解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    id,birthday,name,status<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询条件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Example_Where_Clause&quot;</span>&gt;</span></span><br><span class="line">    where 1=1    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null and id !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null &quot;</span>&gt;</span></span><br><span class="line">            and birthday = #&#123;birthday&#125;        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and NAME = #&#123;name&#125;        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null and status != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and status = #&#123;status&#125;       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>include用于引用sql标签定义的常量。比如引用上面sql标签定义的常量，如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    FROM student    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果遇到resultMap或者<sql>片段已经在另外一个xxxMapper.xml中已经定义过了，此时当前的xml还需要用到，Mybatis中也是支持引用其他Mapper文件中的SQL片段的(类似于Java中的全类名):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;com.xxx.dao.xxMapper.Base_Column_List&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><select>标签中的resultMap同样可以这么引用</p>
</blockquote>
<blockquote>
<p>当遇到表字段冲突时，如users表和user_detail表都有status时，可在字段前加上表名:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    ID,MAJOR,BIRTHDAY,AGE,NAME,HOBBY,users.status<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p>开过阿里巴巴开发手册的大概都知道代码中是不允许出现魔数的，何为魔数？简单的说就是一个数字，一个只有你知道，别人不知道这个代表什么意思的数字。通常我们在Java代码中都会定义一个常量类专门定义这些数字。在Mybatis中同样可以使用(@+全类名+@+常量)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type!=null and type==@com.xxx.core.Constants.CommonConstants@DOC_TYPE&quot;</span>&gt;</span></span><br><span class="line">    -- ....获取医生的权限<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type!=null and type==@com.xxx.core.Constants.CommonConstants@NUR_TYPE&quot;</span>&gt;</span></span><br><span class="line">    -- ....获取护士的权限<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了调用常量类中的常量，还可以类中的方法</p>
</blockquote>
<h2 id="通过selectKey获取自定义列"><a href="#通过selectKey获取自定义列" class="headerlink" title="通过selectKey获取自定义列"></a>通过selectKey获取自定义列</h2><p>假如有些数据库不支持自增主键，或者说我们想插入自定义的主键，而又不想在业务代码中编写逻辑，那么就可以通过MyBatis的selectKey来获取：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert2&quot;</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;address&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        select uuid() from lw_user_address</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into lw_user_address (address) values (#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>selectKey中的order属性有2个选择：BEFORE和AFTER。</p>
<ul>
<li>BEFORE：表示先执行selectKey的语句，然后将查询到的值设置到JavaBean对应属性上，然后再执行insert语句。</li>
<li>AFTER：表示先执行AFTER语句，然后再执行selectKey语句，并将selectKey得到的值设置到JavaBean中的属性。上面示例中如果改成AFTER，那么插入的address就会是空值，但是返回的JavaBean属性内会有值</li>
</ul>
<blockquote>
<p>selectKey中返回的值只能有一条数据，如果满足条件的数据有多条会报错，所以一般都是用于生成主键，确保唯一，或者在selectKey后面的语句加上条件，确保唯一</p>
</blockquote>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>Mybatis提供了一级缓存和二级缓存的支持</p>
<blockquote>
<p>一级缓存</p>
</blockquote>
<ul>
<li><p>spring整合mybatis后，非事务环境下，每次操作数据库都使用新的sqlSession对象。因此mybatis的一级缓存无法使用（一级缓存针对同一个sqlsession有效）,当然可以使用同一个sqlSession来使用一级缓存</p>
</li>
<li><p>*在开启事物的情况之下，spring使用threadLocal获取当前资源绑定同一个sqlSession，因此此时一级缓存是有效的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisApplicationTests</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cacheTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list1 = userDao.selectList();</span><br><span class="line">    assertFalse(list1.isEmpty(), <span class="string">&quot;列表为空&quot;</span>);</span><br><span class="line">    log.debug(list1.toString());</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; list2 = userDao.selectList();</span><br><span class="line">    assertFalse(list2.isEmpty(), <span class="string">&quot;列表为空&quot;</span>);</span><br><span class="line">    log.debug(list2.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样就只会访问一次数据库</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>二级缓存</p>
</blockquote>
<p>在同一个namespace下的mapper文件中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则二级缓存清空</p>
<p>Mybatis 的二级缓存需要手动开启才能启动，与一级缓存的最大区别就在于二级缓存的作用范围比一级缓存大，二级缓存是多个 sqlSession 可以共享一个 Mapper 的二级缓存区域，二级缓存作用的范围是 Mapper 中的同一个命名空间（namespace）的 statement 。在配置文件默认开启了二级缓存的情况下，如果每一个 namespace 都开启了二级缓存，则都对应有一个二级缓存区，同一个 namespace 共用一个二级缓存区</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.jonesun.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启本mapper的namespace下的二级缓存</span></span><br><span class="line"><span class="comment">    type：指定cache接口的实现类的类型，mybatis默认使用PerpetualCache</span></span><br><span class="line"><span class="comment">    要和ehcache整合，需要配置type为ehcache实现cache接口的类型--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>指定缓存（cache）接口的实现类型，当需要和ehcache整合时更改该参数值即可。</td>
</tr>
<tr>
<td>flushInterval</td>
<td>刷新间隔。可被设置为任意的正整数，单位毫秒。默认不设置。</td>
</tr>
<tr>
<td>size</td>
<td>引用数目。可被设置为任意正整数，缓存的对象数目等于运行环境的可用内存资源数目。默认是1024。</td>
</tr>
<tr>
<td>readOnly</td>
<td>只读，true或false。只读的缓存会给所有的调用者返回缓存对象的相同实例。默认是false。</td>
</tr>
<tr>
<td>eviction</td>
<td>缓存收回策略。LRU（最近最少使用的），FIFO（先进先出），SOFT（ 软引用），WEAK（ 弱引用）。默认是 LRU。</td>
</tr>
</tbody></table>
<blockquote>
<p> 在 Mapper 中加入cache便签后，可以在select中可设置useCache=”false”来禁用缓存；在insert、update、delete中设置flushCache=”false”来取消清空/刷新缓存，默认是会清空缓存</p>
</blockquote>
<h3 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h3><blockquote>
<p>通常我们会为每个单表创建单独的映射文件，由于MyBatis的二级缓存是基于namespace的，多表查询语句所在的namspace无法感应到其他namespace中的语句对多表查询中涉及的表进行的修改，引发<strong>脏数据问题</strong></p>
</blockquote>
<p>为了避免这个问题，在多个mapper.xml中如果要一起使用二级缓存，可以使用cache-ref引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache，这样两个映射文件对应的Sql操作都使用的是同一块缓存了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.StudentMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不过需要注意的是，缓存的粒度就变粗了，多个Mapper namespace下的所有操作都会对缓存使用造成影响</li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><blockquote>
<p>二级缓存一般应用在对于访问多的查询请求且对查询结果的实时性要求不高的，此时可采用 Mybatis 二级缓存技术降低数据库访问量，提高访问速度。例如：耗时比较高的统计分析的sql</p>
</blockquote>
<h1 id="pagehelper"><a href="#pagehelper" class="headerlink" title="pagehelper"></a>pagehelper</h1><p>可结合<a href="https://pagehelper.github.io/">pagehelper</a>实现分页</p>
<ul>
<li>pom.xml中加入引用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>service层使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">PageInfo&lt;User&gt; <span class="title">getAllUsersForPage</span><span class="params">(<span class="keyword">int</span> pageNo, <span class="keyword">int</span> pageSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo&lt;User&gt; <span class="title">getAllUsersForPage</span><span class="params">(<span class="keyword">int</span> pageNo, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        PageHelper.startPage(pageNo,pageSize);</span><br><span class="line">        List&lt;User&gt; list = userDao.selectList();</span><br><span class="line">        PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">return</span> pageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAllUsersForPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PageInfo&lt;User&gt; pageInfo = userService.getAllUsersForPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        assertFalse(pageInfo.getList().isEmpty(), <span class="string">&quot;列表为空&quot;</span>);</span><br><span class="line">        log.debug(pageInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><p>实际项目中会使用mysql与mybatis进行搭配</p>
<ul>
<li>pom.xml中加入引用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改对应application-xx.yml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/xxx?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有两点需要注意: </p>
</blockquote>
<ul>
<li><p>mysql-connector包使用了新的驱动: com.mysql.jdbc.Driver被弃用了,应为com.mysql.cj.jdbc.Driver</p>
</li>
<li><p>连接的URL中需要增加时区信息: serverTimezone=UTC或者serverTimezone=GMT+8</p>
</li>
</ul>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><blockquote>
<p>Hikari</p>
</blockquote>
<p>SpringBoot 默认数据库连接池是Hikari,可以根据项目需要自定义配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/xxx?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#    # SpringBoot 默认数据库连接池Hikari will use the above plus the following to setup connection pooling</span></span><br><span class="line"><span class="comment">#    type: com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment">## 最小空闲连接数量</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment">## 连接池最大连接数，默认是10</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">15</span></span><br><span class="line">      <span class="comment">## 此属性控制从池返回的连接的默认自动提交行为,默认值：true</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">## 空闲连接存活最大时间，默认600000（10分钟）,时间单位都是毫秒</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment">## 连接池名称</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">DatebookHikariCP</span></span><br><span class="line">      <span class="comment">## 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="comment">## 数据库连接超时时间,默认30秒，即30000</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<p>大多数线上应用可以使用如下的Hikari配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">maximumPoolSize:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">minimumIdle:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">connectionTimeout:</span> <span class="number">30000</span></span><br><span class="line"><span class="attr">idleTimeout:</span> <span class="number">600000</span></span><br><span class="line"><span class="attr">maxLifetime:</span> <span class="number">1800000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>druid</p>
</blockquote>
<p>如果需要可以改用阿里巴巴的<a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">druid</a></p>
<ul>
<li>pom文件加入引用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对应application-xx.yml中加入配置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/xxx?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># 使用druid连接池</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line"><span class="comment">#      #当数据库抛出不可恢复的异常时,抛弃该连接</span></span><br><span class="line"><span class="comment">#      init-exception-throw: true</span></span><br><span class="line"><span class="comment">#      exception-sorter: true</span></span><br><span class="line">      <span class="comment">#初始化时建立物理连接的个数</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment">#最大连接池数量 maxIdle已经不再使用</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment">#是否缓存preparedStatement,mysql5.5+建议开启</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#当值大于0时poolPreparedStatements会自动修改为true</span></span><br><span class="line">      <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment">#获取连接时最大等待时间，单位毫秒</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment">#销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment">#最小连接池数量</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment">#申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment">#归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line">      <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment">#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#既作为检测的间隔时间又作为testWhileIdel执行的依据</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment">#用来检测连接是否有效的sql 必须是一个查询语句</span></span><br><span class="line">      <span class="comment">#mysql中为 select &#x27;x&#x27;</span></span><br><span class="line">      <span class="comment">#oracle中为 select 1 from dual</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，StatFilter,用于统计监控信息&#x27;wall&#x27;用于防火墙</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall,slf4j</span></span><br><span class="line">      <span class="comment">#通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">      <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line">      <span class="comment">#合并多个DruidDataSource的监控数据</span></span><br><span class="line">      <span class="attr">use-global-data-source-stat:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 配置DruidStatFilter</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">url-pattern:</span> <span class="string">&quot;/*&quot;</span></span><br><span class="line">          <span class="attr">exclusions:</span> <span class="string">&quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;</span></span><br><span class="line">      <span class="comment">#设置访问druid监控页的账号和密码,默认没有</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">&quot;/druid/*&quot;</span></span><br><span class="line">        <span class="comment"># IP白名单(没有配置或者为空，则允许所有访问)</span></span><br><span class="line"><span class="comment">#        allow: localhost,127.0.0.1,192.168.*</span></span><br><span class="line">        <span class="comment"># IP黑名单 (存在共同时，deny优先于allow)</span></span><br><span class="line">        <span class="comment">#deny: 192.168.1.100</span></span><br><span class="line">        <span class="comment">#  禁用HTML页面上的“Reset All”功能</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>阿里巴巴的druid带了一个监控sql相关的页面，访问项目地址+/druid/即可查看(登录用户名密码在yml中设置的login-username和login-password)</p>
</blockquote>
<p>关于druid和Hikari有个比较有意思的<a href="https://github.com/brettwooldridge/HikariCP/issues/232">讨论</a></p>
<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><p>可结合mybatis-plus生成基础sql，感兴趣可以了解下，个人不是很推荐代码生成相关(除非确实都是简单的CURD)</p>
<p>使用默认的MyBatis，如果需要添加新的表对应dao层的话，一般需要编写mapper和dao方法(这点就不如JPA来的方便)，可以使用<a href="https://baomidou.com/">MyBatis-Plus</a>来简化开发，生成基础的sql</p>
<blockquote>
<p>引入 MyBatis-Plus 之后请不要再次引入 MyBatis 以及 MyBatis-Spring，以避免因版本差异导致的问题。</p>
</blockquote>
<p>去除原有mybatis相关依赖，加入:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;2.1.3&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;1.3.0&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在在项目中使用的话，直接用mybatis-plus-boot-starter</p>
</blockquote>
<p>注意因为pagehelper-spring-boot-starter默认会引用mybatis，所以要不直接去除(MyBatis-Plus有自己的分页功能), 要不就将pagehelper-spring-boot-starter的mybatis引用排除掉</p>
<h1 id="推荐idea插件"><a href="#推荐idea插件" class="headerlink" title="推荐idea插件"></a>推荐idea插件</h1><ul>
<li>free-idea-mybatis(Free MyBatis Plugin)是一款增强idea对mybatis支持的插件，主要功能如下： <ul>
<li>生成mapper xml文件</li>
<li>快速从代码跳转到mapper及从mapper返回代码</li>
<li>mybatis自动补全及语法错误提示</li>
<li>集成mybatis generator gui界面</li>
</ul>
</li>
</ul>
<p>这个插件同样可以生成mapper.xml相关文件</p>
<h1 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h1><p>如果是主从复制- -读写分离：比如test01中负责增删改，test02中负责查询。但是需要注意的是负责增删改的数据库必须是主库（master）</p>
<p><a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/">sharding-jdbc</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/shijiemozujiejie/article/details/80766633">mysql主从复制</a></p>
<h1 id="Mybatis分层结构"><a href="#Mybatis分层结构" class="headerlink" title="Mybatis分层结构"></a>Mybatis分层结构</h1><blockquote>
<p>mysql inndb默认可重复读级别，不会出现幻读。</p>
</blockquote>
<p>mybatis架构自下而上分为基础支撑层、数据处理层、API接口层这三层。</p>
<ul>
<li>基础支撑层，主要是用来做连接管理、事务管理、配置加载、缓存管理等最基础组件，为上层提供最基础的支撑。</li>
<li>数据处理层，主要是用来做参数映射、sql解析、sql执行、结果映射等处理，可以理解为请求到达，完成一次数据库操作的流程。</li>
<li>API接口层，主要对外提供API，提供诸如数据的增删改查、获取配置等接口。</li>
</ul>
<h1 id="Mybatis-Dynamic-Sql"><a href="#Mybatis-Dynamic-Sql" class="headerlink" title="Mybatis Dynamic Sql"></a>Mybatis Dynamic Sql</h1><p>我们常用的xml配置属于MyBatis3风格，官方推出了一个新的风格MyBatis3DynamicSql(java+注解)，感兴趣可以参考<a href="https://github.com/mybatis/mybatis-dynamic-sql">官方Github</a></p>
<p>pom.xml需加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.dynamic-sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-dynamic-sql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Docker-Mysql"><a href="#Docker-Mysql" class="headerlink" title="Docker Mysql"></a>Docker Mysql</h1><p>拉取mysql镜像，如果需要指定版本则可以到<a href="https://hub.docker.com/_/mysql?tab=tags">Hub Docker</a>中寻找合适版本，这里我们直接用最新版本(8.+)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root123 -d mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射本地路径</span></span><br><span class="line">docker run -p 3306:3306 --name mysql --restart=always -v /d/Software/docker/env/mysql/logs:/var/log/mysql -v /d/Software/docker/env/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root123 -d mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般mysql配置文件是不需要映射的，只要映射日志和数据保存位置即可</p>
</blockquote>
<p>进入容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql bash</span><br></pre></td></tr></table></figure>

<p>登录mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果要修改密码</span></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root123&#x27;;</span><br></pre></td></tr></table></figure>

<p>授权其他电脑访问并更新加密规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* TO &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>添加远程登录用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;jonesun&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;jonesun123&#x27;;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;jonesun&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="Mysql客户端工具"><a href="#Mysql客户端工具" class="headerlink" title="Mysql客户端工具"></a>Mysql客户端工具</h2><ul>
<li><p><a href="https://www.mysql.com/products/workbench/">MySQL Workbench</a>: 这属于mysql官方出品，免费，功能强大，是首选。<br><img src="mysql-workbench.png" alt="mysql-workbench"></p>
</li>
<li><p><a href="https://dbeaver.io/download/">DBeaver</a>:  开放<a href="https://github.com/dbeaver/dbeaver">源码</a>  超过2万Star的项目，中文友好，推荐使用<br><img src="dbeaver-ss-mock.png" alt="dbeaver-ss-mock"></p>
</li>
<li><p><a href="https://www.navicat.com/en/products/navicat-for-mysql">navicat-for-mysql</a>: 这个确实是好用，就是价格有点贵。网上也有不少破解版，喜欢用的自行搜索吧<br><img src="navicat-for-mysql.png" alt="navicat-for-mysql"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-监控</title>
    <url>/20201120/java/springboot/685e4f62/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>方式一： Spring Boot Actuator + Micrometer + Prometheus + Grafana</p>
<p>方式二： Spring Boot Actuator + Spring Boot Admin</p>
 <a id="more"></a>


<h1 id="方式一-Micrometer-Prometheus-Grafana"><a href="#方式一-Micrometer-Prometheus-Grafana" class="headerlink" title="方式一 Micrometer + Prometheus + Grafana"></a>方式一 Micrometer + Prometheus + Grafana</h1><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用了Spring Security等权限框架需要放开</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">web.ignoring().antMatchers(<span class="string">&quot;/actuator&quot;</span>, <span class="string">&quot;/actuator/**&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<p>浏览器测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;actuator&#x2F;prometheus</span><br></pre></td></tr></table></figure>

<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>Prometheus是一款开源的监控 + 时序数据库 + 报警软件</p>
<p><a href="https://prometheus.io/download/">Prometheus官网</a>下载，或者访问<a href="https://hub.docker.com/u/prom">docker</a>进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull prom&#x2F;statsd-exporter</span><br><span class="line"></span><br><span class="line">docker run -d -p 9090:9090 \</span><br><span class="line">    -v $(pwd)&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \</span><br><span class="line">    prom&#x2F;prometheus --config.file&#x3D;&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需编写prometheus.yml</p>
</blockquote>
<p>新增</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;springboot&#x27;</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">&#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:8080&#x27;</span>]</span><br></pre></td></tr></table></figure>


<p>如果不是采用的docker方式，直接找到安装目录下的prometheus.yml，在scrape_configs新增</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;springboot&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:8080&#x27;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>targets对应需要监控的服务地址</p>
</blockquote>
<p>浏览器访问测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9090</span><br></pre></td></tr></table></figure>

<p>至此，已经用Prometheus实现了监控数据的可视化，然而使用体验并不好。下面来用Grafana实现更友好、更贴近生产的监控可视化。</p>
<h3 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h3><p>Grafana是一个开源的跨平台度量分析和可视化 + 告警工具</p>
<p><a href="https://grafana.com/grafana/download?pg=hp&platform=docker&plcmt=hero-btn2">grafana</a></p>
<p>使用docker安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name&#x3D;grafana -p 3000:3000 grafana&#x2F;grafana</span><br></pre></td></tr></table></figure>

<p>Windows的话下载zip或者安装包直接安装即可</p>
<p>登录：访问 <a href="http://localhost:3000/">http://localhost:3000</a> ，初始账号/密码为：admin/admin</p>
<p><img src="grafana-home.png" alt="grafana-home"></p>
<h4 id="绑定Prometheus"><a href="#绑定Prometheus" class="headerlink" title="绑定Prometheus"></a>绑定Prometheus</h4><p>左侧菜单选择Configuration-datasources-Add data source</p>
<p>添加Prometheus地址</p>
<p><img src="grafana-add-proetheus.png" alt="grafana-add-proetheus"></p>
<p>点击 save&amp;test，测试成功即可</p>
<h4 id="创建监控Dashboard"><a href="#创建监控Dashboard" class="headerlink" title="创建监控Dashboard"></a>创建监控Dashboard</h4><p>左侧菜单选择+Create-Import，输入id为<strong>4701</strong>，这个是为Micrometer提供的增强包。有兴趣可以前往 <a href="https://grafana.com/dashboards">Grafana Lab - Dashboards</a>，输入关键词即可搜索指定Dashboard, 详情页的右上角找到id</p>
<p><img src="grafana-dashboard-id.png" alt="grafana-dashboard-id"></p>
<p>比较好用的Dashboard</p>
<ul>
<li>JVM (Micrometer)</li>
<li>JVM (Actuator)</li>
<li>Spring Boot Statistic</li>
</ul>
<blockquote>
<p>注意是以 Prometheus 作为数据源，支持Micrometer的Dashboard</p>
</blockquote>
<p><img src="grafana-import.png" alt="grafana-import"></p>
<p>点击右侧load后，选择prometheus，确认后import</p>
<p><img src="grafana-import-select-prometheus.png" alt="grafana-import-select-prometheus"></p>
<blockquote>
<p>如果选择项是空的，注意是否开启了prometheus</p>
</blockquote>
<p><img src="grafana-dashboard.png" alt="grafana-dashboard"></p>
<p>可查看监控的服务jvm等情况</p>
<h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><p>Grafana支持的告警渠道非常丰富，例如邮件、钉钉、Slack、Webhook等，有兴趣可以了解下</p>
<h1 id="方式二-Spring-Boot-Admin"><a href="#方式二-Spring-Boot-Admin" class="headerlink" title="方式二 Spring Boot Admin"></a>方式二 Spring Boot Admin</h1><p><a href="https://codecentric.github.io/spring-boot-admin/current/">Spring Boot Admin</a> 是一个开源社区项目，用于管理和监控SpringBoot应用程序。 应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册（通过HTTP）或使用SpringCloud注册中心（例如Eureka，Consul）发现。 UI是的AngularJs应用程序，展示Spring Boot Admin Client的Actuator端点上的一些监控。</p>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>创建两个SpringBoot项目，一个作为监控端(admin-server-demo)，一个作为被监控端(admin-client-demo)</p>
<h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jonesun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>admindemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>admin-server-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>14<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot-admin.version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">spring-boot-admin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">admin-server</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">        <span class="attr">mail:</span></span><br><span class="line">          <span class="comment"># 收件人列表(多个使用,分隔)</span></span><br><span class="line">          <span class="attr">to:</span> <span class="string">xxx@163.com</span></span><br><span class="line">          <span class="comment"># 是否开启(如果暂时不需要通知，可关闭)</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 抄送</span></span><br><span class="line">          <span class="attr">cc:</span> <span class="number">111</span><span class="string">@163.com,222@163.com</span></span><br><span class="line">          <span class="comment"># 发件人</span></span><br><span class="line">          <span class="attr">from:</span> <span class="string">xxx&lt;aaa@163.com&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">    <span class="comment"># port: 25</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">aaa@163.com</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">utf-8</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxx</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>QQ、163等邮箱需要设置授权码，password填生成好的授权码，如果不需要邮件告警，去除mail相关配置即可</p>
</blockquote>
<p>AdminServerDemoApplication.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminServerDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AdminServerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，一定要加上@EnableAdminServer</p>
</blockquote>
<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><p>新建Spring Boot项目</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jonesun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>admin-client-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>admin-client-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>14<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot-admin.version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">spring-boot-admin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">admin-client</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://localhost:8001</span></span><br><span class="line">        <span class="attr">instance:</span></span><br><span class="line">          <span class="comment"># 客户端实例 url</span></span><br><span class="line">          <span class="attr">service-url:</span> <span class="string">http://127.0.0.1:8002</span></span><br><span class="line">          <span class="attr">prefer-ip:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 客户端实例名称</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">cts-vivo-preview</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br></pre></td></tr></table></figure>

<h2 id="运行验证"><a href="#运行验证" class="headerlink" title="运行验证"></a>运行验证</h2><p>分别启动两个服务，然后浏览器中打开server端的网址: <a href="http://localhost:8001/">http://localhost:8001/</a></p>
<p>即可查看监控信息，和服务的详细情况</p>
<p><img src="springboot-admin.png" alt="springboot-admin"></p>
<p>如果存在Spring Security，则需要添加自定义安全配置，以允许对端点进行未经身份验证的访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ActuatorSecurity extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">            .anyRequest().permitAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>如果想在admin-server中查看client的日志，则需在client的application.yml中加入配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&quot;%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n%wEx&quot;</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="comment"># 日志所在路径(需与日志框架中配置的路径一致)</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">C:/tmp/admin-client/spring-log.log</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意logging.file.name不支持表达式，所以项目中无论是使用默认logback还是log4j2，都需要匹配好日志路径及名称。如果需要配置相对路径则可配置为./log/xxx.log，表示为项目所在目录下的log文件夹中的xxx.log文件<br>低版本的springBoot没有logging.file.name，可直接配置为logging.file</p>
</blockquote>
<p>这样就可以在admin-server中查看日志,无需登录到服务器上查看了，甚至可以利用日志配置，在线实时调整日志的显示级别(内部原理也是actuator)，方便在出现异常情况下查看详细的日志打印</p>
<p><img src="spring-boot-admin-log.png" alt="spring-boot-admin-log"></p>
<p><img src="spring-boot-admin-log-config.png" alt="spring-boot-admin-log-config"></p>
<h2 id="告警-1"><a href="#告警-1" class="headerlink" title="告警"></a>告警</h2><p>结合spring-boot-starter-mail(admin-server中配置)进行告警，主要是Spring Boot Actuator的使用，这里举个例子：</p>
<p>当服务器中的磁盘容量不足5GB时，进行邮件告警</p>
<p>修改client-server中的application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">env,beans</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">health,info</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line">  <span class="attr">health:</span></span><br><span class="line">    <span class="attr">diskspace:</span></span><br><span class="line">      <span class="comment"># 当磁盘容量不足5GB时告警</span></span><br><span class="line">      <span class="attr">threshold:</span> <span class="string">5GB</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际项目中肯定不能将所有<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints">endpoint</a> 都暴露，根据项目自己调整</p>
</blockquote>
<p>这边我们设置diskspace的阈值为5GB, 即如果运行环境的磁盘容量不足5GB时进行告警(本地测试的话为看到邮件通知可调整为较大的数值如150GB)</p>
<p>重新启动项目后, 就会收到邮件通知，并且admin-server中对应的diskspace状态会为DOWN</p>
<h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>当使用Spring Boot Actuator和Spring Boot Admin, 实际项目中肯定不能直接暴露到让人随意访问，这里我们加入Spring Security</p>
<ul>
<li>admin-server中</li>
</ul>
<p>pom.xml中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml中加入测试账户(实际项目中可结合数据库进行配合)，不过一般项目写死也可以，毕竟服务器配置一般不会外传</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin123</span></span><br></pre></td></tr></table></figure>

<p>加入权限配置SecurityConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String contextPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contextPath = adminServerProperties.getContextPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 跨域设置，SpringBootAdmin客户端通过instances注册，见InstancesController</span></span><br><span class="line">        http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</span><br><span class="line">                .ignoringAntMatchers(contextPath + <span class="string">&quot;/instances&quot;</span>);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated(); <span class="comment">// 所有请求必须通过认证</span></span><br><span class="line"></span><br><span class="line">        http.formLogin().loginPage(<span class="string">&quot;/login&quot;</span>).permitAll();</span><br><span class="line">        http.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>).logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用basic认证，SpringBootAdmin客户端使用的是basic认证</span></span><br><span class="line">        http.httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client-server中</li>
</ul>
<p>application.yml中加入配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">admin123</span></span><br></pre></td></tr></table></figure>

<p>分别重启两个项目，浏览器访问admin-server，可以发现需要登录才可以查看</p>
<p><img src="spring-boot-admin-login.png" alt="spring-boot-admin-login"></p>
<blockquote>
<p>如果client-server也使用了security</p>
</blockquote>
<p>则首先需支持HTTP BASIC 方式访问端点(默认是支持的)，然后将元数据提供给admin-server</p>
<p>client-server中application.yml加入:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">   <span class="attr">boot:</span></span><br><span class="line">     <span class="attr">admin:</span></span><br><span class="line">       <span class="attr">client:</span></span><br><span class="line">         <span class="attr">instance:</span></span><br><span class="line">           <span class="attr">metadata:</span></span><br><span class="line">             <span class="attr">user.name:</span> <span class="string">$&#123;spring.security.user.name&#125;</span></span><br><span class="line">             <span class="attr">user.password:</span> <span class="string">$&#123;spring.security.user.password&#125;</span> </span><br></pre></td></tr></table></figure>

<p>如果不支持的话，则可以定制 HttpHeadersProvider来达到效果</p>
<blockquote>
<p>示例源码</p>
</blockquote>
<p><a href="https://github.com/jonesun/spring-admin-demo/tree/master/admin-server">admin-server</a></p>
<p><a href="https://github.com/jonesun/spring-admin-demo/tree/master/client-server">client-server</a></p>
<h2 id="Spring-Cloud下的应用"><a href="#Spring-Cloud下的应用" class="headerlink" title="Spring Cloud下的应用"></a>Spring Cloud下的应用</h2><p>集成了Spring Cloud Discovery (如eureka)到应用程序后，则不需要 Spring Boot Admin 客户端。<br>只需在DiscoveryClient中添加Spring Boot Admin Server，其他新增应用的话直接注册到DiscoveryServer即可。</p>
<blockquote>
<p>示例源码</p>
</blockquote>
<p><a href="https://github.com/jonesun/spring-admin-demo/tree/master/eureka-server">eureka-server</a></p>
<p><a href="https://github.com/jonesun/spring-admin-demo/tree/master/eureka-client-with-admin-server">eureka-client-with-admin-server</a></p>
<p><a href="https://github.com/jonesun/spring-admin-demo/tree/master/eureka-client">eureka-client</a></p>
<p>与Spring Boot Admin类似的还有<a href="https://skywalking.apache.org/">Apache Skywalking</a> 利用的java agent， 可以监控任意的java应用，感兴趣可以了解下</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li>监控页面对应信息一栏显示: 未提供任何信息，需要使用spring-boot的插件，运行spring-boot:build-info，生成Actuator使用的构建信息文件build-info.properties, 再次运行就可以看到了</li>
</ul>
<p><img src="spring-boot-admin-info.png" alt="spring-boot-admin-info"></p>
<p>或者在application.yml中加入:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">@project.version@</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">@project.groupId@</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">@project.description@</span></span><br><span class="line">  <span class="comment">#还可以自定义信息</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">jone</span> <span class="string">sun</span></span><br><span class="line">  <span class="attr">blog:</span> <span class="string">https://jonesun.github.io/</span></span><br></pre></td></tr></table></figure>

<p>如果运行后出现类似:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.yaml.snakeyaml.scanner.ScannerException: while scanning for the next token</span><br><span class="line">found character &#39;@&#39; that cannot start any token. (Do not use @ for indentation)</span><br><span class="line"> in &#39;reader&#39;, line 39, column 12:</span><br><span class="line">      version: @project.version@</span><br></pre></td></tr></table></figure>

<p>错误，先检查下pom.xml中是否存在对应值，尤其有些项目没有写description，再在build标签下新增:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启过滤，用指定的参数替换directory下的文件中的参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>java-引用</title>
    <url>/20201130/java/aee68e6b/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java里将数据类型分为了基本数据类型和引用数据类型，基本数据类型包含: byte、char、short、int、float、double、long、boolean，剩下的都是引用类型。最常用的就是String字符串：</p>
<ul>
<li>基本数据类型的值都是直接保存在变量中的(一个变量一个值，可以体会到类似Integer.valueof缓存值的用意)</li>
<li>而引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置</li>
<li>对于基本类型变量num，赋值运算符将会直接修改变量的值，原来的数据将被覆盖掉，被替换为新的值。</li>
<li>对于引用类型变量str，赋值运算符只会改变变量中所保存的<strong>对象的地址</strong>信息，原来对象的地址被覆盖掉，重新写入新对象的地址数据。但<strong>原来的对象本身并不会被改变</strong>，只是不再被任何引用所指向的对象，即“垃圾对象”，后续会被垃圾回收器回收。</li>
<li>引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象</li>
</ul>
<p>基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num &#x3D; 1;</span><br><span class="line">        int num2 &#x3D; num;</span><br><span class="line">        System.out.println(&quot;num修改前: &quot; + num + &quot; num2: &quot; + num2);</span><br><span class="line">        num &#x3D; 2;</span><br><span class="line">        System.out.println(&quot;num修改后: &quot; + num + &quot; num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        StringBuilder sb &#x3D;  new StringBuilder(&quot;hello&quot;);</span><br><span class="line">        StringBuilder sb2 &#x3D; sb;</span><br><span class="line">        System.out.println(&quot;sb修改前: &quot; + sb.toString() + &quot; sb2: &quot; + sb2.toString());</span><br><span class="line">        sb.append(&quot; world&quot;);</span><br><span class="line">        System.out.println(&quot;sb修改后: &quot; + sb.toString() + &quot; sb2: &quot; + sb2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        String str &#x3D; &quot;hello&quot;;</span><br><span class="line">        String str2 &#x3D; str;</span><br><span class="line">        System.out.println(&quot;str修改前: &quot; + str + &quot; str2: &quot; + str2);</span><br><span class="line">        str &#x3D; &quot;world&quot;;</span><br><span class="line">        System.out.println(&quot;str修改后: &quot; + str + &quot; str2: &quot; + str2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">num修改前: 1 num2: 1</span><br><span class="line">num修改后: 2 num2: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">sb修改前: hello sb2: hello</span><br><span class="line">sb修改后: hello world sb2: hello world</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">str修改前: hello str2: hello</span><br><span class="line">str修改后: world str2: hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里可以联想下String的不可变性</p>
</blockquote>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java的参数传递为值传递。也就是说，当我们传递一个参数时，方法将获得该参数的一个拷贝: </p>
<ul>
<li>基本类型变量的值传递，意味着变量本身被复制，并传递给Java方法。Java方法对变量的修改不会影响到原变量。</li>
<li>引用的值传递，意味着对象的地址被复制，并传递给Java方法。Java方法根据该引用的访问将会影响对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num &#x3D; 1;</span><br><span class="line">        System.out.println(&quot;num修改前: &quot; + num);</span><br><span class="line">        testIntArg(num);</span><br><span class="line">        System.out.println(&quot;num修改后: &quot; + num);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        StringBuilder sb &#x3D;  new StringBuilder(&quot;hello&quot;);</span><br><span class="line">        System.out.println(&quot;sb修改前: &quot; + sb.toString());</span><br><span class="line">        testSbArg(sb);</span><br><span class="line">        System.out.println(&quot;sb修改后: &quot; + sb.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        String str &#x3D; &quot;hello&quot;;</span><br><span class="line">        System.out.println(&quot;str修改前: &quot; + str);</span><br><span class="line">        testStrArg(str);</span><br><span class="line">        System.out.println(&quot;str修改后: &quot; + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testIntArg(int num) &#123;</span><br><span class="line">        &#x2F;&#x2F;基本数据类型，参数传递后，方法内部修改不会影响原有参数</span><br><span class="line">        System.out.println(&quot;testIntArg, num修改前: &quot; + num);</span><br><span class="line">        num &#x3D; 2;</span><br><span class="line">        System.out.println(&quot;testIntArg,num修改后: &quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testSbArg(StringBuilder sb) &#123;</span><br><span class="line">        &#x2F;&#x2F;引用数据类型，参数传递后，除非重新new对象，否则方法内部修改会影响原有参数</span><br><span class="line">        System.out.println(&quot;testSbArg, sb修改前: &quot; + sb.toString());</span><br><span class="line">        sb.append(&quot; world&quot;);</span><br><span class="line">        System.out.println(&quot;testSbArg, sb修改后: &quot; + sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testStrArg(String str) &#123;</span><br><span class="line">        System.out.println(&quot;testStrArg, str修改前: &quot; + str);</span><br><span class="line">        &#x2F;&#x2F;String 这里就相当于new String()了</span><br><span class="line">        str &#x3D; &quot;hello world&quot;;</span><br><span class="line">        System.out.println(&quot;testStrArg, str修改后: &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">num修改前: 1</span><br><span class="line">testIntArg, num修改前: 1</span><br><span class="line">testIntArg,num修改后: 2</span><br><span class="line">num修改后: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">sb修改前: hello</span><br><span class="line">testSbArg, sb修改前: hello</span><br><span class="line">testSbArg, sb修改后: hello world</span><br><span class="line">sb修改后: hello world</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">str修改前: hello</span><br><span class="line">testStrArg, str修改前: hello</span><br><span class="line">testStrArg, str修改后: hello world</span><br><span class="line">str修改后: hello</span><br></pre></td></tr></table></figure>

<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>Java提供了四种引用类型：强引用(FinalReference)、软引用(SoftReference)、弱引用(WeakReference)、虚引用(PhantomReference)</p>
<p><img src="Reference.png" alt="Reference"></p>
<p>除了强引用(FinalReference)其他都是public修饰的，可以在我们的程序里直接使用，事实如果我们直接定义变量等某个对象时，默认就是对这个对象的强引用</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用特点：</p>
<ul>
<li>强引用可以直接访问目标对象</li>
<li>只要有引用变量存在，垃圾回收器永远不会回收。JVM即使抛出OOM异常，也不会回收强引用所指向的对象。</li>
</ul>
<ul>
<li>强引用可能导致内存泄漏问</li>
</ul>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那么垃圾回收器<strong>绝不会回收</strong>它。例如:StringBuilder sb = new StringBuilder(“test”);变量str指向StringBuffer实例所在的堆空间，通过str可以操作该对象。</p>
<p>在不用对象的时将引用赋值为 null，能够帮助垃圾回收器回收对象(具体回收时机还是要看垃圾收集策略)。比如 ArrayList 的 clear() 方法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    final Object[] es &#x3D; elementData;</span><br><span class="line">    for (int to &#x3D; size, i &#x3D; size &#x3D; 0; i &lt; to; i++)</span><br><span class="line">        es[i] &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>因此，软引用可以用于实现<strong>对内存敏感的高速缓存</strong>: 在内存足够的情况下直接通过软引用取值，无需从的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p>
<p>软引用特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收：</p>
<ul>
<li>在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用</li>
<li>在垃圾线程回收该Java对象之后，get()方法将返回null</li>
</ul>
<blockquote>
<p>软引用对象是在jvm内存不够的时候才会被回收</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SoftReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    static class HeapObject &#123;</span><br><span class="line">        byte[] bs &#x3D; new byte[1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SoftReference&lt;HeapObject&gt; softReference &#x3D; new SoftReference&lt;&gt;(new HeapObject());</span><br><span class="line"></span><br><span class="line">        List&lt;HeapObject&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (softReference.get() !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;模拟消耗内存</span><br><span class="line">                list.add(new HeapObject());</span><br><span class="line">                System.out.println(&quot;list.add&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;---------软引用已被回收---------&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现简易版缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 简易版软引用实现的缓存</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SoftReferenceCache&lt;K, V&gt; &#123;</span><br><span class="line">    private final HashMap&lt;K, SoftReference&lt;V&gt;&gt; mCache;</span><br><span class="line"></span><br><span class="line">    public SoftReferenceCache() &#123;</span><br><span class="line">        mCache &#x3D; new HashMap&lt;K, SoftReference&lt;V&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将对象放进缓存中，这个对象可以在GC发生时被回收</span><br><span class="line">     * @param key key的值.</span><br><span class="line">     * @param value value的值型.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void put(K key, V value) &#123;</span><br><span class="line">        mCache.put(key, new SoftReference&lt;V&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从缓存中获取value</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 如果找到的话返回value，如果被回收或者没有就返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V get(K key) &#123;</span><br><span class="line">        V value &#x3D; null;</span><br><span class="line">        SoftReference&lt;V&gt; reference &#x3D; mCache.get(key);</span><br><span class="line">        if (reference !&#x3D; null) &#123;</span><br><span class="line">            value &#x3D; reference.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。</p>
<p>不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">        WeakReference&lt;String&gt; weakReference &#x3D; new WeakReference&lt;&gt;(str);</span><br><span class="line">        System.out.println(&quot;1str: &quot; + str + &quot; weakReference&gt;&gt;: &quot; + weakReference.get());</span><br><span class="line">        str &#x3D; null;</span><br><span class="line">        System.out.println(&quot;2str: &quot; + str + &quot; weakReference&gt;&gt;: &quot; + weakReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;3str: &quot; + str + &quot; weakReference&gt;&gt;: &quot; + weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">1str: abc weakReference&gt;&gt;: abc</span><br><span class="line">2str: null weakReference&gt;&gt;: abc</span><br><span class="line">3str: null weakReference&gt;&gt;: null</span><br></pre></td></tr></table></figure>

<p>如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象</p>
<blockquote>
<p>Java中的ThreadLocal内部实现使用的就是WeakReference，因为weakReference的值可能为空，故在使用ThreadLocal时可以使用其提供的initialValue方法</p>
</blockquote>
<h2 id="软引用VS弱引用"><a href="#软引用VS弱引用" class="headerlink" title="软引用VS弱引用"></a>软引用VS弱引用</h2><p>软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 软引用测试类</span><br><span class="line"> * jvm参数， -Xms5m -Xmx10m表示初始内存是5M，最大内存是10M</span><br><span class="line"> * -Xmx256m</span><br><span class="line"> * @author jone.sun</span><br><span class="line"> * @date 2020-11-30 11:12</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private static final Integer COUNT &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        testFinalReference();</span><br><span class="line">&#x2F;&#x2F;        testSoftReference();</span><br><span class="line">        testWeakReference();</span><br><span class="line"></span><br><span class="line">        print();</span><br><span class="line">        &#x2F;&#x2F;手动调用gc</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;调用gc后&quot;);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试强引用</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void testFinalReference() &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        &#x2F;&#x2F;我本机测试时 count为3就会报java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        for (int i &#x3D; 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;每次申请1M</span><br><span class="line">            list.add(new byte[1024 * 1024]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;list: &quot; + list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试软引用</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void testSoftReference() &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        &#x2F;&#x2F;可以随机添加，但最多只会保留两个，其他会被设置为null</span><br><span class="line">        for (int i &#x3D; 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">            byte[] buff &#x3D; new byte[1024 * 1024];</span><br><span class="line">            SoftReference&lt;byte[]&gt; sr &#x3D; new SoftReference&lt;&gt;(buff);</span><br><span class="line">            &#x2F;&#x2F;注意这里是将data置为null之后，否则data是存在强引用关系的，软引用亦是如此。</span><br><span class="line">            buff &#x3D; null;</span><br><span class="line">            list.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;list: &quot; + list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试弱引用</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void testWeakReference() &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        &#x2F;&#x2F;可以随机添加，但最多只会保留两个，其他会被设置为null</span><br><span class="line">        for (int i &#x3D; 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">            byte[] buff &#x3D; new byte[1024 * 1024];</span><br><span class="line">            WeakReference&lt;byte[]&gt; sr &#x3D; new WeakReference&lt;&gt;(buff);</span><br><span class="line">            buff &#x3D; null;</span><br><span class="line">            list.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;list: &quot; + list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void print() &#123;</span><br><span class="line">        for(int i&#x3D;0; i &lt; list.size(); i++)&#123;</span><br><span class="line">            Object obj &#x3D; list.get(i);</span><br><span class="line">            if(obj instanceof SoftReference) &#123;</span><br><span class="line">                System.out.println(&quot;SoftReference: &quot; + i + &quot;&#x3D; &quot; +  ((SoftReference)obj).get());</span><br><span class="line">            &#125; else if(obj instanceof WeakReference) &#123;</span><br><span class="line">                System.out.println(&quot;WeakReference: &quot; + i + &quot;&#x3D; &quot; +  ((WeakReference)obj).get());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(i + &quot;&#x3D; &quot; + obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出 可以发现SoftReference无论是否调用gc总是会有值，WeakReference使用后再调用gc就会设置为null</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用软引用和弱引用的时候，可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</p>
</blockquote>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>　　虚引用是所有类型中最弱的一个。一个持有虚引用的对象和没有引用几乎是一样的，随时可能被垃圾回收器回收，当试图通过虚引用的get()方法取得强引用时，总是会失败。</p>
<p>虚引用必须和引用队列一起使用，它的作用在于检测对象是否已经从内存中删除，跟踪垃圾回收过程。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>回收时间</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>一直存活</td>
<td>所有程序的场景，基本对象，自定义对象等。</td>
</tr>
<tr>
<td>软引用SoftReference</td>
<td>内存不足时会被回收</td>
<td>一般用在对内存非常敏感的资源上，用作缓存的场景比较多，例如：网页缓存、图片缓存</td>
</tr>
<tr>
<td>弱引用WeakReference</td>
<td>只能存活到下一次GC前</td>
<td>生命周期很短的对象，例如ThreadLocal中的Key。</td>
</tr>
<tr>
<td>虚引用</td>
<td>随时会被回收， 创建了可能很快就会被回</td>
<td>业界暂无使用场景， 可能被JVM团队内部用来跟踪JVM的垃圾回收活动</td>
</tr>
</tbody></table>
<h1 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h1><p> 官方对于引用队列类的注释是：</p>
<blockquote>
<p>Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected. 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>
</blockquote>
<p>对于软引用和弱引用和虚引用，我们希望<strong>当一个对象被gc掉的时候通知用户线程，进行额外的处理时</strong>，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SoftReference ref &#x3D; null;</span><br><span class="line">while ((ref &#x3D; (EmployeeRef) q.poll()) !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 清除ref</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SoftReferenceTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class HeapObject &#123;</span><br><span class="line">        byte[] bs &#x3D; new byte[1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReferenceQueue&lt;HeapObject&gt; queue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">        SoftReference&lt;HeapObject&gt; softReference &#x3D; new SoftReference&lt;&gt;(new HeapObject(),queue);</span><br><span class="line"></span><br><span class="line">        List&lt;HeapObject&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (softReference.get() !&#x3D; null) &#123;</span><br><span class="line">                list.add(new HeapObject());</span><br><span class="line">                System.out.println(&quot;list.add&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;---------软引用已被回收---------&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">        Reference&lt;? extends  HeapObject&gt; pollRef &#x3D; queue.poll();</span><br><span class="line">        while (pollRef !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(pollRef);</span><br><span class="line">            System.out.println(pollRef.get());</span><br><span class="line">            pollRef &#x3D; queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置VM options:-Xms5m -Xmx5m -XX:+PrintGC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte[] data &#x3D; new byte[1*1024*1024];</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">SoftReference&lt;byte[]&gt; softReference &#x3D; new SoftReference&lt;&gt;(data,referenceQueue);</span><br><span class="line">data &#x3D; null;</span><br><span class="line">System.out.println(&quot;before:&quot;+softReference.get());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        byte[] temp &#x3D; new byte[3*1024*1024];</span><br><span class="line">        System.out.println(&quot;processing:&quot;+softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">    System.out.println(&quot;after:&quot;+softReference.get());</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">while(referenceQueue.poll()!&#x3D;null)&#123;</span><br><span class="line">    System.out.println(&quot;self:&quot;+softReference);</span><br><span class="line">    softReference.clear();</span><br><span class="line">    softReference &#x3D; null;</span><br><span class="line">    System.out.println(&quot;last:&quot;+softReference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫 </p>
</blockquote>
<h1 id="VisualVM使用"><a href="#VisualVM使用" class="headerlink" title="VisualVM使用"></a>VisualVM使用</h1><p>VisualVM是集成JDK命令行工具和轻量级分析功能的可视化分析工具，设计用于开发和生产时间的使用。它提供了一个可视化界面，用于查看基于Java技术、运行于JVM上的应用程序(Java应用程序)的详细信息。</p>
<p>oracle版本的JDK 6〜8默认在bin目录下的jvisualvm.exe, 从Oracle JDK 9中开始已经不再内置visualvm(openjdk默认也是不包含的), 可以自己下载安装</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>官网下载<a href="https://visualvm.github.io/releases.html">最新版本</a></p>
<p>直接双击打开bin目录下的visualvm.exe</p>
<blockquote>
<p>如果出现cannot find java 1.8 or higher等问题的话, 则需要在etc目录下的visualvm.conf文件中加入jdk的目录，如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visualvm_jdkhome&#x3D;&quot;C:\Users\jone.sun\.jdks\adopt-openjdk-1.8.0_275&quot;</span><br></pre></td></tr></table></figure>

<h3 id="IDEA中使用"><a href="#IDEA中使用" class="headerlink" title="IDEA中使用"></a>IDEA中使用</h3><p>打开IDEA的插件设置页面，搜索VisualVM Launcher，进行安装</p>
<p>![VisualVM Launcher](VisualVM Launcher.png)</p>
<p>完毕后即可通过IDEA启动VisualVM和自己的应用程序, 初次使用可能需要设置下路径:</p>
<p>![VisualVM Launcher Setting](VisualVM Launcher Setting.png)</p>
<p>之后就可以直接使用了![VisualVM Launcher Run](VisualVM Launcher Run.png)</p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="Sampler-抽样器"><a href="#Sampler-抽样器" class="headerlink" title="Sampler(抽样器)"></a>Sampler(抽样器)</h3><p>点击CPU，就可以看到各个类以及方法执行的时间，可以监控哪个类的方法执行时间较长，可以定位到具体的异常方法。</p>
<p>点击内存，很直观的能找到哪个位置可能存在内存泄漏的情况。</p>
<p>通过 Applications 窗口右击应用程序节点来启用”Heap Dump on OOME(在出现 OOME 时生成堆 Dump)”功能，当应用程序出现 OutOfMemory 例外时，VisualVM 将自动生成一个堆转储。</p>
<blockquote>
<p>除了监控本地的应用程序，同样可以远程监控局域网内的服务器</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程5-并发同步器CountDownLatch&amp;CyclicBarrier&amp;Semaphore</title>
    <url>/20200731/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/d2a4479b/</url>
    <content><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>倒计时锁: 一个或多个线程等待其他线程完成操作</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p>
<blockquote>
<p>CountDownLatch可以解决那些一个或者多个线程在执行之前必须依赖于某些必要的前提业务先执行的场景</p>
</blockquote>
 <a id="more"></a>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法，创建一个值为count 的计数器</span><br><span class="line">public CountDownLatch(int count); </span><br><span class="line">​</span><br><span class="line">&#x2F;&#x2F;阻塞当前线程，将当前线程加入阻塞队列, 等待直到count值为0才继续执行</span><br><span class="line">await();</span><br><span class="line">​</span><br><span class="line">&#x2F;&#x2F;和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">await(long timeout, TimeUnit unit);</span><br><span class="line">​</span><br><span class="line">&#x2F;&#x2F;对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程</span><br><span class="line">countDown();</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>从多个统计结果汇总数据进行报表统计</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于聚合所有的统计指标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建计数器，这里需要统计4个指标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在统计新增用户数量&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);<span class="comment">//任务执行需要3秒</span></span><br><span class="line">                map.put(<span class="string">&quot;userNumber&quot;</span>, <span class="number">1</span>);<span class="comment">//保存结果值</span></span><br><span class="line">                countDownLatch.countDown();<span class="comment">//标记已经完成一个任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;统计新增用户数量完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在统计订单数量&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);<span class="comment">//任务执行需要3秒</span></span><br><span class="line">                map.put(<span class="string">&quot;countOrder&quot;</span>, <span class="number">2</span>);<span class="comment">//保存结果值</span></span><br><span class="line">                countDownLatch.countDown();<span class="comment">//标记已经完成一个任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;统计订单数量完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在商品销量&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);<span class="comment">//任务执行需要3秒</span></span><br><span class="line">                map.put(<span class="string">&quot;countGoods&quot;</span>, <span class="number">3</span>);<span class="comment">//保存结果值</span></span><br><span class="line">                countDownLatch.countDown();<span class="comment">//标记已经完成一个任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;统计商品销量完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在总销售额&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);<span class="comment">//任务执行需要3秒</span></span><br><span class="line">                map.put(<span class="string">&quot;countmoney&quot;</span>, <span class="number">4</span>);<span class="comment">//保存结果值</span></span><br><span class="line">                countDownLatch.countDown();<span class="comment">//标记已经完成一个任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;统计销售额完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//主线程等待所有统计指标执行完毕</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();<span class="comment">//记录结束时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;------统计指标全部完成--------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;统计结果为：&quot;</span> + map.toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;任务总执行时间为&quot;</span> + (endTime - startTime) / <span class="number">1000</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>百米赛跑, 当所有选手到达终点, 裁判进行汇总排名</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch cdOrder = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch cdAnswer = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;选手&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在等待裁判发布口令&quot;</span>);</span><br><span class="line">                    cdOrder.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;选手&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;已接受裁判口令&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;选手&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到达终点&quot;</span>);</span><br><span class="line">                    cdAnswer.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;裁判&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;即将发布口令&quot;</span>);</span><br><span class="line">            cdOrder.countDown();</span><br><span class="line">            System.out.println(<span class="string">&quot;裁判&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;已发送口令，正在等待所有选手到达终点&quot;</span>);</span><br><span class="line">            cdAnswer.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;所有选手都到达终点&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;裁判&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;汇总成绩排名&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟并发操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatchTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟的并发量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONCURRENT_NUM = <span class="number">199</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable taskTemp = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> AtomicInteger iCounter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                doSomething(iCounter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        LatchTest latchTest = <span class="keyword">new</span> LatchTest();</span><br><span class="line">        latchTest.startTaskAllInOnce(CONCURRENT_NUM, taskTemp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(AtomicInteger iCounter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 发起请求</span></span><br><span class="line">            <span class="comment">//此处模拟方法</span></span><br><span class="line">            <span class="keyword">int</span> value = iCounter.incrementAndGet();</span><br><span class="line">            System.out.println(System.nanoTime() + <span class="string">&quot; [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] iCounter = &quot;</span> + value);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">startTaskAllInOnce</span><span class="params">(<span class="keyword">int</span> threadNums, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(threadNums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使线程在此等待，当开始门打开时，一起涌入门中</span></span><br><span class="line">                    startGate.await();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 将结束门减1，减到0时，就可以开启结束门了</span></span><br><span class="line">                        endGate.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    ie.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        System.out.println(startTime + <span class="string">&quot; [&quot;</span> + Thread.currentThread() + <span class="string">&quot;] All thread is ready, concurrent going...&quot;</span>);</span><br><span class="line">        <span class="comment">// 因开启门只需一个开关，所以立马就开启开始门</span></span><br><span class="line">        startGate.countDown();</span><br><span class="line">        <span class="comment">// 等等结束门开启</span></span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        System.out.println(endTime + <span class="string">&quot; [&quot;</span> + Thread.currentThread() + <span class="string">&quot;] All thread is completed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>A，B，C的工作都分为两个阶段，A只需要等待B，C各自完成他们工作的第一个阶段就可以执行了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String employeeName,<span class="keyword">long</span> time, CountDownLatch countDownLatch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.employeeName = employeeName;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(employeeName+ <span class="string">&quot; 第一阶段开始准备&quot;</span>);</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">            System.out.println(employeeName+<span class="string">&quot; 第一阶段准备完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">            System.out.println(employeeName+ <span class="string">&quot; 第二阶段开始准备&quot;</span>);</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">            System.out.println(employeeName+<span class="string">&quot; 第二阶段准备完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Employee a = <span class="keyword">new</span> Employee(<span class="string">&quot;A&quot;</span>, <span class="number">3000</span>,countDownLatch);</span><br><span class="line">        Employee b = <span class="keyword">new</span> Employee(<span class="string">&quot;B&quot;</span>, <span class="number">3000</span>,countDownLatch);</span><br><span class="line">        Employee c = <span class="keyword">new</span> Employee(<span class="string">&quot;C&quot;</span>, <span class="number">4000</span>,countDownLatch);</span><br><span class="line"></span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;B,C准备完成&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用，而CyclicBarrier可以实现循环拦截</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>同步屏障</p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>可循环使用的栅栏，所有的线程必须到齐后才能一起通过这个障碍。CyclicBarrier的计数器像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用。通过它可以实现让一组线程等待至某个状态之后再全部同时执行。</p>
<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法</span><br><span class="line">&#x2F;&#x2F;要拦截的线程数 每一阶段结束时要执行的任务</span><br><span class="line"> public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务</span><br><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;让线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务</span><br><span class="line">public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重置</span><br><span class="line">reset();</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>现实生活中我们经常会遇到这样的情景，在进行某个活动前需要等待人全部都齐了才开始。例如吃饭时要等全家人都上座了才动筷子，旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。在JUC包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是CyclicBarrier类。</p>
<ol>
<li>小明、小红、小亮兄妹三个要吃早吃饭，妈妈说先洗手，洗完手之后大家一起吃，等三个人吃完饭，再一起去玩。</li>
</ol>
<blockquote>
<p>在这个例子中第一个barrier状态是大家都洗好手，第二个barrier状态是大家都吃完饭。第二个barrier在第一个barrier释放后可以重用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;开始做下一件事吧...&quot;</span>));</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Child(barrier, <span class="string">&quot;小明&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Child(barrier, <span class="string">&quot;小红&quot;</span>, <span class="number">5</span>));</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Child(barrier, <span class="string">&quot;小亮&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sleep;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(CyclicBarrier cyclicBarrier, String name, <span class="keyword">long</span> sleep)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在洗手...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);<span class="comment">//以睡眠来模拟洗手</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;洗好了，等待其他小朋友洗完...&quot;</span>);</span><br><span class="line"><span class="comment">//                cyclicBarrier.await();</span></span><br><span class="line">                cyclicBarrier.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);      <span class="comment">//以睡眠来模拟吃饭</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;吃好了，等待其他小朋友吃完.....&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多轮赛马</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strides = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Horse</span><span class="params">(CyclicBarrier b)</span> </span>&#123; barrier = b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">//赛马每次随机跑几步</span></span><br><span class="line">                    strides += rand.nextInt(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tracks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getStrides(); i++) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(id);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getStrides</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> strides; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Horse &quot;</span> + id + <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseRace</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINISH_LINE = <span class="number">75</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Horse&gt; horses = <span class="keyword">new</span> ArrayList&lt;Horse&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//打印赛道边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FINISH_LINE; i++) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//打印赛马轨迹</span></span><br><span class="line">        <span class="keyword">for</span>(Horse horse : horses) &#123;</span><br><span class="line">            System.out.println(horse.tracks());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否结束</span></span><br><span class="line">        <span class="keyword">for</span>(Horse horse : horses) &#123;</span><br><span class="line">            <span class="keyword">if</span>(horse.getStrides() &gt;= FINISH_LINE) &#123;</span><br><span class="line">                System.out.println(horse + <span class="string">&quot;won!&quot;</span>);</span><br><span class="line">                exec.shutdownNow();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//休息指定时间再到下一轮</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;barrier-action sleep interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, <span class="keyword">new</span> HorseRace());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            Horse horse = <span class="keyword">new</span> Horse(barrier);</span><br><span class="line">            horses.add(horse);</span><br><span class="line">            exec.execute(horse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在CyclicBarrier的内部定义了一个ReentrantLock的对象，然后再利用这个ReentrantLock对象生成一个Condition的对象。每当一个线程调用CyclicBarrier的await方法时，首先把剩余屏障的线程数减1，然后判断剩余屏障数是否为0：如果不是，利用Condition的await方法阻塞当前线程；如果是，首先利用Condition的signalAll方法唤醒所有线程，最后重新生成Generation对象以实现屏障的循环使用。</p>
</blockquote>
<h2 id="CountDownLatch与CyclicBarrier不同"><a href="#CountDownLatch与CyclicBarrier不同" class="headerlink" title="CountDownLatch与CyclicBarrier不同"></a>CountDownLatch与CyclicBarrier不同</h2><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</li>
<li>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>
<li>CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</li>
</ul>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>控制并发线程数</p>
<h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源</p>
<h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造函数 接受一个整型的数字，表示可用的许可证数量(允许同时运行的线程数目), 也就是最大并发数</span><br><span class="line">public Semaphore(int permits) </span><br><span class="line"></span><br><span class="line">公平（获得锁的顺序与线程启动顺序有关）：</span><br><span class="line">&#x2F;&#x2F;构造函数  获得锁的顺序与线程启动顺序是否有关</span><br><span class="line">public Semaphore(int permits,boolean fair)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取一个许可证</span><br><span class="line">void acquire() throws InterruptedException</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前线程尝试去阻塞的获取1个许可证(不可中断的)</span><br><span class="line">acquireUninterruptibly()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;归还许可证</span><br><span class="line">void release()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尝试获取许可证, 若获取成功返回true，若获取失败返回false</span><br><span class="line">boolean tryAcquire()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回此信号量中当前可用的许可证数</span><br><span class="line">int availablePermits()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回正在等待获取许可证的线程数</span><br><span class="line">int getQueueLength()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是否有线程正在等待获取许可证</span><br><span class="line">boolean hasQueuedThreads()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。<br>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控</p>
<ol>
<li>只有10个线程可以同时访问</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">////请求获得许可，如果有可获得的许可则继续往下执行，许可数减1。否则进入阻塞状态</span></span><br><span class="line">                    s.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;save data&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//释放许可，许可数加1</span></span><br><span class="line">                    s.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模拟学校食堂的窗口打饭过程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义3个打饭窗口</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个学生过来打饭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Student(semaphore, <span class="string">&quot;学生&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Semaphore semaphore, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;进入了餐厅&quot;</span>);</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;拿到了打饭许可&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; 打好了饭，释放这个窗口&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟5000次请求，同时最大200个并发操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发执行的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONCURRENT_COUNT = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicInteger countAtomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//信号量 能保证同时执行的线程最多200个，模拟出稳定的并发量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(CONCURRENT_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//闭锁，实现计数器递减</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_COUNT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取执行许可，当总计未释放的许可数不超过200是，允许通过</span></span><br><span class="line">                    <span class="comment">//否则线程阻塞等待，直到获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    countAtomicInteger.incrementAndGet();</span><br><span class="line">                    <span class="comment">//执行后，释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//闭锁减一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程阻塞，直到闭锁值为0时，继续往下执行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(countAtomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><p>阶段器: java1.7引入，用来解决控制多个线程分阶段共同完成任务的情景问题, 与CyclicBarrier不同的是Phaser可以<strong>动态改变parties计数</strong></p>
<h2 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">arrive() 该方法不作任何等待，直接返回下一阶段的序号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bulkRegister(int parties) 注册多个party。如果当前phaser已经被终止，则该方法无效，并返回负数。如果调用该方法时，onAdvance方法正在执行，则该方法等待其执行完毕。如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该Phaser会被注册到其父Phaser中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每执行一次方法register()就动态添加一个parties值</span><br><span class="line">public int register()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;批量增加parties数量</span><br><span class="line">public int bulkRegister(int parties) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前线程退出，并且使parties值减1</span><br><span class="line">public int arriveAndDeregister()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前线程已经到达屏障，在此等待一段时间，等条件满足后继续向下一个屏障继续执行</span><br><span class="line">public int arriveAndAwaitAdvance()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不作任何等待，直接返回下一阶段的序号</span><br><span class="line">public int arrive()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回</span><br><span class="line">public int awaitAdvance(int phase)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;效果与awaitAdvance(int phase)相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出异常</span><br><span class="line">public int awaitAdvanceInterruptibly(int phase)</span><br><span class="line">        throws InterruptedException </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;效果与awaitAdvanceInterruptibly(int phase)相当，区别在于如果超时则抛出TimeoutException</span><br><span class="line">public int awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 强制让该Phaser进入终止状态。已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响</span><br><span class="line">public void forceTermination()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当一个阶段的所有线程都到达时 , 执行该方法, 此时 phase自动加1(可自行重写)</span><br><span class="line">protected boolean onAdvance(int phase, int registeredParties)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个阶段的所有线程都到达时 , 执行该方法, 此时 phase自动加1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phase</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registeredParties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                System.out.println(<span class="string">&quot;预赛完成&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;初赛完成&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;决赛完成&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return super.onAdvance(phase, registeredParties);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> runnerNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        GamePhaser gamePhaser = <span class="keyword">new</span> GamePhaser();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注册一次表示phaser维护的线程个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gamePhaser.register();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runnerNum;  i++ ) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 注册一次表示phaser维护的线程个数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            gamePhaser.register();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:参加预赛&quot;</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 预赛阶段-----执行这个方法的话会等所有的选手都完成了之后再继续下面的方法</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    gamePhaser.arriveAndAwaitAdvance();</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;选手0&quot;</span>.equals(name)) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + <span class="string">&quot;:退出初赛&quot;</span>);</span><br><span class="line">                        gamePhaser.arriveAndDeregister();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 参加初赛</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:参加初赛&quot;</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 初赛阶段-----执行这个方法的话会等所有的选手都完成了之后再继续下面的方法</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    gamePhaser.arriveAndAwaitAdvance();</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;选手1&quot;</span>.equals(name)) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + <span class="string">&quot;:退出决赛&quot;</span>);</span><br><span class="line">                        gamePhaser.arriveAndDeregister();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 参加决赛</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:参加决赛&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 决赛阶段-----执行这个方法的话会等所有的选手都完成了之后再继续下面的方法</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    gamePhaser.arriveAndAwaitAdvance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;选手&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后续阶段主线程就不参加了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gamePhaser.arriveAndDeregister();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Phaser相对于CyclicBarrier和CountDownLatch的优势主要有两点：</p>
<ul>
<li><p>Phaser可以完成多阶段，而一个CyclicBarrier或者CountDownLatch一般只能控制一到两个阶段的任务；</p>
</li>
<li><p>Phaser每个阶段的任务数量可以控制，而一个CyclicBarrier或者CountDownLatch任务数量一旦确定不可修改。</p>
</li>
</ul>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>交换器: 一个线程在完成一定的事务后想与另一个线程交换数据，则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据</p>
<blockquote>
<p>超过2个线程则是随机发送消息, 不保证可靠性!</p>
</blockquote>
<h2 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。</span><br><span class="line">V exchange(V v)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待另一个线程到达此交换点（除非当前线程被中断或超出了指定的等待时间），然后将给定的对象传送给该线程，并接收该线程的对象</span><br><span class="line">V exchange(V v, long timeout, TimeUnit unit)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 两个线程间的数据交换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Exchanger&lt;String &gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ExecutorService service1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        service1.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程1：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;收到的消息是: &quot;</span> + exchanger.exchange(<span class="string">&quot;你好这里是线程1&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service1.shutdown();</span><br><span class="line"></span><br><span class="line">        ExecutorService service2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        service2.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程2：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;收到的消息是: &quot;</span> + exchanger.exchange(<span class="string">&quot;你好这里是线程2&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service2.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程7-atomic原子变量</title>
    <url>/20200811/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/e45118f/</url>
    <content><![CDATA[<p>在JDK1.5之后，JDK的（concurrent包）并发包里提供了一些类来支持原子操作，如AtomicBoolean,AtomicInteger,AtomicLong都是用原子的方式来更新指定类型的值</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>AtomicInteger、AtomicLong、AtomicBoolean</p>
<p>主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升</p>
<p><img src="atomicInteger.png" alt="基本类"> </p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>这三个类提供的方法几乎一样，AtomicBoolean少一些，因为boolean值就两个值，所以就是来回改，相对的很多增加减少的方法自然就没有了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">* AtomicInteger常见的方法列表 </span><br><span class="line">* @see AtomicInteger#get()             直接返回值 </span><br><span class="line">* @see AtomicInteger#getAndAdd(int)    增加指定的数据，返回变化前的数据 </span><br><span class="line">* @see AtomicInteger#getAndDecrement() 减少1，返回减少前的数据 </span><br><span class="line">* @see AtomicInteger#getAndIncrement() 增加1，返回增加前的数据 </span><br><span class="line">* @see AtomicInteger#getAndSet(int)    设置指定的数据，返回设置前的数据 </span><br><span class="line">*  </span><br><span class="line">* @see AtomicInteger#addAndGet(int)    增加指定的数据后返回增加后的数据 </span><br><span class="line">* @see AtomicInteger#decrementAndGet() 减少1，返回减少后的值 </span><br><span class="line">* @see AtomicInteger#incrementAndGet() 增加1，返回增加后的值 </span><br><span class="line">* @see AtomicInteger#lazySet(int)      仅仅当get时才会set </span><br><span class="line">*  </span><br><span class="line">* @see AtomicInteger#compareAndSet(int, int) 尝试新增后对比，若增加成功则返回true否则返回false </span><br><span class="line">*&#x2F;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;** </span><br><span class="line">* AtomicBoolean主要方法： </span><br><span class="line">* @see AtomicBoolean#compareAndSet(boolean, boolean)  第一个参数为原始值，第二个参数为要修改的新值，若修改成功则返回true，否则返回false </span><br><span class="line">* @see AtomicBoolean#getAndSet(boolean)   尝试设置新的boolean值，直到成功为止，返回设置前的数据 </span><br><span class="line">*&#x2F;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private int count = 0;</span></span><br><span class="line"><span class="comment">//    //非线程安全执行count++</span></span><br><span class="line"><span class="comment">//    public  void increment() &#123;</span></span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public int getCount() &#123;</span></span><br><span class="line"><span class="comment">//        return count;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private volatile int count = 0;</span></span><br><span class="line"><span class="comment">//    //若要线程安全执行执行count++，需要加锁</span></span><br><span class="line"><span class="comment">//    public synchronized void increment() &#123;</span></span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public int getCount() &#123;</span></span><br><span class="line"><span class="comment">//        return count;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LocalDateTime startTime = LocalDateTime.now();</span><br><span class="line">        AtomicIntegerTest atomicIntegerTest = <span class="keyword">new</span> AtomicIntegerTest();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                atomicIntegerTest.increment();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + atomicIntegerTest.getCount() + <span class="string">&quot;花费: &quot;</span> + ChronoUnit.MILLIS.between(startTime, LocalDateTime.now()) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若干线程，只有一个线程修改状态成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBooleanTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicBoolean TEST_BOOLEAN = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute((() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (TEST_BOOLEAN.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我成功了！&quot;</span>);</span><br><span class="line">                &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;我没有成功！已经被修改过了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>AtomicReference、AtomicStampedReference、AtomicMarkableReference</p>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>用于原子地更新某个引用,只提供操作保证某个引用的更新会被原子化,常用封装某个引用会被多个线程频繁更新的场景,保证线程安全性 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相关方法列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicReference#compareAndSet(Object, Object) 对比设置值，参数1：原始值，参数2：修改目标引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicReference#getAndSet(Object) 将引用的目标修改为设置的参数，直到修改成功为止，返回修改前的引用(所以这边需要慎重, 防止无响应)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicReference&lt;String&gt; ATOMIC_REFERENCE = <span class="keyword">new</span> AtomicReference&lt;String&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(Math.abs((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>)));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ATOMIC_REFERENCE.compareAndSet(<span class="string">&quot;abc&quot;</span>, <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>))) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我是线程：&quot;</span> + num + <span class="string">&quot;,我获得了锁进行了对象修改！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>AtomicStampedReference是为了解决ABA问题</p>
<blockquote>
<p>ABA：当某些流程在处理过程中是顺向的，也就是不允许重复处理的情况下，在某些情况下导致一个数据由A变成B，再中间可能经过0-N个环节后变成了A，此时A不允许再变成B了，因为此时的状态已经发生了改变，例如：银行资金里面做一批账目操作，要求资金在80-100元的人，增加20元钱，时间持续一天，也就是后台程序会不断扫描这些用户的资金是否是在这个范围，但是要求增加过的人就不能再增加了，如果增加20后，被人取出10元继续在这个范围，那么就可以无限套现出来，就是ABA问题了，类似的还有抢红包或中奖，比如每天每个人限量3个红包，中那个等级的奖的个数等等。</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>模拟ABA问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.get();</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + <span class="string">&quot;获取值: &quot;</span> + value);</span><br><span class="line">            <span class="comment">// 阻塞1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这边会认为，还是可以从1变为3，实际上atomicInteger已经被其他线程修改了(1-2-1，即ABA)</span></span><br><span class="line">            <span class="comment">//在有些场景中是不允许的</span></span><br><span class="line">            <span class="keyword">boolean</span> isCASSuccess = atomicInteger.compareAndSet(value, <span class="number">3</span>); <span class="comment">// CAS操作</span></span><br><span class="line">            <span class="keyword">if</span> (isCASSuccess) &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;更新成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;更新失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;主操作线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取值: &quot;</span> + value);</span><br><span class="line">            <span class="comment">//把值从1变为2</span></span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">2</span>)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;从 &quot;</span> + value + <span class="string">&quot;更新为 2&quot;</span>);</span><br><span class="line">                <span class="comment">// do sth</span></span><br><span class="line">                value = atomicInteger.get();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取新值: &quot;</span> + value);</span><br><span class="line">                <span class="comment">//再把值从2变为1</span></span><br><span class="line">                <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;从 &quot;</span> + value + <span class="string">&quot;更新为 1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;干扰线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        main.start();</span><br><span class="line">        other.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用AtomicStampedReference解决ABA问题, 内部使用Pair来存储元素值及其版本号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicInteger = <span class="keyword">new</span> AtomicStampedReference(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.getReference();</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicInteger.getStamp();</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + <span class="string">&quot;获取值: &quot;</span> + value + <span class="string">&quot; 版本为: &quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 阻塞1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这边会认为，还是可以从1变为3，实际上atomicInteger已经被其他线程修改了(1-2-1，即ABA)</span></span><br><span class="line">            <span class="comment">//在有些场景中是不允许的</span></span><br><span class="line">            <span class="keyword">boolean</span> isCASSuccess = atomicInteger.compareAndSet(value, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>); <span class="comment">// CAS操作</span></span><br><span class="line">            <span class="keyword">if</span> (isCASSuccess) &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;更新成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;更新失败, 版本为： &quot;</span> + atomicInteger.getStamp());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;主操作线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.getReference();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取值: &quot;</span> + value);</span><br><span class="line">            <span class="comment">//把值从1变为2</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicInteger.getStamp();</span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;从 &quot;</span> + value + <span class="string">&quot;更新为 2&quot;</span>);</span><br><span class="line">                <span class="comment">// do sth</span></span><br><span class="line">                value = atomicInteger.getReference();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取新值: &quot;</span> + value);</span><br><span class="line">                <span class="comment">//再把值从2变为1</span></span><br><span class="line">                stamp = atomicInteger.getStamp();</span><br><span class="line">                <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">1</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;从 &quot;</span> + value + <span class="string">&quot;更新为 1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;干扰线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        main.start();</span><br><span class="line">        other.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicMarkableReference可以理解为上面AtomicStampedReference的简化版，就是不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。</p>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p>Atomic的数组要求不允许修改长度等，不像集合类那么丰富的操作，不过它可以让你的数组上每个元素的操作绝对安全的，也就是它细化的力度还是到数组上的元素，为你做了二次包装</p>
<h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><p>示例</p>
<p>100个线程并发，每10个线程会被并发修改数组中的一个元素，也就是数组中的每个元素会被10个线程并发修改访问，每次增加原始值的大小，此时运算完的结果看最后输出的敲好为原始值的11倍数，和我们预期的一致，如果不是线程安全那么这个值什么都有可能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常见的方法列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#addAndGet(int, int) 执行加法，第一个参数为数组的下标，第二个参数为增加的数量，返回增加后的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#compareAndSet(int, int, int) 对比修改，参数1：数组下标，参数2：原始值，参数3，修改目标值，修改成功返回true否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#decrementAndGet(int) 参数为数组下标，将数组对应数字减少1，返回减少后的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#incrementAndGet(int) 参数为数组下标，将数组对应数字增加1，返回增加后的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#getAndAdd(int, int) 和addAndGet类似，区别是返回值是变化前的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#getAndDecrement(int) 和decrementAndGet类似，区别是返回变化前的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#getAndIncrement(int) 和incrementAndGet类似，区别是返回变化前的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerArray#getAndSet(int, int) 将对应下标的数字设置为指定值，第二个参数为设置的值，返回是变化前的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerArray ATOMIC_INTEGER_ARRAY = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread []threads = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> result = ATOMIC_INTEGER_ARRAY.addAndGet(index, index + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程编号为：&quot;</span> + threadNum + <span class="string">&quot; , 对应的原始值为：&quot;</span> + (index + <span class="number">1</span>) + <span class="string">&quot;，增加后的结果为：&quot;</span> + result);</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&gt;\n执行已经完成，结果列表：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ATOMIC_INTEGER_ARRAY.length() ; i++) &#123;</span><br><span class="line">            System.out.println(ATOMIC_INTEGER_ARRAY.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h3><p>AtomicLongArray其实和AtomicIntegerArray操作方法类似，最大区别就是它操作的数据类型是long</p>
<h3 id="AtomicRerenceArray"><a href="#AtomicRerenceArray" class="headerlink" title="AtomicRerenceArray"></a>AtomicRerenceArray</h3><p>AtomicRerenceArray类似，只是它方法只有两个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AtomicReferenceArray#compareAndSet(int, Object, Object)   </span><br><span class="line">参数1：数组下标；  </span><br><span class="line">参数2：修改原始值对比；  </span><br><span class="line">参数3：修改目标值   </span><br><span class="line">修改成功返回true，否则返回false  </span><br><span class="line">  </span><br><span class="line">AtomicReferenceArray#getAndSet(int, Object)   </span><br><span class="line">参数1：数组下标  </span><br><span class="line">参数2：修改的目标  </span><br><span class="line">修改成功为止，返回修改前的数据  </span><br></pre></td></tr></table></figure>

<h2 id="属性原子修改器-Updater"><a href="#属性原子修改器-Updater" class="headerlink" title="属性原子修改器(Updater)"></a>属性原子修改器(Updater)</h2><p>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</p>
<p>外部的Updater可以对对象的属性本身的修改提供类似Atomic的操作，也就是它对这些普通的属性的操作是并发下安全的。它算是Atomic的系列的一个扩展，Atomic系列是为你定义好的一些对象，你可以使用，<strong>但是如果是别人已经在使用的对象会原先的代码需要修改为Atomic系列，此时若全部修改类型到对应的对象相信很麻烦，因为牵涉的代码会很多</strong>，此时java提供一个外部的Updater可以对对象的属性本身的修改提供类似Atomic的操作，也就是它对这些普通的属性的操作是并发下安全的。实现方式是通过反射找到属性，对属性进行操作，但是并不是设置accessable，所以必须是可见的属性才能操作</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li><p>限制1：操作的目标不能是static类型，前面说到unsafe的已经可以猜测到它提取的是非static类型的属性偏移量，如果是static类型在获取时如果没有使用对应的方法是会报错的，而这个Updater并没有使用对应的方法。</p>
</li>
<li><p>限制2：操作的目标不能是final类型的，因为final根本没法修改。</p>
</li>
<li><p>限制3：必须是volatile类型的数据，也就是数据本身是读一致的。</p>
</li>
<li><p>限制4：属性必须对当前的Updater所在的区域是可见的，也就是private如果不是当前类肯定是不可见的，protected如果不存在父子关系也是不可见的，default如果不是在同一个package下也是不可见的</p>
</li>
</ul>
<h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>示例</p>
<p>只有一个线程可以对数据进行修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> intValue = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以直接访问对应的变量，进行修改和处理</span></span><br><span class="line"><span class="comment">     * 条件：要在可访问的区域内，如果是private或挎包访问default类型以及非父亲类的protected均无法访问到</span></span><br><span class="line"><span class="comment">     * 其次访问对象不能是static类型的变量（因为在计算属性的偏移量的时候无法计算），也不能是final类型的变量（因为根本无法修改），必须是普通的成员变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 方法（说明上和AtomicInteger几乎一致，唯一的区别是第一个参数需要传入对象的引用）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#addAndGet(Object, int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#compareAndSet(Object, int, int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#decrementAndGet(Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#incrementAndGet(Object)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#getAndAdd(Object, int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#getAndDecrement(Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#getAndIncrement(Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AtomicIntegerFieldUpdater#getAndSet(Object, int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;A&gt; ATOMIC_INTEGER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(A.class, &quot;intValue&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(ATOMIC_INTEGER_UPDATER.compareAndSet(a, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我是线程：&quot;</span> + num + <span class="string">&quot; 我对对应的值做了修改！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AtomicLongFieldUpdater"><a href="#AtomicLongFieldUpdater" class="headerlink" title="AtomicLongFieldUpdater"></a>AtomicLongFieldUpdater</h3><p>AtomicLongFieldUpdater区别在于它所操作的数据是long类型</p>
<h3 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h3><p>AtomicReferenceFieldUpdater方法较少，主要是compareAndSet以及getAndSet两个方法的使用，它的定义比数字类型的多一个属性的类型，因为引用的是一个对象，对象本身也有一个类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class A &#123;  </span><br><span class="line">    volatile String stringValue &#x3D; &quot;abc&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">AtomicReferenceFieldUpdater &lt;A ,String&gt;ATOMIC_REFERENCE_FIELD_UPDATER &#x3D; AtomicReferenceFieldUpdater.newUpdater(A.class, String.class, &quot;stringValue&quot;);  </span><br></pre></td></tr></table></figure>

<h2 id="java8新增-原子类型累加器"><a href="#java8新增-原子类型累加器" class="headerlink" title="java8新增-原子类型累加器"></a>java8新增-原子类型累加器</h2><p>java8之后，又新增了DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder，这些类是对AtomicLong等类的改进(在某些场景下，注意并不是完全替代)，比如LongAccumulator与LongAdder在高并发环境下比AtomicLong更高效，代价是消耗更多的内存空间。</p>
<p><img src="striped64.png" alt="striped64"></p>
<h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>与AtomicLong相比，LongAdder更多地用于收集统计数据，而不是细粒度的同步控制。而且，LongAdder只提供了add(long)和decrement()方法，想要使用cas方法还是要选择AtomicLong。低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那<br>LongAdder可能更合适</p>
<h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><p>LongAccumulator是LongAdder的增强版。LongAdder只能针对数值的进行加减运算，而<br>LongAccumulator提供了自定义的函数操作。通过LongBinaryOperator，可以自定义对入参的任意操作，并返回结果（LongBinaryOperator接收2个long作为参数，并返回1个long）</p>
<p>LongAccumulator内部原理和LongAdder几乎完全一样，都是利用了父类Striped64的longAccumulate方法</p>
<h3 id="DoubleAdder和DoubleAccumulator"><a href="#DoubleAdder和DoubleAccumulator" class="headerlink" title="DoubleAdder和DoubleAccumulator"></a>DoubleAdder和DoubleAccumulator</h3><p>从名字也可以看出，DoubleAdder和DoubleAccumulator用于操作double原始类型。<br>与LongAdder的唯一区别就是，其内部会通过一些方法，将原始的double类型，转换为long类型，其<br>余和LongAdder完全一样</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式-责任链模式</title>
    <url>/20200927/java/designPatterns/7e2ffbc9/</url>
    <content><![CDATA[<blockquote>
<p>设计模式是为了可扩展性，不要为了使用设计模式而使用</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>责任链模式(Chain of Responsibility): 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>
</blockquote>
<p>像我们日常使用的spring框架中的拦截器和过滤器都是使用了该模式，每次请求都会经过一系列的拦截，只有当前面的拦截通过后才会进入下一步</p>
<p>责任链模式包含如下角色:</p>
<ul>
<li>Handler: 抽象处理者，处理请求的接口类包含抽象处理方法和一个后继连接</li>
<li>Concrete Handler: 实现抽象处理者的处理类，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</li>
<li>Client: 创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li>
</ul>
<p>抽象的处理者实现三个职责：</p>
<ul>
<li>一是定义一个请求的处理方法handleMessage，唯一对外开放的方法；</li>
<li>二是定义一个链的编排方法setNext，设置下一个处理者；</li>
<li>三是定义了具体的请求者必须实现的两个方法：定义自己能够处理的级别getHandlerLevel和具体的处理任务echo。</li>
</ul>
<p>注意事项：</p>
<p>链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能</p>
<p>JavaEE的Servlet规范定义的Filter就是一种责任链模式，它不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter，这种模式不但允许一个Filter自行决定处理ServletRequest和ServletResponse，还可以“伪造”ServletRequest和ServletResponse以便让下一个Filter处理，能实现非常复杂的功能</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>审批流程、多轮面试等需要多级处理的场景都适合使用责任链模式来实现，可解决大量的分支判断造成难维护、灵活性差的问题</p>
 <a id="more"></a>

<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ol>
<li>有固定上下级关系的带等级和处理范围的, 如公司的请假审批</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义等级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LevelEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通员工</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;普通员工&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小组长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GROUP_MANAGER(<span class="number">2</span>, <span class="string">&quot;小组长&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 经理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    COMMON_MANAGER(<span class="number">3</span>, <span class="string">&quot;经理&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BOSS(<span class="number">3</span>, <span class="string">&quot;老板&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 职位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String office;</span><br><span class="line"></span><br><span class="line">    LevelEnum(Integer level, String office) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.office = office;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOffice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> office;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LevelEnum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;level=&quot;</span> + level +</span><br><span class="line">                <span class="string">&quot;, office=&#x27;&quot;</span> + office + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请假人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BaseStaff staff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请假内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请假天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer needDays;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequest</span><span class="params">(BaseStaff staff, String content, String type, Integer needDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.staff = staff;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.needDays = needDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseStaff <span class="title">getStaff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> staff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaff</span><span class="params">(BaseStaff staff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.staff = staff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNeedDays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> needDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNeedDays</span><span class="params">(Integer needDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.needDays = needDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LeaveRequest&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, type=&#x27;&quot;</span> + type + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, needDays=&quot;</span> + needDays +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义响应类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始默认状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer STATUS_OF_PASS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer STATUS_OF_REFUSE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer resultStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String resultContent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resultStatus = DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getResultStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultStatus</span><span class="params">(Integer resultStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultStatus = resultStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResultContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultContent</span><span class="params">(String resultContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultContent = resultContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LeaveResponse&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, resultStatus=&quot;</span> + resultStatus +</span><br><span class="line">                <span class="string">&quot;, resultContent=&#x27;&quot;</span> + resultContent + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义员工基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStaff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LevelEnum level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BaseManagerStaff superior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseStaff</span><span class="params">(String name, LevelEnum level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请假</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">(LeaveRequest request, LeaveResponse leaveResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (superior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//向上级请假</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s 向 %s 发起请假: %s &quot;</span>, getShowName(), superior.getShowName(), request.toString()));</span><br><span class="line">            superior.doHandle(request, leaveResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;%s 没有上级，无法审批: %s &quot;</span>, getShowName(), request.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LevelEnum <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(LevelEnum level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseManagerStaff <span class="title">getSuperior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> superior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuperior</span><span class="params">(BaseManagerStaff superior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.superior = superior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShowName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, level=&quot;</span> + level +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义管理层员工基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseManagerStaff</span> <span class="keyword">extends</span> <span class="title">BaseStaff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseManagerStaff</span><span class="params">(String name, LevelEnum level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批请假</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(LeaveRequest request, LeaveResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批流程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">approval</span><span class="params">(LeaveRequest request, LeaveResponse response, Predicate&lt;LeaveRequest&gt; predicate)</span> </span>&#123;</span><br><span class="line">        response.setName(getName());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(request.getType())) &#123;</span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;当前审批人为 %s&gt;&gt;申请未指定类型, 驳回：%s&quot;</span>, getShowName(), request.toString()));</span><br><span class="line">            response.setResultStatus(LeaveResponse.STATUS_OF_REFUSE);</span><br><span class="line">            response.setResultContent(<span class="string">&quot;申请未指定类型, 驳回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(request)) &#123;</span><br><span class="line">            response.setResultStatus(LeaveResponse.STATUS_OF_PASS);</span><br><span class="line">            response.setResultContent(<span class="string">&quot;同意&quot;</span>);</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;当前审批人为 %s&gt;&gt;审批通过：%s&quot;</span>, getShowName(), request.toString()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BaseManagerStaff managerStaff = getSuperior();</span><br><span class="line">            <span class="keyword">if</span> (managerStaff != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;当前审批人为 %s&gt;&gt;得由%s审批：%s&quot;</span>, getShowName(), managerStaff.getShowName(), request.toString()));</span><br><span class="line">                managerStaff.doHandle(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;当前审批人为 %s&gt;&gt;没有上级, 无需审批, 直接通过：%s&quot;</span>, getShowName(), request.toString()));</span><br><span class="line">                response.setResultStatus(LeaveResponse.STATUS_OF_PASS);</span><br><span class="line">                response.setResultContent(<span class="string">&quot;直接同意&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义普通员工</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalStaff</span> <span class="keyword">extends</span> <span class="title">BaseStaff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalStaff</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, LevelEnum.NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupManager</span> <span class="keyword">extends</span> <span class="title">BaseManagerStaff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupManager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, LevelEnum.GROUP_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(LeaveRequest request, LeaveResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3天内的请假请求，由小组长审批</span></span><br><span class="line">        approval(request, response, request1 -&gt; request1.getNeedDays() &lt;= <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonManager</span> <span class="keyword">extends</span> <span class="title">BaseManagerStaff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonManager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, LevelEnum.COMMON_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(LeaveRequest request, LeaveResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//5天内的请假请求，由经理审批</span></span><br><span class="line">        approval(request, response, request1 -&gt; request1.getNeedDays() &lt;= <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义老板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BossManager</span> <span class="keyword">extends</span> <span class="title">BaseManagerStaff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BossManager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, LevelEnum.BOSS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">(LeaveRequest request, LeaveResponse leaveResponse)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//老板 请假自己申请即可</span></span><br><span class="line"><span class="comment">//        super.leave(request, leaveResponse);</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前审批人为 %s&gt;&gt;没有上级, 无需审批, 直接通过：%s&quot;</span>, getShowName(), request.toString()));</span><br><span class="line">        leaveResponse.setResultStatus(LeaveResponse.STATUS_OF_PASS);</span><br><span class="line">        leaveResponse.setResultContent(<span class="string">&quot;直接同意&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(LeaveRequest request, LeaveResponse response)</span> </span>&#123;</span><br><span class="line">        response.setName(getName());</span><br><span class="line">        <span class="keyword">if</span> (request.getNeedDays() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;当前审批人为 %s&gt;&gt;申请未指定类型, 驳回：%s&quot;</span>, getShowName(), request.toString()));</span><br><span class="line">            response.setResultStatus(LeaveResponse.STATUS_OF_REFUSE);</span><br><span class="line">            response.setResultContent(<span class="string">&quot;请这么多天, 驳回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5天以上的请假请求，由经理审批</span></span><br><span class="line">        approval(request, response, request1 -&gt; request1.getNeedDays() &gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化公司 人员</span></span><br><span class="line">        BossManager bossManager1 = <span class="keyword">new</span> BossManager(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        CommonManager commonManager = <span class="keyword">new</span> CommonManager(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        GroupManager groupManager1 = <span class="keyword">new</span> GroupManager(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        NormalStaff normalStaff1 = <span class="keyword">new</span> NormalStaff(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置上下级关系</span></span><br><span class="line">        normalStaff1.setSuperior(groupManager1);</span><br><span class="line">        groupManager1.setSuperior(commonManager);</span><br><span class="line">        commonManager.setSuperior(bossManager1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通员工请假</span></span><br><span class="line">        leave(normalStaff1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小组长请假</span></span><br><span class="line">        leave(groupManager1, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//经理请假</span></span><br><span class="line">        leave(commonManager, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//老板请假</span></span><br><span class="line">        leave(bossManager1, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">(BaseStaff staff, Integer needDays)</span> </span>&#123;</span><br><span class="line">        LeaveResponse leaveResponse1 = <span class="keyword">new</span> LeaveResponse();</span><br><span class="line">        staff.leave(<span class="keyword">new</span> LeaveRequest(staff, <span class="string">&quot;国庆请假&quot;</span> + needDays + <span class="string">&quot;天&quot;</span>, <span class="string">&quot;事假&quot;</span>, needDays), leaveResponse1);</span><br><span class="line">        System.out.println(staff.getName() + <span class="string">&quot;&gt;&gt;国庆请假&quot;</span> + needDays + <span class="string">&quot;天结果：&quot;</span> + leaveResponse1.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有固定的上下级管理, 处理者处理好后，由专门的chain管理类继续交由下一个处理者处理，如拦截器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(String token, String name, String content, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.token = token;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIp</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyRequest&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;token=&#x27;&quot;</span> + token + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ip=&#x27;&quot;</span> + ip + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义响应类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer STATUS_OF_DEFAULT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer STATUS_OF_PASS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer STATUS_OF_REFUSE = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String reason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResponse</span><span class="params">(MyRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS_OF_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRequest <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(MyRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReason</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(Integer status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyResponse&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;request=&quot;</span> + request +</span><br><span class="line">                <span class="string">&quot;, reason=&#x27;&quot;</span> + reason + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义拦截器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//利用java8默认方法的特性，将是否进入下一阶段统一控制</span></span><br><span class="line">        doHandle(request, response);</span><br><span class="line">        <span class="keyword">return</span> MyResponse.STATUS_OF_PASS.equals(response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(MyRequest request, MyResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义权限拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getToken() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setStatus(MyResponse.STATUS_OF_REFUSE);</span><br><span class="line">            response.setReason(<span class="string">&quot;权限验证不予通过,未传递token&gt;&gt;&quot;</span> + request.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;权限验证通过&gt;&gt;&quot;</span> + request.toString());</span><br><span class="line">            response.setStatus(MyResponse.STATUS_OF_PASS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义白名单拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteListInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里测试方便 判断是否内网用最简单的方法(项目中不要这么判断)</span></span><br><span class="line">        <span class="keyword">if</span> (request.getIp() == <span class="keyword">null</span> || !request.getIp().startsWith(<span class="string">&quot;192.168.&quot;</span>)) &#123;</span><br><span class="line">            response.setStatus(MyResponse.STATUS_OF_REFUSE);</span><br><span class="line">            response.setReason(<span class="string">&quot;白名单验证不予通过,非内网访问&gt;&gt;&quot;</span> + request.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;白名单验证通过&gt;&gt;&quot;</span> + request.toString());</span><br><span class="line">            response.setStatus(MyResponse.STATUS_OF_PASS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义日志拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;日志记录成功&gt;&gt;&quot;</span> + request.toString());</span><br><span class="line">        response.setStatus(MyResponse.STATUS_OF_PASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义拦截器责任链</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InterceptorChain <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">        interceptors.add(interceptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行过滤</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyResponse <span class="title">submit</span><span class="params">(MyRequest request)</span> </span>&#123;</span><br><span class="line">        MyResponse myResponse = <span class="keyword">new</span> MyResponse(request);</span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.handle(request, myResponse)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line"></span><br><span class="line">        interceptorChain.addInterceptor(<span class="keyword">new</span> AuthInterceptor())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> WhiteListInterceptor())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> LogInterceptor());</span><br><span class="line"></span><br><span class="line">        MyResponse myResponse = interceptorChain.submit(<span class="keyword">new</span> MyRequest(<span class="string">&quot;xxxxxx&quot;</span>, <span class="string">&quot;第一个请求&quot;</span>,<span class="string">&quot;测试请求内容&quot;</span>, <span class="string">&quot;192.168.1.1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果: &quot;</span> + myResponse);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MyResponse myResponse1 = interceptorChain.submit(<span class="keyword">new</span> MyRequest(<span class="keyword">null</span>, <span class="string">&quot;第二个请求&quot;</span>,<span class="string">&quot;测试请求内容&quot;</span>, <span class="string">&quot;192.168.1.1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;没有传递token执行结果: &quot;</span> + myResponse1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MyResponse myResponse2 = interceptorChain.submit(<span class="keyword">new</span> MyRequest(<span class="string">&quot;xxxxxx&quot;</span>, <span class="string">&quot;第三个请求&quot;</span>,<span class="string">&quot;测试请求内容&quot;</span>, <span class="string">&quot;111.168.1.1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;非内网执行结果: &quot;</span> + myResponse2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>designPatterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>designPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-SpringInitializr说明</title>
    <url>/20201207/java/springboot/c778234/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>idea 可以通过Spring Initializr创建SpringBoot/SpringCloud项目并勾选引用第三方组件，阿里巴巴也发行了类似的插件Alibaba Java Initializr(可在插件市场搜索安装)</p>
<p><img src="spring-initializr.png" alt="spring-initializr"></p>
<p>可以看到分类还是不少的，下面我就逐一分享下每个分类及可选择的组件和使用场景</p>
<blockquote>
<p>idea版本基于2020.2, 不同idea可能会有出入，Spring Boot基于2.4.0，更详细的见<a href="https://start.spring.io/">https://start.spring.io/</a></p>
</blockquote>
 <a id="more"></a>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Spring Initializr具有以下模块：</p>
<ul>
<li><p>Developer Tools 开发工具</p>
<ul>
<li><a href="https://arthas.gitee.io/index.html">Arthas</a>: Arthas 是Alibaba开源的Java诊断工具，允许开发者在不修改代码或重启服务器的基础上，实现Java应用程序的运行时诊断，深受开发者喜爱</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#using-boot-devtools">Spring Boot DevTools</a>: Provides fast application restarts, LiveReload, and configurations for enhanced development experience. 提供快速的应用程序重启、实时重新加载、配置，以增强开发体验。</li>
<li><a href="https://projectlombok.org/">Lombok</a>: Java annotation library which helps to reduce boilerplate code. 有助于减少样板代码的Java注释库。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#configuration-metadata-annotation-processor">Spring Configuration Processor</a>: Generate metadata for developers to offer contextual help and “code completion” when working with custom configuration keys(ex.application.properties/.yml files). 生成元数据 供开发人员在使用自定义配置键 (例如，application.properties/.yml)时提供上下文帮助和”代码补全”。</li>
</ul>
</li>
<li><p>web</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-developing-web-applications">Spring Web</a>: Build web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as default embedded container. 使用Spring MVC构建web(包含RESTful)应用程序。使用Apache Tomcat作为默认的嵌入式容器。<ul>
<li><a href="https://spring.io/guides/gs/rest-service/">Building a RESTful Web Service</a> </li>
<li><a href="https://spring.io/guides/gs/serving-web-content/">Serving Web Content with Spring MVC</a></li>
<li><a href="https://spring.io/guides/tutorials/bookmarks/">Building REST services with Spring</a></li>
</ul>
</li>
<li>Spring Reactive Web: Build reactive web applications with Spring WebFlux and Netty. 使用Spring WebFlux和Netty构建响应式Web应用程序。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#howto-use-exposing-spring-data-repositories-rest-endpoint">Rest Repositories</a>: Exposing Spring Data repositories over REST via Spring Data REST. 使用Spring Data REST以REST形式暴露Spring Data存储库。<ul>
<li><a href="https://spring.io/guides/gs/accessing-data-rest/">Accessing JPA Data with REST</a></li>
<li><a href="https://spring.io/guides/gs/accessing-neo4j-data-rest/">Accessing Neo4j Data with REST</a></li>
<li><a href="https://spring.io/guides/gs/accessing-mongodb-data-rest/">Accessing MongoDB Data with REST</a></li>
</ul>
</li>
<li>Spring Session: Provides an API and implementations for managing user session information. 提供用于管理用户会话信息的API和实现。</li>
<li>Rest Repositories HAL Explorer: Browsing Spring Data REST repositories in your browser. 在浏览器中浏览Spring Data REST仓库。</li>
<li>Rest Repositories HAL Browser: Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.2.0-M1 Browsing Spring Data REST repositories in you browser. 在浏览器中浏览Spring Data REST仓库。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-spring-hateoas">Spring HATEOAS</a>: Eases the creation of RESTful APIs that follow the HATEOAS principle when working with Spring / Spring  MVC. 在使用Spring/Spring MVC时，轻松创建遵循HATEOAS原理的RESTful API。<ul>
<li><a href="https://spring.io/guides/gs/rest-hateoas/">Building a Hypermedia-Driven RESTful Web Service</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-webservices">Spring Web Services</a>: Facilitates contract-first SOAP development. Allows for the creation of flexible web using one of the many ways to manipulate XML payloads. 促进约定优先的SOAP开发，允许使用多种操作XML有效负载的方式之一来创建灵活的Web服务。<ul>
<li><a href="https://spring.io/guides/gs/producing-web-service/">Producing a SOAP web service</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-jersey">Jersey</a>: Framework for developing RESTful Web Services in Java that provides support for JAX-RS APIs. 用Java开发RESTful Web服务的框架，该框架提供对JAX-RS API的支持。</li>
<li><a href="https://vaadin.com/spring">Vaadin</a>: Java framework for building rich client apps based on Web componens. Java框架，用于基于Web组件构建富客户端应用程序。<ul>
<li><a href="https://spring.io/guides/gs/crud-with-vaadin/">Creating CRUD UI with Vaadin</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Template Engines 模板引擎</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-spring-mvc-template-engines">Thymeleaf</a>: A modern server-side Java template engine for both web and standlone environments. Allows HTML to be correctly displayed in borwsers and as static prototypes. 适用于Web和独立环境的现代服务器端Java模板引擎。允许HTML在浏览器中正确显示为静态原型。<ul>
<li><a href="https://spring.io/guides/gs/handling-form-submission/">Handling Form Submission</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-spring-mvc-template-engines">Apache Freemarker</a>: Java library to generate text output (HTML web pages, e-mails, configuration files, source, etc.) based on templates and changing data. 用于根据模板和更改的数据生成文本输出(HTML网页、电子邮件、配置文件、源代码等)的Java库。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-spring-mvc-template-engines">Mustache</a>: login-less Templates. There are no if statements, else clauses, or for loops. Instead there are only tags. 无逻辑的模板。没有if语句、else字句或者for循环。相反，只有标签。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-spring-mvc-template-engines">Groovy Templates</a>: Groovy templating engine. Groovy模板引擎。</li>
</ul>
</li>
<li><p>Security</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-security">Spring Security</a>: Highly customizable authentication and access-control framework for Spring applications. 用于Spring应用程序的高度可定制的身份验证和访问控制框架。<ul>
<li><a href="https://spring.io/guides/gs/securing-web/">Securing a Web Application</a></li>
<li><a href="https://spring.io/guides/tutorials/spring-boot-oauth2/">Spring Boot and OAuth2</a></li>
<li><a href="https://spring.io/guides/gs/authenticating-ldap/">Authenticating a User with LDAP</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-security-oauth2-client">OAuth2 Client</a>: Spring Boot integration for Spring Security’s OAuth2/OpenId Connect client features. 用于Spring Security的OAuth2/OpenId Connect 客户端功能的Spring Boot集成。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-security-oauth2-server">OAuth2 Resource Server</a>: Spring Boot integration for Spring Security’s QAuth2 resource server features. 用于Spring Security的OAuth2资源服务器功能的Spring Boot集成。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-ldap">Spring LDAP</a>: Makes it easier to build Spring based applications that use the Lightweight Directory Access Protocol. 让使用轻量级目录访问协议的基于Spring的应用程序的构建更加容易。</li>
<li>Okta: Okta specific configuration for Spring Security/Spring Boot OAuth2 features. Enable your Spring Boot application to work with Okta via OAuth 2.0/OIDC. Okta特定于Spring Security/Spring Boot OAuth2功能的配置。使您的Spring Boot应用程序能够通过OAuth 2.0/OIDC与Okta一起使用。<ul>
<li><a href="https://github.com/okta/samples-java-spring/tree/master/okta-hosted-login">Okta-Hosted Login Page Example</a></li>
<li><a href="https://github.com/okta/samples-java-spring/tree/master/custom-login">Custom Login Page Example</a></li>
<li><a href="https://github.com/okta/samples-java-spring/tree/master/resource-server">Okta Spring Security Resource Server Example</a></li>
<li><a href="https://github.com/okta/okta-spring-boot#readme">Okta Spring Boot documentation</a></li>
</ul>
</li>
</ul>
</li>
<li><p>SQL</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-sql">JDBC API</a>: Database Connectivity API that defines how a client may connect and query a database. 数据库连接API，定义客户端如何连接和查询数据库。<ul>
<li><a href="https://spring.io/guides/gs/relational-data-access/">Accessing Relational Data using JDBC with Spring</a></li>
<li><a href="https://spring.io/guides/gs/managing-transactions/">Managing Transactions</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-jpa-and-spring-data">Spring Data JPA</a>: Persist data in SQL stores with Java Persistence API using Spring Data and Hibernate. 通过Java Persistence API 使用Spring Data和Hibernate在SQL存储中持久化数据。<ul>
<li><a href="https://spring.io/guides/gs/accessing-data-jpa/">Accessing Data with JPA</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#reference">Spring Data JDBC</a>: Persist data in SQL stores with plain JDBC using Spring Data. 使用Spring Data时，通过纯JDBC在SQL存储中持久化数据。<ul>
<li><a href="https://github.com/spring-projects/spring-data-examples/tree/master/jdbc/basics">Using Spring Data JDBC</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/spring-boot-features.html#boot-features-r2dbc">Spring Data R2DBC</a>: Provides Reactive Relational Database Connectivity to persist data in SQL stores using Spring Data in reactive applications. 提供响应式关系型数据库连接。以在响应式应用程序中使用Spring Data将数据存储在SQL存储中。<ul>
<li><a href="https://spring.io/guides/gs/accessing-data-r2dbc/">Accessing data with R2DBC</a></li>
<li><a href="https://r2dbc.io/">R2DBC Homepage</a></li>
</ul>
</li>
<li><a href="https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">MyBatis Framework</a>: Persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or annotations. 持久化框架，支持自定义SQL，存储过程和高级映射。Mybatis使用XML描述符或注解将对象与存储过程或SQL语句耦合。<ul>
<li><a href="https://github.com/mybatis/spring-boot-starter/wiki/Quick-Start">MyBatis Quick Start</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#howto-execute-liquibase-database-migrations-on-startup">Liquibase Migration</a>: Liquibase database migration and source control library. Liquibase数据库迁移和源代码控制库。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#howto-execute-flyway-database-migrations-on-startup">Flyway Migration</a>: Version control for your database so you can migrate from any version (incl.an empty database) to the latest version of the schema. 数据库的版本控制，您可以从任何版本(包括空数据库)迁移到架构的最新版本。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-jooq">JOOQ Access Layer</a>: Generate Java code from your database and build type safe SQL queries through a fluent API. 从数据库中生成Java代码，并通过流畅的API构建类型安全的SQL查询。</li>
<li>IBM DB2 Driver: A JDBC driver that provides access to IBM DB2. 提供对IBM DB2访问的JDBC驱动程序。</li>
<li>Apache Derby Database: An open source relational database implemented entirely in Java. 一个完全用Java实现的开源关系型数据库。</li>
<li>H2 Database: Provides a fast in-memory database that supports JDBC API and R2DBC access, with a small (2mb) footprint. Supports embedded and server modes as well as a browser based console application. 提供一个快速的内存数据库，该数据库支持JDBC API和R2DBC访问，并且占用空间很小(2mb)。支持嵌入式和服务器模式以及基于浏览器的控制台应用程序。</li>
<li>HyperSQL Database: Lightweight 100% Java SQL Database Engine. 轻量级100% Java SQL数据库引擎。</li>
<li>MS SQL Server Driver: A JDBC and R2DBC driver that provides access to Microsoft SQL Server and Azure SQL Database from any Java application. JDBC和R2DBC驱动程序，可以从任何Java应用程序访问Microsoft SQL Server和Azure SQL数据库。</li>
<li><a href="https://spring.io/guides/gs/accessing-data-mysql/">MySQL Driver</a>: MySQL JDBC and R2DBC driver. MySQL JDBC和R2DBC驱动程序。</li>
<li>Oracle Driver: A JDBC driver that provides access to Oracle. 提供对Oracle访问的JDBC驱动程序。</li>
<li>PostgreSQL Driver: A JDBC and R2DBC driver that allows Java programs to connect to a PostgreSQL database using standard, database independent Java code. JDBC和R2DBC驱动程序，允许Java程序使用标准的、独立于数据库的Java代码连接到PostgreSQL数据库。</li>
</ul>
</li>
<li><p>NoSQL</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-redis">Spring Data Redis (Access+Driver)</a>: Advanced and thread-safe Java Redis client for synchronous, asynchronous, and reactive usage. Supports Cluster, Sentinel, Piperlining, Auto-Reconnect, Codecs and much more. 先进且线程安全的Java Redis客户端，用于同步、异步和响应式使用。支持集群、哨兵、管道、自动重连、编解码器等。<ul>
<li><a href="https://spring.io/guides/gs/messaging-redis/">Messaging with Redis</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-redis">Spring Data Reactive Redis</a>: Access Redis key-value data stores in a reactive fashion with Spring Data Redis. 使用Spring Data Redis以响应式访问Redis键值数据存储。<ul>
<li><a href="https://spring.io/guides/gs/messaging-redis/">Messaging with Redis</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-mongodb">Spring Data MongoDB</a>: Store data in flexible, JSON-like documents, meaning fields can vary from document to document and data structure can be change over time. 将数据存储在灵活的、类似于JSON的文档中，这意味着字段随文档的不同而不同，并且数据结构可以随时间变化。<ul>
<li><a href="https://spring.io/guides/gs/accessing-data-mongodb/">Accessing Data with MongoDB</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-mongodb">Spring Data Reactive MongoDB</a>: Provides asynchronous stream processing with non-blocking back pressure for MongoDB. 为MongoDB提供具有无阻塞背压的异步流处理。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-elasticsearch">Spring Data Elasticsearch (Access+Driver)</a>: A distributed, RESTful search and analytics engine with Spring Data Elasticsearch. 带有Spring Data Elasticsearch的分布式RESTful搜索和分析引擎。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-solr">Spring Data for Apache Solr</a>: Apache Solr is an open source enterprise search platform built on Apache Lucene. Apache Solr是基于Apache Lucene构建的开源企业搜索平台。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-cassandra">Spring Data for Apache Cassandra</a>: A free and open-source, distributed, NoSQL database management system that offers high-scalability and high-performance. 一个免费开源的NoSQL分布式数据库管理系统，可提供高可伸缩性和高性能。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-cassandra">Spring Data Reactive for Apache Cassandra</a>: Access Cassandra NoSQL Database in a reactive fashion. 以响应式方式访问Cassandra NoSQL数据库。</li>
<li><a href="https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/">Spring for Apache Geode</a>: Apache Geode is a data management platform that helps users build real-time, highly concurrent, highly performant and reliable Spring Boot applications at scale that is compatible with Pivotal Cloud Cache. Apache Geode是一个数据管理平台，可帮助用户大规模构建与Pivotal Cloud Cache兼容的实时、高并发、高性能和可靠的Spring Boot应用程序。<ul>
<li><a href="https://github.com/spring-projects/spring-boot-data-geode/tree/master/spring-geode-samples">Using Spring for Apache Geode</a></li>
<li><a href="https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/#geode-gemfire-switch">Switch from Apache Geode to Pivotal Cloud Cache</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-couchbase">Spring Data Couchbase</a>: NoSQL document-oriented database that offers in memory-first architecture, geo-distributed deployments, and workload isolation. NoSQL面向文档的数据库，提供内存优先的体系结构，地理分布的部署和工作负载隔离。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-couchbase">Spring Data Reactive Couchbase</a>: Access Couchbase NoSQL database in a reactive fashion with Spring Data Couchbase. 使用Spring Data Couchbase以响应式方式访问Couchbase NoSQL数据库。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-neo4j">Spring Data Neo4j</a>: An open source NoSQL database that stores data structured as graphs consisting of nodes, connected by relationships. 一个开源的NoSQL数据库，该数据库存储结构化为图形的数据，这些图形由通过关系连接额节点组成。<ul>
<li><a href="https://spring.io/guides/gs/accessing-data-neo4j/">Accessing Data with Neo4j</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Messaging 消息</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-integration">Spring Integration</a>: Adds support for Enterprise Integration Patterns. Enables lightweight messaging and supports integration with external systems via declarative adapters. 添加了对企业集成模式的支持。支持轻量级消息传递，并通过申明性适配器支持与外部系统的集成。<ul>
<li><a href="https://spring.io/guides/gs/integration/">Integrating Data</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-amqp">Spring for RabbitMQ</a>: Gives your applications a common platform to send and receive messages, and your messages a safe place to live until received. 为您的应用程序提供一个发送和接收消息的通用平台，并使您的消息在一个安全的生存环境中，直到收到消息为止。<ul>
<li><a href="https://spring.io/guides/gs/messaging-rabbitmq/">Messaging with RabbitMQ</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-kafka">Spring for Apache Kafka</a>: Publish, subscribe, store, and process streams of records. 发布、订阅、存储和处理记录流。</li>
<li>Spring for Apache kafka Streams: Building stream processing applications with Apache kafka Streams. 使用Apache Kafka Streams构建流处理应用程序。<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples">Sample for using Apache kafka Streams with Spring Cloud stream</a></li>
<li><a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/_reference.html#kafka-streams">Apache Kafka Streams Support</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/current/reference/html/#_kafka_streams_binding_capabilities_of_spring_cloud_stream">Apache Kafka Streams Binding Capabilities of Spring Cloud Stream</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-activemq">Spring for Apache ActiveMQ 5</a>: Spring JMS supports with Apache ActiveMQ ‘Classic’. 带有Apache ActiveMQ ‘Classic’模式的Spring JMS支持。<ul>
<li><a href="https://spring.io/guides/gs/messaging-jms/">Java Message Service API via Apache ActiveMQ Classic.</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-artemis">Spring for Apache ActiveMQ Artemis</a>: Spring for Apache ActiveMQ Artemis. 带有Apache ActiveMQ ‘Artemis’模式的Spring JMS支持。<ul>
<li><a href="https://spring.io/guides/gs/messaging-jms/">Messaging with JMS</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-websockets">WebSocket</a>: Build WebSocket applications with SockJS and STOMP. 使用SockJS和STOMP构建WebSocket应用程序。<ul>
<li><a href="https://spring.io/guides/gs/messaging-stomp-websocket/">Using WebSocket to build an interactive web application</a></li>
</ul>
</li>
<li>RSocket: RSocket.io application with Spring Messaging and Netty. 带有Spring Messaging和Netty的RSocket.io应用程序。</li>
<li><a href="https://camel.apache.org/camel-spring-boot/latest/spring-boot.html">Apache Camel</a>: (Requires Spring Boot Version &gt;=2.0.0.M1 and &lt;2.4.0-M1) Apache Camel is an open source integration framework that empowers you to quickly and easily integrate various systems consuming or producing data. Apache Camel是一个开源集成框架，可让您快速轻松地集成使用或生成数据的各种系统。</li>
<li><a href="https://www.solace.dev/start-spring-io-help/">Solace PubSub+</a>: Connect to a Solace PubSub+ Advanced Event Broker to publish, subscribe, request/reply and store/relpay messages 连接到Solace PubSub+ Adanced Event Broker以发布、订阅，请求/答复以及存储/重播消息。<ul>
<li><a href="https://www.solace.dev/">Solace Developer Portal</a></li>
</ul>
</li>
</ul>
</li>
<li><p>I/O 输入/输出</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#howto-batch-applications">Spring Batch</a>: Batch applications with transactions, retry.skip and chunk based processing. 批处理应用程序，具有事务、重试/跳过和基于块的处理。<ul>
<li><a href="https://spring.io/guides/gs/batch-processing/">Creating a Batch Service</a></li>
</ul>
</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-validation">Validation</a>: JSR-303 validation with Hibernate validator. 使用Hibernate验证程序进行JSR-303验证。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-email">Java Mail Sender</a>: Send email using Java Mail and Spring Framework’s JavaMailSender. 使用Java Mail和Spring Framework的JavaMailSender发送电子邮件。</li>
<li>Quartz Scheduler: Schedule jobs using Quartz. 使用Quartz调度作业。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#boot-features-caching">Spring cache abstraction</a>: Provides cache-related operations, such as the ability to update the content of the cache, but does not provide the actual data store. 提供与缓存有关的操作，例如更新缓存内容的能力，但不提供实际的数据存储。<ul>
<li><a href="https://spring.io/guides/gs/caching/">Caching Data with Spring</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Ops</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/htmlsingle/#production-ready">Spring Boot Actuator</a>: supports built in (or custom) endpoints that let you monitor and manage your application - such as application health, metrics, sessions, etc. 支持内置(或自定义)端点，使您可以监视和管理应用程序-例如应用程序运行状况，指标，会话等。<ul>
<li><a href="https://spring.io/guides/gs/actuator-service/">Building a RESTful Web Service with Spring Boot Actuator</a></li>
</ul>
</li>
<li><a href="https://codecentric.github.io/spring-boot-admin/current/#getting-started">Codecentric’s Spring Boot Admin (Client)</a>: Required for your application to register with a Codecentric’s Spring Boot Admin Server instance. 应用程序向Spring Boot Admin Server实例注册所必要的依赖。</li>
<li><a href="https://codecentric.github.io/spring-boot-admin/current/#getting-started">Codecentric’s Spring Boot Admin (Server)</a>: A community project to manage and monitor your Spring Boot applications. Provides a UI on top of the Spring Boot Actuator endpoints. 一个社区项目，用于管理和监视您的Spring Boot应用程序。在Spring Boot Actuator端点的顶部提供一个UI。</li>
</ul>
</li>
<li><p>Observability 观测</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/production-ready-features.html#production-ready-metrics-export-datadog">Datadog</a>: Datadog is a dimensional time-series SAAS with built-in dashboarding and alerting. Datadog是具有内置仪表板和警报功能的维度时间序列SAAS。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/production-ready-features.html#production-ready-metrics-export-influx">Influx</a>: Support real-time stream processing and storage of time-series data. 支持实时流处理和时间序列数据的存储。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/production-ready-features.html#production-ready-metrics-export-graphite">Graphite</a>: Hierarchical metrics systems backed by a fixed-size database. 由固定大小的数据库支持的分层度量标准系统。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/production-ready-features.html#production-ready-metrics-export-new-relic">New Relic</a>: SaaS offering with a full UI and a query language called NRQL. 具有完整UI和称为NRQL的查询语言的Saas产品。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/production-ready-features.html#production-ready-metrics-export-prometheus">Prometheus</a>: An in-memory dimensional time series database with a simple built-in UI, a custom query language, and math operations. 具有简单内置UI，自定义查询语言和数学运算的内存中维时间序列数据库。</li>
<li><a href="https://docs.wavefront.com/wavefront_springboot.html">Wavefront</a>: Tanzu Observability by Wavefront is a SaaS-based metrics monitoring and analytics platform that lets you visualize, query, and alert over data from across your entire stack (infrastructure, network, custom app metrics, bussiness KPIs, etc.) Wavefront的Tanzu Observability是基于SaaS的指标监视和分析平台，可让您可视化，查询和警告整个堆栈中的数据(基础结构、网络、自定义应用程序指标、业务KPI等)<ul>
<li><a href="https://github.com/wavefrontHQ/wavefront-spring-boot">Wavefront for Spring Boot repository</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Testing 测试</p>
<ul>
<li>Spring REST Docs: Document RESTful services by combining hand-written with Asciidoctor and auto-generated snippets produced with Spring MVC Test. 通过结合使用Asciidoctor手写和通过Spring MVC Test自动生成的代码片段来记录RESTful服务。</li>
<li><a href="https://www.testcontainers.org/">Testcontainers</a>: Provide lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container.</li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/reference/html/">Contract Verifier</a>: Moves TDD to the level of software architecture by enabling Consumer Driven Contract (CDC) development. 通过启用“消费者驱动合同”（CDC）开发，将TDD升级到软件体系结构级别</li>
<li>Contract Stub Runner: Stub Runner for HTTP/Messaging based communication. Allows creating Wire Mock stubs from RestDocs tests. Stub Runner，用于基于 HTTP/消息 传递的通信。允许通过RestDocs测试创建WireMock存根。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.4.0/reference/html/boot-features-nosql.html#boot-features-ldap-embedded">Embedded LDAP Server</a>: Provides a platform neutral way for running a LDAP server in unit tests. 提供在单元测试中运行LDAP服务器的平台无关的方法。</li>
<li>Embedded MongoDB Database: Provodes a platform neutral way for running MongoDB in unit tests. 提供在平台测试中运行MongoDB的平台无关的方法。</li>
<li>Junit：Java语言的单元测试框架</li>
</ul>
</li>
<li><p>cola 架构</p>
<ul>
<li>cola-core: COLA框架的核心库</li>
<li>cola-common: COLA框架通用组件</li>
</ul>
</li>
<li><p>other</p>
<ul>
<li>Fastjson: Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。</li>
<li>Jackson Databind：Jackson 是一个序列化库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。</li>
<li>Apache Commons Lang: Java实用程序类的软件包，用于java.lang的层次结构中的类，或者被认为是标准的以证明存在于java.lang中。</li>
<li>Gson：Gson 是一个 Google 开发的序列化库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。</li>
<li>Commons-io: Commons IO is a library of utilities to assist with developing IO functionality.</li>
</ul>
</li>
<li><p>Spring Cloud</p>
<ul>
<li><a href="https://spring.io/projects/spring-cloud-commons">Cloud Bootstrap</a>: Mon-specific Spring Cloud features, unrelated to external libraries or integrations (e.g Bootstrap context and @RefreshScope).</li>
<li><a href="https://cloud.spring.io/spring-cloud-function/reference/html/">Function</a>: Promotes the implementation of business logic via functions and supports a uniform programming model across serverless providers, as well as the ability to run standalone (locally or in a Pass).<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-samples">Varous sample apps using Spring Cloud Function</a></li>
</ul>
</li>
<li>Task: Allows a user to develop and run short lived microservices using Spring Cloud. Run them locally, in the cloud, and on Spring Cloud Data Flow.</li>
</ul>
</li>
<li><p>Spring Cloud Security</p>
<ul>
<li>Cloud Security: A declarative model whitch can be heavily configured externally (or centrally) lends itself to the implementation of large system of co-operating, remote components, usually with a central indentity management service.</li>
<li>Cloud OAuth2: OAuth2 and distributed application patterns with spring-cloud-security.</li>
</ul>
</li>
<li><p>Spring Cloud Tools</p>
<ul>
<li>Cloud Connectors: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.3.0.M1) Simplifies the process of connecting to services and gaining operating environment awareness in cloud platforms such as Cloud Foundry and Heroku.</li>
<li><a href="https://docs.spring.io/spring-cloud-open-service-broker/docs/current/reference/html5/">Open Service Broker</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0.M1) Framework for building Spring Boot apps that implement the Open Service Broker API, which can deliver services to applications running within cloud native platforms such as Cloud Foundry, Kubernetes and OpenShift.<ul>
<li><a href="https://github.com/spring-cloud-samples/bookstore-service-broker">Using Spring Cloud Open Service Broker</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Cloud Config</p>
<ul>
<li>Config Client: Client that connects to a Spring Cloud Config Server to fetch the application’s configuration.</li>
<li><a href="https://spring.io/guides/gs/centralized-configuration/">Config Server</a>: Central management for configuration via Git, SVN, or HashiCorp Vault.</li>
<li>Vault Configuration: Provides client-side support for externalized configuration in a distributed system. Using HashiCorp’s Vault you hava a central place to manage external secret properties for applications across all environments,</li>
<li>Apache Zookeeper Configuration: Enable and configure common patterns inside your application and build large distributed systems with Apache Zookeeper based components. The provided patterns include Service Discovery and Configuration.</li>
<li>Consul Configuration: Enable and configure the common patterns inside your application and build large distributed system with Hashicorp’s Consul. The patterns provided include Service Discovery, Distributed Configuration and Control Bus.</li>
</ul>
</li>
<li><p>Spring Cloud Discovery</p>
<ul>
<li>Eureka Discovery Client: a REST based service for locating services for th purpose of load balancing and failover of middle-tier servers.</li>
<li><a href="https://spring.io/guides/gs/service-registration-and-discovery/">Eureka Server</a>: spring-cloud-netflix Eureka Server.</li>
<li>[Apache Zookeeper Discovery](Service discovery with Apache Zookeeper.)</li>
<li>Cloud Foundry Discovery: Service discovery with Cloud Foundry.</li>
<li>Consul Discovery: Service discovery with Hashicorp Consul.</li>
</ul>
</li>
<li><p>Spring Cloud Routing</p>
<ul>
<li><a href="https://spring.io/guides/gs/routing-and-filtering/">Zuul [Maintenance]</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Intelligent and programmable routing with Spring Cloud Netflix Zuul.</li>
<li><a href="https://github.com/spring-cloud-samples/spring-cloud-gateway-sample">Gateway</a>: Provides a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as security, monitoring/metrics, and resiliency.</li>
<li><a href="https://spring.io/guides/gs/client-side-load-balancing/">Ribbon [Maintenance]</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Client-side load-balancing with Spring Cloud Netflix and Ribbon.</li>
<li>OpenFeign: Declarative REST Client. OpenFeign creates a dynamic implemention of an interface decorated with JAX-RS or Spring MVC annotations.</li>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-commons/current/reference/html/#spring-cloud-loadbalancer">Cloud LoadBalancer</a>: Client-side load-balancing with Spring CLoud LoadBalancer.<ul>
<li><a href="https://spring.io/guides/gs/spring-cloud-loadbalancer/">Client-side load-balancing with Spring CLoud LoadBalancer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Spring Cloud Circuit Breaker: </p>
<ul>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-circuitbreaker/current/reference/html">Resilience4j</a>: Spring Cloud Circuit breaker with Resilience4j as the underlying implementation.</li>
<li><a href="https://spring.io/guides/gs/circuit-breaker/">Hystrix [Maintenance]</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Circuit breaker with Spring Cloud Netflix Hystrix.</li>
<li>Hystrix Dashboard [Maintenance]: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Circuit breaker dashboard with Spring Cloud Netflix Hystrix.</li>
<li>Turbine [Maintenance]: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Circuit breaker metric aggregation using spring-cloud-netflix with Turbine and server-sent events.</li>
<li>Turbine Stream [Maintenance]: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Circuit breaker metric aggregation using spring-cloud-netflix with Tuibine and Spring Cloud Stream (requires a binder, e.g. Apache Kafka or RabbitMQ).</li>
</ul>
</li>
<li><p>Spring Cloud Tracing</p>
<ul>
<li>Sleuth: Distributed tracing via logs logs with Spring Cloud Sleuth.</li>
<li>Zipkin Client: Distributed tracing with an existing Zipkin installation and Spring Cloud Sleuth Zipkin.</li>
</ul>
</li>
<li><p>Spring Cloud Messaging</p>
<ul>
<li>Cloud Bus: Links nodes of a distributed system with a lightweight message broker which can used to broadcast state changes or other management instructions (requires a binder, e.g. Apache Kafka or RabbitMQ).</li>
<li>Cloud Stream: Framework for building highly scalable event-driven microservices connected with shared messaging systems (requires a binder, e.g. Apache Kafka, RabbitMQ or Solace PubSub+).</li>
<li>Reactive Cloud Stream: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.2.0.M1) Reactive messaging microservices with Spring Cloud Stream (requires a binder, e.g. Apache Kafka or RabbitMQ).</li>
</ul>
</li>
<li><p>Pivotal Cloud Foundry</p>
<ul>
<li><a href="https://docs.pivotal.io/spring-cloud-services/3-1/common/">Config Client (PCF)</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Config client on Pivotal Cloud Foundy.</li>
<li><a href="https://docs.pivotal.io/spring-cloud-services/3-1/common/">Service Registry (PCF)</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1)  Eureka service discovery  client on Pivotal Cloud Foundry.</li>
<li>Circuit Breaker (PCF): (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Hystrix circuit breaker client on Pivotal Cloud Foundry.</li>
</ul>
</li>
<li><p>Amazon Web Services</p>
<ul>
<li>AWS Core: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1)  AWS native services from Spring Cloud for AWS.</li>
<li>AWS RDS: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Relational databases on AWS with RDS and Spring Cloud AWS JDBC.</li>
<li>AWS Simple Queue Service: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Messaging on AWS with SQS and Spring Cloud AWS Messaging.</li>
</ul>
</li>
<li><p>Microsoft Azure</p>
<ul>
<li><a href="https://github.com/Microsoft/azure-spring-boot/">Azure Support</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1)  Auto-configuration for Azure Services (Service Bus, Storage, Active Directory, Cosmos DB, Key Vault, and more).</li>
<li><a href="https://github.com/Microsoft/azure-spring-boot/tree/master/azure-spring-boot-starters/azure-active-directory-spring-boot-starter">Azure Active Directory</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Spring Security integration with Azure Active Directory for authentication.<ul>
<li><a href="https://github.com/Microsoft/azure-spring-boot/tree/master/azure-spring-boot-samples/azure-active-directory-spring-boot-sample">Using Active Directory</a></li>
</ul>
</li>
<li><a href="https://github.com/Microsoft/azure-spring-boot/tree/master/azure-spring-boot-starters/azure-keyvault-secrets-spring-boot-starter">Azure key Vault</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1) Manage application secrets and keys.<ul>
<li><a href="https://github.com/Microsoft/azure-spring-boot/tree/master/azure-spring-boot-samples/azure-keyvault-secrets-spring-boot-sample">Using key Vault</a></li>
</ul>
</li>
<li><a href="https://github.com/Microsoft/azure-spring-boot/tree/master/azure-spring-boot-starters/azure-storage-spring-boot-starter">Azure Storage</a>: (Requires Spring Boot Version &gt;=2.0.0.RELEASE and &lt;2.4.0-M1)  Azure Storage service integration.<ul>
<li><a href="https://github.com/Microsoft/azure-spring-boot/tree/master/azure-spring-boot-samples/azure-storage-spring-boot-sample">Using Azure Storage</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Google Cloud Platform</p>
<ul>
<li><a href="https://cloud.spring.io/spring-cloud-gcp/reference/html/">GCP Support</a>: Contains auto-configuration support for every Spring Cloud GCP integration. Most of the auto-configuration code is only enabled if other dependencies are added to the classpath.<ul>
<li><a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples">GCP Samples</a></li>
</ul>
</li>
<li><a href="https://cloud.spring.io/spring-cloud-gcp/reference/html/#spring-integration">GCP Messaging</a>: Adds the GCP Support entry and all the required dependencies so that the Google Cloud Pub/Sub integration work out of the box.<ul>
<li><a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-sample">GCP Pub/Sub Sample</a></li>
</ul>
</li>
<li><a href="https://cloud.spring.io/spring-cloud-gcp/reference/html/#spring-resources">GCP Storage</a>: Adds the GCP Support entry and all the required dependencies so that the Google Cloud Storage integration work out of the box.<ul>
<li><a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-storage-resource-sample">Guide</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Alibaba</p>
<ul>
<li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_nacos_config">Nacos Configuration</a>: (Requires Spring Boot Version &gt;=2.2.0.RELEASE and &lt;2.3.0.M1) Support for externalized configuration in a distributed system, auto refresh when configuration changes. 通过Alibaba Nacos实现配置管理：支持分布式系统中的外部化配置、配置更改时自动刷新功能。<ul>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example">Nacos Configuration Example</a></li>
</ul>
</li>
<li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_nacos_discovery">Nacos Service Discovery</a>: (Requires Spring Boot Version &gt;=2.2.0.RELEASE and &lt;2.3.0.M1) Service discovery with Alibaba Nacos. 通过nacos实现的服务发现平台<ul>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme.md">Nacos Service Discovery Example</a></li>
</ul>
</li>
<li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_sentinel">Sentinel</a>: (Requires Spring Boot Version &gt;=2.2.0.RELEASE and &lt;2.3.0.M1) Flow control and circuit breaking with Alibaba Sentinel.提供 Sentinel 自动接入和配置支持，提供 Spring Web/WebFlux、Feign、RestTemplate、注解等适配。<ul>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example">Sentinel Example</a></li>
<li>Sentinel DataSource: 提供 Sentinel 动态数据源接入支持，方便用户整合 Nacos 等数据源动态管理规则</li>
<li>Sentinel Dubbo Adapter: 提供 Sentinel 对 Dubbo 的适配能力。</li>
<li>Sentinel Gateway: 提供 Sentinel 网关流控自动接入支持，目前支持 Spring Cloud Gateway 和 Zuul。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>
<li>RocketMQ Binder：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务</li>
<li>Seata: 阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li>ANS: ANS(Application Naming Service) is a component of EDAS. Spring Cloud Alibaba Cloud ANS provides the commercial version of service registration and discovery in conformity with the Spring Cloud specifications, so that you can develop your applications locally and run them on the cloud.</li>
<li>ACM: Spring Cloud AliCloud ACM is an implementation of the commercial product Application Configuration Management(ACM) in the client side of Spring Cloud, and is free of charge.</li>
<li>OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>
<li>SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
<li>Nepxion Discovery：一款集成Spring Cloud Alibaba、Nacos、Sentinel等阿里巴巴中间件，实现网关和服务的灰度发布、路由、权重、限流、熔断、降级、隔离、监控、追踪等功能的微服务开源解决。</li>
<li>RDS: 阿里云关系型数据库RDS（Relational Database Service）是一种稳定可靠、可弹性伸缩的在线数据库服务，提供容灾、备份、恢复、迁移等方面的全套解决方案，彻底解决数据库运维的烦恼。</li>
</ul>
<blockquote>
<p>更多阿里云相关产品可访问<a href="https://start.aliyun.com/">https://start.aliyun.com/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成Redis</title>
    <url>/20200826/java/springboot/b11f77d1/</url>
    <content><![CDATA[<h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<blockquote>
<p> C语言开发的、开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件</p>
</blockquote>
<blockquote>
<p>一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库，性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS</p>
</blockquote>
<p><a href="https://redis.io/">Redis</a> <a href="http://www.redis.cn/">中文网站</a> 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。</p>
<h2 id="为什么要使用redis"><a href="#为什么要使用redis" class="headerlink" title="为什么要使用redis"></a>为什么要使用redis</h2><blockquote>
<p>性能</p>
</blockquote>
<p>由于MySql数据存储在磁盘中，对于一些需要执行耗时非常长的，但结果不会频繁改动的SQL操作(经常是查询，如每日排行榜或者高频业务热数据)，就适合将运行结果放到到redis中。<br>后面的请求优先去redis中获取，加快访问速度、提高性能</p>
<blockquote>
<p>并发</p>
</blockquote>
<p>mysql支持并发访问的能力有限(当然现在一般会使用一些数据库连接池的来加强并发能力)，当有大量的并发请求，直接访问数据库的话，mysql会挂掉。所以可以使用redis作为缓冲，让请求先访问到redis，而不是直接访问数据库，提高系统的并发能力。</p>
<blockquote>
<p>当然redis是基于内存的，存储容量肯定要比磁盘少很多，要存储大量数据，需升级内存，造成在一些不需要高性能的地方是相对比较浪费的，所以建议在需要性能的地方使用redis，在不需要高性能的地方使用mysql。不要一味的什么数据都丢到redis中。</p>
</blockquote>
<a id="more"></a>

<p><strong>Redis主要有5种数据类型，包括String、list、Set、ZSet、Hash</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
<th>应用场景</th>
<th>Java对应</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作;对整数和浮点数执行自增或者自减操作</td>
<td>做简单的键值对缓存</td>
<td>类似Java的String</td>
</tr>
<tr>
<td>List</td>
<td>列表</td>
<td>从两端压入或者弹出元素;对单个或者多个元素进行修剪,只保留一个范围内的元素</td>
<td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
<td>类似Java的LinkedList</td>
</tr>
<tr>
<td>Set</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素;检查一个元素是否存在于集合中;计算交集、并集、差集;从集合里面随机获取元素</td>
<td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
<td>类似Java中的HashSet</td>
</tr>
<tr>
<td>ZSet(Sorted sets)</td>
<td>有序集合</td>
<td>添加、获取、删除元素;根据分值范围或者成员来获取元素;计算一个键的排名</td>
<td>去重但可以排序，如获取排名前几名的用户</td>
<td>类似Java的SortedSet和HashMap的结合体</td>
</tr>
<tr>
<td>Hash</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对;获取所有键值对;检查某个键是否存在</td>
<td>结构化的数据，比如一个对象</td>
<td>类似Java的HashMap</td>
</tr>
</tbody></table>
<h1 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>截至2021年1月，官方也没提供windows版本的下载，如果是为了学习需要，可以到<a href="https://github.com/MicrosoftArchive/redis/releases">MicrosoftArchive Github</a> 上下载(最后的更新时间为2016年)</p>
<p>下载后像常用的软件类似：双击redis-server.exe即可启动redis服务器, 可参考<a href="https://www.cnblogs.com/xing-nb/p/12146449.html">Redis下载及安装(windows版)</a></p>
<blockquote>
<p>此版本对应的是redis的3.2.1版本，而目前redis已经发展到了6.x，故生产环境不建议使用，自己学习就好;<br>当然如果生产环境中的服务器恰好是windows的，小型项目使用也可以(毕竟没那么多并发量)，但还是建议使用下面的docker方式安装，使用较新的稳定版本<br>另外还有一种方案就是到github上下载redis对应版本的源码自己编译(或者找找网络大神的编译好的版本)</p>
</blockquote>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>直接输入命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure>
<p>安装完成后，Redis服务器会自动启动。</p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux|grep redis</span><br></pre></td></tr></table></figure>
<p>可以看到服务器系统进程默认端口6379</p>
<p>需要手动下载安装包并运行的话，可参考<a href="https://blog.csdn.net/hzlarm/article/details/99432240">Ubuntu安装Redis及使用</a></p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>使用docker</p>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<h4 id="准备redis的配置文件"><a href="#准备redis的配置文件" class="headerlink" title="准备redis的配置文件"></a>准备redis的配置文件</h4><p>因为需要redis的配置文件，这里最好去redis的<a href="http://www.redis.cn/download.html">官方网站</a> 去下载一个redis使用里面的配置文件即可</p>
<p>拿到redis.conf 后放到指定目录(这个目录用于后面docker指定本地目录用，比如我放在D:\Software\docker\env\redis\redis.conf)</p>
<p>修改redis.conf配置文件的以下配置：</p>
<ul>
<li>注释掉 bind 127.0.0.1 使redis可以外部访问，则注释掉这部分</li>
<li>修改 protected-mode no 不限制只能本地访问</li>
<li>修改 requirepass 123456 #给redis设置密码(如果需要)</li>
</ul>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -p 6379:6379 --name redis -v D:\Software\docker\env\redis\redis.conf:/etc/redis/redis.conf  -v D:\Software\docker\env\redis\data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span></span><br><span class="line">docker run -p 6379:6379 --name redis --restart=always -v /d/Software/docker/env/redis/redis.conf:/etc/redis/redis.conf  -v /d/Software/docker/env/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> /d/ Windows的D盘</span></span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口</li>
<li>-v /d/Software/docker/env/redis.conf:/etc/redis/redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中</li>
<li>-v /d/Software/docker/env/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份</li>
<li>redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动</li>
<li>appendonly yes：redis启动后数据持久化</li>
</ul>
<p>其他定制配置可参考<a href="https://hub.docker.com/_/redis/">hub.docker</a></p>
<h2 id="Redis可视化客户端"><a href="#Redis可视化客户端" class="headerlink" title="Redis可视化客户端"></a>Redis可视化客户端</h2><p>Redis的可视化客户端目前较流行的有：</p>
<ul>
<li>Redis Desktop Manager: 基于Qt5的跨平台Redis桌面管理软件，<a href="http://docs.redisdesktop.com/en/latest/install/#windows">下载地址</a> , 不过<a href="https://github.com/uglide/RedisDesktopManager/releases/tag/0.9.3">0.9.3</a> 版本之后就开始付费使用了，只能下载0.9.3的版本。</li>
</ul>
<p><img src="redis-desktop-manager.png" alt="redis-desktop-manager"></p>
<ul>
<li><p>Another Redis Desktop Manager：基于nodejs开发的免费的Redis可视化管理工具 <a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">下载地址</a> <a href="https://gitee.com/qishibo/AnotherRedisDesktopManager/releases">码云下载地址</a></p>
</li>
<li><p><img src="another-redis-desktop-manager.png" alt="another-redis-desktop-manager"></p>
</li>
</ul>
<blockquote>
<p>个人推荐 Another Redis DeskTop Manager，作为替代方案</p>
</blockquote>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>访问Redis，直接引入spring-boot-starter-data-redis依赖即可(它实际上是Spring Data的一个子项目——<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#preface">Spring Data Redis</a>)</p>
<p>在pom.xml中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- lettuce pool 缓存连接池 如果不需要在yml中自定义pool配置, 则不需要引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Springboot2以后，底层访问redis已经不再是jedis了，而是默认lettuce</p>
</blockquote>
<ul>
<li>使用jedis：当多线程使用同一个连接时，是线程不安全的。所以要使用连接池，为每个jedis实例分配一个连接。</li>
<li>使用Lettuce：当多线程使用同一连接实例时，是线程安全的。是采用netty连接redis server，实例可以在多个线程间共享，不存在线程不安全的情况，这样可以减少线程数量</li>
</ul>
<p>所以如果要继续使用jedis的话需要改为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐使用lettuce</p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果使用默认lettuce的话，直接在application.yml配置redis服务连接基本参数即可(spring-boot-starter-xx的好处之一):</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">## Redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">## Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">## Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment">## Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">## Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">password:</span></span><br></pre></td></tr></table></figure>

<p>如果需要配置连接池的参数的话:</p>
<ul>
<li>使用lettuce：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lettuce:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">## 连接池最大连接数（使用负值表示没有限制） 默认8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">500</span></span><br><span class="line">        <span class="comment">## 连接池中的最小空闲连接 默认0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">## 连接池中的最大空闲连接 默认8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">500</span></span><br><span class="line">        <span class="comment">##连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用jedis</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jedis:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">## 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="comment">#spring.redis.pool.max-active=8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">## 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="comment">#spring.redis.pool.max-wait=-1</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">## 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="comment">#spring.redis.pool.max-idle=8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">## 连接池中的最小空闲连接</span></span><br><span class="line">        <span class="comment">#spring.redis.pool.min-idle=0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编写公共配置"><a href="#编写公共配置" class="headerlink" title="编写公共配置"></a>编写公共配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration(&quot;cache&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">objectRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configRedisTemplate(Object.class, redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以根据自己实际项目需要，定制多个CacheManager，注解的地方可以指定使用哪个CacheManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectRedisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate&lt;String, Object&gt; objectRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果支持使用objectRedisTemplate，没有用注解或者cacheManager方式的话，则此配置不生效，即key相关的规则，需使用者自己定义</span></span><br><span class="line">        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration</span><br><span class="line">                .defaultCacheConfig()</span><br><span class="line"><span class="comment">//                .entryTtl(Duration.ofDays(1))</span></span><br><span class="line">                .disableCachingNullValues()</span><br><span class="line">                .computePrefixWith(cacheName -&gt; <span class="string">&quot;spring-redis&quot;</span>.concat(<span class="string">&quot;:&quot;</span>).concat(cacheName).concat(<span class="string">&quot;:&quot;</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(objectRedisTemplate.getStringSerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(objectRedisTemplate.getValueSerializer()));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; cacheNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cacheNames.add(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个缓存空间应用不同的配置</span></span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; configMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configMap.put(<span class="string">&quot;user&quot;</span>, cacheConfiguration.entryTtl(Duration.ofSeconds(<span class="number">120</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(Objects.requireNonNull(objectRedisTemplate.getConnectionFactory()))</span><br><span class="line">                .cacheDefaults(cacheConfiguration)</span><br><span class="line">                .initialCacheNames(cacheNames)</span><br><span class="line">                .withInitialCacheConfigurations(configMap)</span><br><span class="line">                <span class="comment">//在spring事务正常提交时才缓存数据</span></span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">RedisTemplate&lt;String, T&gt; <span class="title">configRedisTemplate</span><span class="params">(Class&lt;T&gt; clazz, RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, T&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;T&gt; j2jrs = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(clazz);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 解决jackson2无法反序列化LocalDateTime的问题</span></span><br><span class="line">        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">        om.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line"><span class="comment">//        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span></span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        j2jrs.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setValueSerializer(j2jrs);</span><br><span class="line">        redisTemplate.setHashValueSerializer(j2jrs);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="service中使用"><a href="#service中使用" class="headerlink" title="service中使用"></a>service中使用</h3><blockquote>
<p>注意推荐使用SpringCache中的注解和类，这样就算后期不使用redis，改用mongodb或者其他缓存中间件时，业务代码都不需要变更，这里体现了Java中的门面模式(外观模式)</p>
</blockquote>
<h4 id="使用-CacheConfig相关注解"><a href="#使用-CacheConfig相关注解" class="headerlink" title="使用@CacheConfig相关注解"></a>使用@CacheConfig相关注解</h4><p><strong>项目中一定要加上@EnableCaching</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;cacheAnnotationUserService&quot;)</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAnnotationUserService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cacheable[] cacheable() default &#123;&#125;; //声明多个<span class="doctag">@Cacheable</span></span></span><br><span class="line"><span class="comment">     * CachePut[] put() default &#123;&#125;;        //声明多个<span class="doctag">@CachePut</span></span></span><br><span class="line"><span class="comment">     * CacheEvict[] evict() default &#123;&#125;;    //声明多个<span class="doctag">@CacheEvict</span></span></span><br><span class="line"><span class="comment">     * 插入用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Caching(put = &#123;@CachePut(key = &quot;#user.id&quot;)&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;插入用户: &#123;&#125;&quot;</span>, user.getUsername());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * --<span class="doctag">@Cacheable</span>注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存</span></span><br><span class="line"><span class="comment">     * 命名空间:<span class="doctag">@Cacheable</span>的value会替换<span class="doctag">@CacheConfig</span>的cacheNames(两者必须有一个)</span></span><br><span class="line"><span class="comment">     * --key是[命名空间]::[<span class="doctag">@Cacheable</span>的key或者KeyGenerator生成的key](<span class="doctag">@Cacheable</span>的key优先级高,KeyGenerator不配置走默认KeyGenerator SimpleKey [])</span></span><br><span class="line"><span class="comment">     * 使用 sync = true保证只有一个线程访问数据库，避免缓存击穿 ，注意sync = true不能与unless=&quot;#result == null&quot;一起使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#userId&quot;, sync = true)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;查找用户: &#123;&#125;&quot;</span>, userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * --<span class="doctag">@CachePut</span>注解的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，</span></span><br><span class="line"><span class="comment">     * 和 <span class="doctag">@Cacheable</span> 不同的是，它每次都会触发真实方法的调用</span></span><br><span class="line"><span class="comment">     * 简单来说就是用户更新缓存数据。但需要注意的是该注解的value 和 key 必须与要更新的缓存相同，也就是与<span class="doctag">@Cacheable</span> 相同</span></span><br><span class="line"><span class="comment">     * 默认先执行数据库更新再执行缓存更新</span></span><br><span class="line"><span class="comment">     * 注意返回值必须是要修改后的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;更新用户：&#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#userId&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteById</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除用户：&#123;&#125;&quot;</span>, userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * --<span class="doctag">@CachEvict</span> 的作用 主要针对方法配置，能够根据一定的条件对缓存进行清空</span></span><br><span class="line"><span class="comment">     * 触发缓存清除</span></span><br><span class="line"><span class="comment">     * 默认先执行数据库删除再执行缓存删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(allEntries = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;清除所有&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用CacheManager"><a href="#使用CacheManager" class="headerlink" title="使用CacheManager"></a>使用CacheManager</h4><p>注解方式适合逻辑不是很复杂的情况，当业务逻辑需要更加灵活的控制缓存处理时，可使用CacheManager来管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;cacheManagerUserService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheManagerUserService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        getUserCache().put(user.getId(), user);</span><br><span class="line">        logger.info(<span class="string">&quot;保存用户: &#123;&#125;&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUserCache().get(userId, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        getUserCache().put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteById</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        getUserCache().evict(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUserCache().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Cache <span class="title">getUserCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheManager.getCache(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="通过-RedisHash注解存储实体到redis"><a href="#通过-RedisHash注解存储实体到redis" class="headerlink" title="通过@RedisHash注解存储实体到redis"></a>通过@RedisHash注解存储实体到redis</h4><p>参考<a href="https://www.baeldung.com/spring-data-redis-tutorial">Introduction to Spring Data Redis</a> 可以像其他数据库一样继承CrudRepository来操作对象</p>
<p>如果需要将某个属性标识为唯一id，添加@Id注解即可</p>
<p>如果需要在redis存储中拥有生命周期，添加@TimeToLive注解；以秒为单位，可根据需要设置其失效时间: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RedisHash(&quot;Student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以秒为单位，失效时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TimeToLive</span></span><br><span class="line">    <span class="keyword">private</span> Long time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Gender &#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果对一个类想要整体设置过期时间，可以使用@RedisHash(value = “Student”, timeToLive = 20L)</p>
<h4 id="直接使用RedisTemplate"><a href="#直接使用RedisTemplate" class="headerlink" title="直接使用RedisTemplate"></a>直接使用RedisTemplate</h4><p>当然如果直接使用RedisTemplate也是可以的，不过需要注意的是一旦直接使用了RedisTemplate，则cacheManager相关的配置将不会生效，包含CachingConfigurerSupport相关的也不会生效，如发生异常时将不会回调CacheErrorHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;redisTemplateUserService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplateUserService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String PREFIX_CACHE_REDIS_KEY_USER = <span class="string">&quot;spring-redis:user:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String, User&gt; userRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userRedisTemplate.opsForValue().set(getRealKeyById(user.getId()), user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRedisTemplate.opsForValue().get(getRealKeyById(userId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userRedisTemplate.opsForValue().set(getRealKeyById(user.getId()), user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteById</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        Boolean result = userRedisTemplate.delete(getRealKeyById(userId));</span><br><span class="line">        logger.info(<span class="string">&quot;删除结果: &#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keys = userRedisTemplate.keys(PREFIX_CACHE_REDIS_KEY_USER + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            userRedisTemplate.delete(keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取真实key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRealKeyById</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_CACHE_REDIS_KEY_USER + userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>key需要自己定义前缀，当然之间使用RedisTemplate可以直接控制更加底层的api</p>
</blockquote>
<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>单机情况下使用jvm提供的锁机制即可</p>
<ul>
<li>方式一: 直接在方法上加上synchronized(或者在关键代码上使用)，缺点购买多个商品时效率会较低(当然因为java8对于synchronized做了很多优化，效率也不会有多差相较于lock)</li>
<li>方式二: 使用lock, 缺点如果逻辑上出现异常(未捕获的)导致锁未及时释放的话，会导致后面的请求都会由于获取不到锁而失败，一个商品抢购还好，如果好多商品，会因为某一个异常导致所有商品都失败</li>
<li>方式三(推荐)：使用ConcurrentHashMap，一个商品一个锁(或者一段数量一个锁)，这样可以在某个商品秒杀出现异常时，不影响其他商品</li>
</ul>
<blockquote>
<p>如果是单机环境的话，使用ConcurrentHashMap是不错的选择，不过如果是集群情况下(部署到多个服务器上)，使用jvm的锁机制就满足不了需求了</p>
</blockquote>
<h3 id="使用redis实现"><a href="#使用redis实现" class="headerlink" title="使用redis实现"></a>使用redis实现</h3><p>可参考<a href="https://developer.ibm.com/zh/articles/j-spring-boot-aop-web-log-processing-and-distributed-locking/">使用 Spring Boot AOP 实现 Web 日志处理和分布式锁</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLock</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String value = UUID.randomUUID().toString();</span><br><span class="line">            Boolean lockStat = redisTemplate.execute((RedisCallback&lt; Boolean&gt;) connection -&gt;</span><br><span class="line">                    connection.set(key.getBytes(StandardCharsets.UTF_8), value.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">                            Expiration.from(timeout, timeUnit), RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line">            <span class="keyword">if</span> (!lockStat) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取分布式锁失败，key=&#123;&#125;&quot;</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            <span class="keyword">boolean</span> unLockStat = redisTemplate.execute((RedisCallback&lt; Boolean&gt;)connection -&gt;</span><br><span class="line">                    connection.eval(script.getBytes(), ReturnType.BOOLEAN, <span class="number">1</span>,</span><br><span class="line">                            key.getBytes(StandardCharsets.UTF_8), value.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">            <span class="keyword">if</span> (!unLockStat) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;释放分布式锁失败，key=&#123;&#125;，已自动超时，其他线程可能已经重新获取锁&quot;</span>, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;释放分布式锁失败，key=&#123;&#125;&quot;</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用redisson"><a href="#使用redisson" class="headerlink" title="使用redisson"></a>使用redisson</h3><p>使用redis做分布式锁时容易发生死锁等未知情况，实际项目还是推荐使用<a href="https://redisson.pro/">redisson</a> 来实现 分布式分段锁</p>
<p>pom.xml中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-data-23<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-data-24<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>redisson-spring-data-24, 取决于项目中使用的SpringBoot版本，因为我使用了SpringBoot 2.4.2，故引用24，而redisson-spring-boot-starter的3.14.0版本默认引用的是23，故需排除</p>
</blockquote>
<p>resource下新建redisson-single.yml(单机版):</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ngleServerConfig:</span></span><br><span class="line">  <span class="comment"># 连接空闲超时，单位：毫秒</span></span><br><span class="line">  <span class="attr">idleConnectionTimeout:</span> <span class="number">10000</span></span><br><span class="line">  <span class="comment"># 连接超时，单位：毫秒</span></span><br><span class="line">  <span class="attr">connectTimeout:</span> <span class="number">10000</span></span><br><span class="line">  <span class="comment"># 命令等待超时，单位：毫秒</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="comment"># 命令失败重试次数,如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。</span></span><br><span class="line">  <span class="comment"># 如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</span></span><br><span class="line">  <span class="attr">retryAttempts:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># 命令重试发送时间间隔，单位：毫秒</span></span><br><span class="line">  <span class="attr">retryInterval:</span> <span class="number">1500</span></span><br><span class="line">  <span class="comment">#  # 重新连接时间间隔，单位：毫秒</span></span><br><span class="line">  <span class="comment">#  reconnectionTimeout: 3000</span></span><br><span class="line">  <span class="comment">#  # 执行失败最大次数</span></span><br><span class="line">  <span class="comment">#  failedAttempts: 3</span></span><br><span class="line">  <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">password:</span></span><br><span class="line">  <span class="comment"># 单个连接最大订阅数量</span></span><br><span class="line">  <span class="attr">subscriptionsPerConnection:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># 客户端名称</span></span><br><span class="line">  <span class="attr">clientName:</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">#  # 节点地址</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">&quot;redis://127.0.0.1:6379&quot;</span></span><br><span class="line">  <span class="comment"># 发布和订阅连接的最小空闲连接数</span></span><br><span class="line">  <span class="attr">subscriptionConnectionMinimumIdleSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 发布和订阅连接池大小</span></span><br><span class="line">  <span class="attr">subscriptionConnectionPoolSize:</span> <span class="number">50</span></span><br><span class="line">  <span class="comment"># 最小空闲连接数</span></span><br><span class="line">  <span class="attr">connectionMinimumIdleSize:</span> <span class="number">32</span></span><br><span class="line">  <span class="comment"># 连接池大小</span></span><br><span class="line">  <span class="attr">connectionPoolSize:</span> <span class="number">64</span></span><br><span class="line">  <span class="comment"># 数据库编号</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># DNS监测时间间隔，单位：毫秒</span></span><br><span class="line">  <span class="attr">dnsMonitoringInterval:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment"># 线程池数量,默认值: 当前处理核数量 * 2</span></span><br><span class="line"><span class="attr">threads:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># Netty线程池数量,默认值: 当前处理核数量 * 2</span></span><br><span class="line"><span class="attr">nettyThreads:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line"><span class="attr">codec:</span> <span class="type">!&lt;org.redisson.codec.JsonJacksonCodec&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment"># 传输模式</span></span><br><span class="line"><span class="attr">transportMode :</span> <span class="string">&quot;NIO&quot;</span></span><br></pre></td></tr></table></figure>

<p>在application.yml中加入:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">## Redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redisson相关配置, 会导致redis原有配置失效，使用时需注意</span></span><br><span class="line">    <span class="attr">redisson:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">&quot;classpath:redisson-single.yml&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样的好处在于，不想引用redisson的话，只要去除pom中的引用并去除spring.redis.redisson配置即可</p>
</blockquote>
<p>即可使用RedissonClient获取分布式锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">buyWithRedissonLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(redissonClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未配置RedissonClient&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = <span class="string">&quot;xxx_lock_&quot;</span> + productId;</span><br><span class="line">        RLock lock = redissonClient.getLock(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> normalBuy(productId);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.error(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(<span class="string">&quot;获取锁异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再进阶的话就可以再封装一层读写锁</p>
</blockquote>
<blockquote>
<p>另外redis和redisson也支持发布和订阅的功能convertAndSend，有兴趣可以了解下</p>
</blockquote>
<h1 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h1><p>缓存的处理策略一般是：前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。所以可能就会存在以下问题:</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>加一层布隆过滤器</li>
</ul>
<blockquote>
<p>当然一般情况下，在接口层增加校验即可，真正业务发展大了，存在攻击了，所采取的策略不会这么简单</p>
</blockquote>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>加锁</li>
<li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象</li>
<li>设置热点数据永远不过期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用lock解决缓存击穿问题(粗颗粒度锁)</span><br><span class="line">private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用ConcurrentHashMap解决缓存击穿问题(细颗粒度锁-推荐)</span><br><span class="line">private ConcurrentHashMap&lt;String, Lock&gt; lockConcurrentHashMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>针对不同key设置不同的过期时间，过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB</li>
<li>如果缓存数据库是<strong>分布式部署</strong>，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询</li>
<li>设置热点数据永远不过期</li>
</ul>
<h1 id="进阶-Redis部署模式"><a href="#进阶-Redis部署模式" class="headerlink" title="进阶: Redis部署模式"></a>进阶: Redis部署模式</h1><h2 id="standalone-单机-模式"><a href="#standalone-单机-模式" class="headerlink" title="standalone(单机)模式"></a>standalone(单机)模式</h2><p>部署在一台服务器中，并发需求不太高时</p>
<h2 id="master-slaver-主从复制-模式"><a href="#master-slaver-主从复制-模式" class="headerlink" title="master/slaver(主从复制)模式"></a>master/slaver(主从复制)模式</h2><p>部署在多台服务器中，一个主节点，多个从节点</p>
<p><strong>优点</strong></p>
<ul>
<li><p>数据备份: 当一个节点损坏（指不可恢复的硬件损坏）时，数据因为有备份，可以方便恢复</p>
</li>
<li><p>负载均衡：所有客户端都访问一个节点肯定会影响Redis工作效率，有了主从以后，可做读写分离，查询操作就可以通过查询从节点来完成</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<p>master节点挂了以后，redis就不能对外提供写服务了，因为剩下的slave不能成为master</p>
<h3 id="搭建方式"><a href="#搭建方式" class="headerlink" title="搭建方式"></a>搭建方式</h3><p>这里就演示windows docker desktop下的搭建方式, 以下命令都用cmd或者powerShell</p>
<ol>
<li><p>拉取最新redis镜像 <code>docker pull redis</code></p>
</li>
<li><p>从官方下载最新的redis, 找到redis.conf文件，拷贝到本地某个文件夹下，如：D:\env\docker\redis\config\redis.conf</p>
</li>
<li><p>配置并运行主服务器</p>
</li>
</ol>
<p>redis.conf中找到下面的配置并修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bind 127.0.0.1</span><br><span class="line">requirepass 123456 #给redis设置密码</span><br><span class="line">appendonly yes #redis持久化　　默认是no</span><br><span class="line"></span><br><span class="line">dir &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-master&#x2F;data&#x2F; #db等相关目录位置(根据自己需要配置)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bind配置可以修改为bind 0.0.0.0, 或者指定ip, 或者直接注释掉(这里我们选择直接注释掉，允许所有来自于可用网络接口的连接)，appendonly开启后，Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里</p>
</blockquote>
<p>实际项目中可能还需要记录日志，可配置logfile并映射本地文件即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /d/env/docker/redis/conf/redis.conf:/usr/local/etc/redis/redis-master/redis.conf -v /d/env/docker/redis/data/:/usr/local/etc/redis/redis-master/data/ -d redis redis-server /usr/local/etc/redis/redis-master/redis.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>#docker run -p &lt;容器端口&gt;:&lt;主机端口&gt; –name &lt;容器名&gt; -v &lt;本地配置文件映射容器配置文件&gt; -v &lt;本地文件夹挂载到容器文件夹&gt; -d(表示以守护进程方式启动容器) &lt;启动redis服务并制定配置文件(容器中的路径)&gt;</p>
</blockquote>
<ol start="4">
<li><p>使用Redis Desktop Manager测试是否连接成功</p>
</li>
<li><p>配置从服务器1，拷贝新的redis.conf并重命名为redis-slave-1.conf，找到下面的配置并编辑:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 6380</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line">requirepass 123456 #给redis设置密码</span><br><span class="line">appendonly yes #redis持久化　　默认是no</span><br><span class="line"></span><br><span class="line">masterauth 123456 #主服务器密码</span><br><span class="line"># replicaof &lt;master ip&gt; &lt;master port&gt;</span><br><span class="line">replicaof 192.168.31.13 6379 #Redis主机(Master)IP 端口</span><br></pre></td></tr></table></figure>

<blockquote>
<p>replicaof为主服务器的ip+端口(在redis5.x的主从配置中，从机配置要配置 replicaof 参数。而早期版本，要配置的是slaveof参数)，如果主服务器设置了密码则需配置masterauth</p>
</blockquote>
<ol start="6">
<li>运行从服务器1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name redis-slave-1 -p 6380:6380 -v /d/env/docker/redis/conf/redis-slave-1.conf:/usr/local/etc/redis/redis-slave-1/redis.conf -d redis redis-server /usr/local/etc/redis/redis-slave-1/redis.conf</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>按照类似步骤配置并运行从服务器2</li>
</ol>
<p>为了方便，直接拷贝redis-slave-1.conf并修改port即可</p>
<p>redis-slave-2.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 6381</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name redis-slave-2 -p 6381:6381 -v /d/env/docker/redis/conf/redis-slave-2.conf:/usr/local/etc/redis/redis-slave-2/redis.conf -d redis redis-server /usr/local/etc/redis/redis-slave-2/redis.conf</span><br></pre></td></tr></table></figure>

<p>以上便可以搭建1主2从的master/slaver(主从复制)模式, 通过向主服务器写入数据，两个从服务器即会自动同步数据</p>
<blockquote>
<p>如果是本机dockers，可以在每个redis-xx.conf中修改,以便显示声明物理机的ip与port，如redis-slave-1.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replica-announce-ip 192.168.31.13 # 这里写自己的ip地址</span><br><span class="line">replica-announce-port 6380 # 这里写绑定的redis服务端口</span><br></pre></td></tr></table></figure>


<h2 id="sentinel-哨兵-模式"><a href="#sentinel-哨兵-模式" class="headerlink" title="sentinel(哨兵)模式"></a>sentinel(哨兵)模式</h2><p>Sentinel 其实是运行在特殊模式下的 redis server, 部署在多台服务器中, 心跳机制+投票裁决，是建立在主从模式的基础上，这也是目前的<strong>主流方案</strong>, 可参考<a href="https://redis.io/topics/sentinel">官方文章-Redis Sentinel文档</a></p>
<p><strong>优点</strong></p>
<p>有效解决主从模式主库异常手动主从切换的问题</p>
<p><strong>缺点</strong></p>
<p>当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中</p>
<h3 id="搭建方式-1"><a href="#搭建方式-1" class="headerlink" title="搭建方式"></a>搭建方式</h3><p>先搭建1个主服务器和两个从服务器，搭建方式同上面的master/slaver(主从复制)模式，我们还是通过windows docker desktop的方式</p>
<blockquote>
<p>由于 Sentinel 启动，故障切换，日志文件创建 等情况均需要修改配置文件，因此一定要给文件读写权限，因此启动前先 chmod 777 -R /data/redis/ 给所有文件夹配置好权限</p>
</blockquote>
<p>下面再搭建1个哨兵</p>
<ol>
<li>哨兵1</li>
</ol>
<p>从官方下载最新的redis, 找到sentinel.conf文件(windows版的是没有这个文件的，需要自己新建或者官网下载linux版本)，拷贝到本地某个文件夹下，如：D:\env\docker\redis\config\sentinel-1.conf</p>
<p>编辑文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 禁止保护模式</span><br><span class="line">protected-mode no</span><br><span class="line"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br><span class="line">sentinel monitor mymaster 192.168.11.128 6379 1</span><br><span class="line"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br><span class="line">logfile &quot;.&#x2F;sentinel_log.log&quot;</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-1 -p 26379:26379 -v  /d/env/docker/redis/conf/sentinel-1.conf:/usr/local/etc/redis/sentinel-1.conf -d redis redis-sentinel /usr/local/etc/redis/sentinel-1.conf</span><br></pre></td></tr></table></figure>



<p>实际环境中对于哨兵也会有多个，一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，需要使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p>
<p>需先修改sentinel-1.conf中的sentinel monitor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br><span class="line">sentinel monitor mymaster 192.168.11.128 6379 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>哨兵2<br>he<br>拷贝一份sentinel-1.conf, 重命名为sentinel-2.conf，修改端口号即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 26380</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-2 -p 26380:26380 -v  /d/env/docker/redis/conf/sentinel-2.conf:/usr/local/etc/redis/sentinel-2.conf -d redis redis-sentinel /usr/local/etc/redis/sentinel-2.conf</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>哨兵3</li>
</ol>
<p>同样拷贝一份sentinel-1.conf, 重命名为sentinel-3.conf，修改端口号即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 26381</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-3 -p 26381:26381 -v  /d/env/docker/redis/conf/sentinel-3.conf:/usr/local/etc/redis/sentinel-3.conf -d redis redis-sentinel /usr/local/etc/redis/sentinel-3.conf</span><br></pre></td></tr></table></figure>

<p>如果指定了新的dir, 如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Sentinel服务运行时使用的临时文件夹</span><br><span class="line">dir &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis</span><br></pre></td></tr></table></figure>
<p>则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-3 -p 26384:26384  -v  /d/env/docker/redis/conf/sentinel-3.conf:/usr/local/etc/redis-sentinel/sentinel.conf  -v  /d/tmp:/usr/local/etc/redis -d redis redis-sentinel /usr/local/etc/redis-sentinel/sentinel.conf</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意启动的顺序: 首先是主机的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程</p>
</blockquote>
<p>测试</p>
<p>使用redis-cli –p 26379查看信息</p>
<p><img src="sentinel-info.png" alt="sentinel-info"></p>
<p>关闭主服务器，等待30秒， 可以看到已经切换到某个从服务器中了</p>
<blockquote>
<blockquote>
<p>如果是本机dockers，可以在每个sentinel-xx.conf中修改,以便显示声明物理机的ip与port，如sentinel-1.conf</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel announce-ip &lt;ip&gt; # 这里写自己的ip地址</span><br><span class="line">sentinel announce-port &lt;port&gt; # 这里写绑定的redis-sentinel服务端口</span><br></pre></td></tr></table></figure>


<h3 id="Springboot-整合哨兵模式"><a href="#Springboot-整合哨兵模式" class="headerlink" title="Springboot 整合哨兵模式"></a>Springboot 整合哨兵模式</h3><p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">12345</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment">## master 名称</span></span><br><span class="line">      <span class="comment">## 哨兵节点的 ip和端口好，哨兵会托管主从的架构</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:26379</span></span><br></pre></td></tr></table></figure>

<h2 id="cluster-集群-模式"><a href="#cluster-集群-模式" class="headerlink" title="cluster(集群)模式"></a>cluster(集群)模式</h2><p>部署在多台服务器中,3.0版本开始正式引入，cluster的出现是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器，可以理解为是哨兵和主从模式的结合体</p>
<blockquote>
<p>这种模式适合数据量巨大的缓存要求，当数据量不是很大使用sentinel即可</p>
</blockquote>
<p><a href="https://developer.ibm.com/zh/languages/java/articles/know-redis-and-use-it-in-springboot-projects/">IBM开发者文章-了解 Redis 并在 Spring Boot 项目中使用 Redis</a></p>
<blockquote>
<p>Spring Boot 2.4.0「新增RedisCacheMetrics」：用于监控使用redis时的puts、gets、deletes以及缓存命中率等信息<br>此指标信息默认不开启，需你增加配置spring.cache.redis.enable-statistics = true</p>
</blockquote>
<p>笔者使用了某云服务器部署了一些测试项目，结果竟然被爆出对外存在攻击行为，最后发现是被人攻占了redis的端口6379，所以<strong>部署 redis 建议修改默认端口或者限制 IP 访问，开启密码认证功能，并使用强密码。</strong></p>
<p><a href="https://www.baeldung.com/java-redis-mongodb">Redis vs MongoDB</a></p>
<p><a href="https://github.com/jonesun/spring-boot-redis-demo">本文示例源码</a></p>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><h2 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a>Redis为什么快呢？</h2><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几<br>十倍。速度快的原因主要有几点：</p>
<ul>
<li>完全基于内存操作</li>
<li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li>
<li>使用单线程，无上下文的切换成本</li>
<li>基于非阻塞的IO多路复用机制</li>
</ul>
<h2 id="那为什么Redis6-0之后又改用多线程呢"><a href="#那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="那为什么Redis6.0之后又改用多线程呢?"></a>那为什么Redis6.0之后又改用多线程呢?</h2><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程<br>来处理数据的读写和协议解析，执行命令还是使用单线程。</p>
<p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提<br>  高redis的性能。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程1-从Thread到Future再到CompletableFuture</title>
    <url>/20200714/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/36c04c8a/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Java项目编程中，为了充分利用计算机CPU资源，一般开启多个线程来执行异步任务。多线有很多好处，其中最重要的是：</p>
<ul>
<li>可以发挥多核CPU的优势</li>
</ul>
<p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p>
<ul>
<li>防止阻塞</li>
</ul>
<p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>
<h1 id="一、Thread-amp-Runnable"><a href="#一、Thread-amp-Runnable" class="headerlink" title="一、Thread&amp;Runnable"></a>一、Thread&amp;Runnable</h1><p>java1开始，常见的两种创建线程的方式。一种是直接继承Thread，另外一种就是实现Runnable接口。</p>
<p>从源码中可以看到，Thread也是实现Runnable接口的：</p>
 <a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别在于，Thread并没有直接实现run()，而是调用Runnable接口中的run()，所以如果要通过继承Thread类实现多线程，则必须覆写run()方法。</p>
<p>但这两种方式存在一些问题：</p>
<ul>
<li>没有参数</li>
<li>没有返回值</li>
<li>无法抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;starting&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;准备执行thread....&quot;</span>);</span><br><span class="line">      handleWithThread();</span><br><span class="line"><span class="comment">//        handleWithoutThread();</span></span><br><span class="line">      System.out.println(<span class="string">&quot;thread执行完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//执行结果，可以发现线程中出现异常后，主线程并不会停止</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWithThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            makeNPE();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWithoutThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      makeNPE();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeNPE</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span>(s.equals(<span class="string">&quot;abc&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">//do something</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>中断线程interrupt: 调用 interrupt() 方法，表示向当前线程打个招呼，告诉其可以中断线程了，至于什么时候终止，取决于当前线程自己，其实原理跟自定义标志位相似，只是打一个停止的标志，并不会去真的停止线程。<br>这种通过标志位或中断操作的方式能够使线程在终止时可以继续执行内部逻辑，而不是立即停止线程，所以，这种中断线程的方式更加的优雅安全，推荐此种方式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; isInterrupted()默认为false</span><br><span class="line">        while (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;i:&quot;+i);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">thread.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将isInterrupted()设置为true</span><br><span class="line">thread.interrupt();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、Callable"><a href="#二、Callable" class="headerlink" title="二、Callable"></a>二、Callable</h1><p>为了解决上面的问题，java5引入了Callable类。从源码中可以看到Callable的call()方法签名有throws，所以它可以处理受检异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但Callable并不可以单独执行，需要ExecutorService配合线程池使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Future<?>解释，为了可取消性而使用 Future 但又不提供可用的结果，故声明 Future<?> 形式类型、并返回 null 作为底层任务的结果</p>
</blockquote>
<p>可以看到使用线程池时，无论使用Runnable还是Callable，都默认返回Future，下面我们就来看看这个Future是何方神圣。</p>
<h1 id="三、Future"><a href="#三、Future" class="headerlink" title="三、Future"></a>三、Future</h1><p>Future与Callable一样都是java1.5开始引入的。同Callable与Runnable一样，Future也是一个接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mayInterruptIfRunning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否取消</span></span><br><span class="line"><span class="comment">     * 如果在任务正常完成前被取消成功，才返回 true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否完成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取执行结果，如果指定时间内未完成则抛出异常(TimeoutException)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要着重说明下cancel(mayInterruptIfRunning)方法：</p>
<ul>
<li>如果发起cancel时任务还没有开始运行，则随后任务就不会被执行</li>
<li>如果发起cancel时，任务已经执行完成了，则返回false</li>
<li>如果发起cancel时，任务已经被取消过了，则返回false</li>
<li>如果发起cancel时任务已经在运行了，则这时就需要看 mayInterruptIfRunning 参数了：<ul>
<li>如果mayInterruptIfRunning 为true, 则返回true，且当前在执行的任务会被中断</li>
<li>如果mayInterruptIfRunning 为false, 则返回true,且正在执行的任务继续运行，直到它执行完</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;FutureTask中cancel源码如下</span><br><span class="line">    public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">        if (!(state &#x3D;&#x3D; NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">              (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            return false;</span><br><span class="line">        try &#123;    &#x2F;&#x2F; in case call to interrupt throws exception</span><br><span class="line">            if (mayInterruptIfRunning) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread t &#x3D; runner;</span><br><span class="line">                    if (t !&#x3D; null)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; finally &#123; &#x2F;&#x2F; final state</span><br><span class="line">                    STATE.setRelease(this, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由此可以知道Future可以对于具体的Runnable或者Callable任务的执行结果进行<strong>取消</strong>、查询是否完成、获取结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAndCallableTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程开始执行&quot;</span>);</span><br><span class="line">        Future&lt;String&gt; stringFuture = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println( Thread.currentThread().getName() + <span class="string">&quot;执行Callable的call方法&quot;</span>);</span><br><span class="line">                <span class="comment">//因为Callable的call方法会throw异常，故这边无需像Runnable显示try/catch</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println( Thread.currentThread().getName() + <span class="string">&quot;执行Callable的call方法完成&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;这是Callable的返回值&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程继续执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime startLocalTime = LocalTime.now();</span><br><span class="line">        <span class="keyword">while</span> (!stringFuture.isDone()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程等待callable&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ChronoUnit.SECONDS.between(startLocalTime, LocalTime.now()) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程不想等待，取消任务&quot;</span>);</span><br><span class="line">                stringFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String futureResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!stringFuture.isCancelled()) &#123;</span><br><span class="line">                futureResult = stringFuture.get(<span class="number">8</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">&quot;主线程获取到返回值&gt;&gt;&quot;</span> + futureResult);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务已取消&gt;&gt;&quot;</span> + futureResult);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//注意一定要显示shutdown线程池，否则线程池不会自动关闭</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果使用Debug可以发现，实际上ExecutorService返回的是Future的实现类FutureTask，下面我们就了解下FutureTask</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>通过查看源码，可以发现FutureTask实现了RunnableFuture接口，而RunnableFuture又继承了Runnable, Future两个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以就可以解释为什么ExecutorService会返回Future了，因为它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<h2 id="Future不足"><a href="#Future不足" class="headerlink" title="Future不足"></a>Future不足</h2><p>以上是单个Future的使用，但在开发过程中，我们可能会有以下需求</p>
<ul>
<li>将两个异步计算合并为一个（这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果）</li>
<li>等待Future集合中的所有任务都完成</li>
<li>仅等待Future集合中最快结束的任务完成，并返回它的结果</li>
<li>…</li>
</ul>
<p>那么单使用Future是不够的，Future很难直接表述多个Future结果之间的依赖性，没有提供方法去判断第一个完成的任务；同时Future也没有提供Callback机制，只能通过阻塞的get方法去获取结果。</p>
<p>所以java8引入了<strong>CompletableFuture</strong></p>
<h1 id="四、CompletableFuture"><a href="#四、CompletableFuture" class="headerlink" title="四、CompletableFuture"></a>四、CompletableFuture</h1><p>CompletableFuture实现了Future接口，另外还实现了CompletionStage接口(它里面的方法表示的是是在某个运行阶段得到了结果之后要做的事情)</p>
<p>CompletableFuture的命名规则：</p>
<ul>
<li>xxx()：表示该方法将继续在已有的线程中执行；</li>
<li>xxxAsync()：表示将异步在线程池中执行</li>
<li>xxxApplyxxx(): 表示变换结果</li>
<li>xxxAcceptxxx(): 表示消费结果</li>
</ul>
<h2 id="create-创建CompletableFuture任务"><a href="#create-创建CompletableFuture任务" class="headerlink" title="create-创建CompletableFuture任务"></a>create-创建CompletableFuture任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果没有指定，默认会在ForkJoinPool.commonPool()中执行</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor);</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCreateFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">      CompletableFuture&lt;Void&gt; runAsyncFuture = CompletableFuture</span><br><span class="line">              .runAsync(() -&gt; System.out.println(<span class="string">&quot;hello world from runAsync!&quot;</span>),</span><br><span class="line">                      executor);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//supplyAsync的使用</span></span><br><span class="line">      CompletableFuture&lt;String&gt; supplyAsyncFuture = CompletableFuture</span><br><span class="line">              .supplyAsync(() -&gt; <span class="string">&quot;hello world from supplyAsync&quot;</span>,</span><br><span class="line">                      executor);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//阻塞等待，runAsync的future无返回值</span></span><br><span class="line">      runAsyncFuture.join();</span><br><span class="line"></span><br><span class="line">      String supplyAsyncResult = supplyAsyncFuture.join();</span><br><span class="line">      System.out.println(<span class="string">&quot;supplyAsyncResult: &quot;</span> + supplyAsyncResult);</span><br><span class="line"></span><br><span class="line">      executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CompletableFuture默认运行使用的是ForkJoin的的线程池，这个线程池默认线程数是CPU的核数，所以强烈建议使用后两个方法，根据任务类型不同，主动创建线程池，进行资源隔离，避免互相干<br>扰</p>
</blockquote>
<blockquote>
<blockquote>
<p>! 在线程操作中，可以使用 join() 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行，join在遇到底层的异常时，会抛出未受查的CompletionException，get在遇到底层异常时，会抛出受查异常ExecutionException</p>
</blockquote>
</blockquote>
<h2 id="串行执行线程"><a href="#串行执行线程" class="headerlink" title="串行执行线程"></a>串行执行线程</h2><p><strong>任务完成则执行</strong></p>
<h3 id="thenRunXXX-不关心上一个任务的结果，无返回值"><a href="#thenRunXXX-不关心上一个任务的结果，无返回值" class="headerlink" title="thenRunXXX: 不关心上一个任务的结果，无返回值"></a>thenRunXXX: 不关心上一个任务的结果，无返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;Void&gt; thenRun(Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action, Executor executor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testThenRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">      CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//线程休眠优先使用TimeUnit的方法</span></span><br><span class="line">              <span class="comment">//如果需要休眠1分钟TimeUnit.MINUTES.sleep(1);Thread.sleep(60000);明显可读性TimeUnit更强</span></span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="comment">//中断线程会抛出此异常</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello1&quot;</span>;</span><br><span class="line">      &#125;).thenRun(() -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">      <span class="comment">//这里仅仅为测试方便让主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭。实际开发不能这么写</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="thenAcceptXXX-消费结果，无返回值"><a href="#thenAcceptXXX-消费结果，无返回值" class="headerlink" title="thenAcceptXXX: 消费结果，无返回值"></a>thenAcceptXXX: 消费结果，无返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这些方法只是针对结果进行消费，入参是Consumer，没有返回值</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThenAccept</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//返回值在回调中</span></span><br><span class="line">      CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello&quot;</span>).thenAccept(s -&gt; System.out.println(s+<span class="string">&quot; world&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thenApplyXXX-变换结果，有返回值"><a href="#thenApplyXXX-变换结果，有返回值" class="headerlink" title="thenApplyXXX: 变换结果，有返回值"></a>thenApplyXXX: 变换结果，有返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这些方法的输入是上一个阶段计算后的结果，返回值是经过变换后的结果</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)        </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testThenApply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot; world&quot;</span>).join();</span><br><span class="line">    <span class="comment">//同样可以使用get进行阻塞获取值，返回值需自己获取</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>thenApply 只可以执行正常的任务，任务出现异常则会不执行 thenApply 方法</p>
</blockquote>
<h3 id="thenComposeXXX-将结果作为参数传递给下一个操作，有返回值"><a href="#thenComposeXXX-将结果作为参数传递给下一个操作，有返回值" class="headerlink" title="thenComposeXXX: 将结果作为参数传递给下一个操作，有返回值"></a>thenComposeXXX: 将结果作为参数传递给下一个操作，有返回值</h3><p>第一个操作完成时，将其结果作为参数传递给第二个操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>thenCompose的返回值是CompletionStage，可以和其他CompletableFuture任务更好地配套组合使用</p>
</blockquote>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThenCompose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;t1=&quot;</span> + t);</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;).thenCompose(param -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">int</span> t = param * <span class="number">2</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;t2=&quot;</span> + t);</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;)).join();</span><br><span class="line">    System.out.println(<span class="string">&quot;result : &quot;</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程并行执行"><a href="#线程并行执行" class="headerlink" title="线程并行执行"></a>线程并行执行</h2><p><strong>两个CompletableFuture[并行]执行完，然后执行</strong></p>
<h3 id="runAfterBothXXX-不依赖上两个任务的结果，无返回值"><a href="#runAfterBothXXX-不依赖上两个任务的结果，无返回值" class="headerlink" title="runAfterBothXXX: 不依赖上两个任务的结果，无返回值"></a>runAfterBothXXX: 不依赖上两个任务的结果，无返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span><br></pre></td></tr></table></figure>

<p>两个CompletionStage都运行完后执行</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testRunAfterBoth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    &#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;), () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    <span class="comment">//这里仅仅为测试方便，实际开发不能这么写</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thenAcceptBothXXX-依赖上两个任务的结果，无返回值"><a href="#thenAcceptBothXXX-依赖上两个任务的结果，无返回值" class="headerlink" title="thenAcceptBothXXX: 依赖上两个任务的结果，无返回值"></a>thenAcceptBothXXX: 依赖上两个任务的结果，无返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)  </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)              </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action, Executor executor) </span><br></pre></td></tr></table></figure>

<h3 id="thenCombineXXX-依赖上两个任务的结果，有返回值"><a href="#thenCombineXXX-依赖上两个任务的结果，有返回值" class="headerlink" title="thenCombineXXX: 依赖上两个任务的结果，有返回值"></a>thenCombineXXX: 依赖上两个任务的结果，有返回值</h3><p>结合两个CompletionStage的结果，进行转化后返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;需要上一阶段的返回值，并且other代表的CompletionStage也要返回值之后，把这两个返回值，进行转换后返回指定类型的值</span><br><span class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</span><br><span class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)       </span><br><span class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor) </span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testThenCombine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">      &#125;), (s1, s2) -&gt; s1 + <span class="string">&quot; &quot;</span> + s2).join();</span><br><span class="line">      System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>线程并行执行，谁先执行完则谁触发下一个任务</strong></p>
<h3 id="runAfterEitherXXX-不依赖前一任务的结果，无返回值"><a href="#runAfterEitherXXX-不依赖前一任务的结果，无返回值" class="headerlink" title="runAfterEitherXXX: 不依赖前一任务的结果，无返回值"></a>runAfterEitherXXX: 不依赖前一任务的结果，无返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)   </span><br><span class="line">public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span><br></pre></td></tr></table></figure>

<h3 id="acceptEitherXXX-依赖最先完成任务的结果，无返回值"><a href="#acceptEitherXXX-依赖最先完成任务的结果，无返回值" class="headerlink" title="acceptEitherXXX: 依赖最先完成任务的结果，无返回值"></a>acceptEitherXXX: 依赖最先完成任务的结果，无返回值</h3><p>两个CompletionStage，谁计算的快，就用那个CompletionStage的结果进行下一步的<strong>消费</strong>操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)       </span><br><span class="line">public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptEither</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    &#125;).acceptEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;), System.out::println);</span><br><span class="line">    <span class="keyword">while</span> (!future.isDone()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyToEitherXXX-依赖最先完成任务的结果，有返回值"><a href="#applyToEitherXXX-依赖最先完成任务的结果，有返回值" class="headerlink" title="applyToEitherXXX: 依赖最先完成任务的结果，有返回值"></a>applyToEitherXXX: 依赖最先完成任务的结果，有返回值</h3><p>两个CompletionStage，谁计算的快，就用那个CompletionStage的结果进行下一步的转化操作(<strong>需要注意的是，两个CompletionStage都会执行完</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;两种渠道完成同一个事情，就可以调用这个方法，找一个最快的结果进行处理返回</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn) </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)         </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn, Executor executor)  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApplyToEither</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">      &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">      &#125;), s -&gt; s).join();</span><br><span class="line">      System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="处理任务结果或者异常"><a href="#处理任务结果或者异常" class="headerlink" title="处理任务结果或者异常"></a>处理任务结果或者异常</h2><h3 id="exceptionally-处理异常"><a href="#exceptionally-处理异常" class="headerlink" title="exceptionally: 处理异常"></a>exceptionally: 处理异常</h3><p>运行时出现了异常，通过exceptionally进行补偿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletionStage&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExceptionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;测试一下异常情况&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//修复空指针</span></span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="handleXXX-任务完成或者异常时运行fn，返回值为fn的返回值"><a href="#handleXXX-任务完成或者异常时运行fn，返回值为fn的返回值" class="headerlink" title="handleXXX: 任务完成或者异常时运行fn，返回值为fn的返回值"></a>handleXXX: 任务完成或者异常时运行fn，返回值为fn的返回值</h3><p>运行完成时，对结果的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)    </span><br></pre></td></tr></table></figure>

<p>handle 方法和 thenApply 方法处理方式基本一样。不同的是 <strong>handle 是在任务完成后再执行，还可以处理异常的任务</strong>。thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法。</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//出现异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;测试一下异常情况&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    &#125;).handle((s, t) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    System.out.println(<span class="string">&quot;result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="whenCompleteXXX-任务完成或者异常时运行action，有返回值"><a href="#whenCompleteXXX-任务完成或者异常时运行action，有返回值" class="headerlink" title="whenCompleteXXX: 任务完成或者异常时运行action，有返回值"></a>whenCompleteXXX: 任务完成或者异常时运行action，有返回值</h3><p>当运行完成时，对结果的记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这里为什么要说成记录，因为这几个方法都会返回CompletableFuture，当Action执行完毕后它的结果返回原始的CompletableFuture的计算结果或者返回异常。所以不会对结果产生任何的作用</span><br><span class="line">public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action) </span><br><span class="line">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action) </span><br><span class="line">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor)  </span><br></pre></td></tr></table></figure>

<ul>
<li>whenComplete与handle的区别在于，它不参与返回结果的处理，把它当成监听器即可</li>
<li>即使异常被处理，在CompletableFuture外层，异常也会再次复现</li>
<li>使用whenCompleteAsync时，返回结果则需要考虑多线程操作问题，毕竟会出现两个线程同时操作一个结果</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWhenComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;测试一下异常情况&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    &#125;).whenComplete((s, t) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;whenComplete&gt;&gt;s: &quot;</span> + s);</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;whenComplete&gt;&gt;throwable&quot;</span> + t.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;exceptionally&gt;&gt;throwable: &quot;</span> + e.getMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world from exceptionally&quot;</span>;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    System.out.println(<span class="string">&quot;result: &quot;</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多个任务的简单组合"><a href="#多个任务的简单组合" class="headerlink" title="多个任务的简单组合"></a>多个任务的简单组合</h2><h3 id="allOf-所有任务都执行完成后"><a href="#allOf-所有任务都执行完成后" class="headerlink" title="allOf: 所有任务都执行完成后"></a>allOf: 所有任务都执行完成后</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAllOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      CompletableFuture&lt;Void&gt; future =  CompletableFuture.allOf(future1,future2,future3);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get()); <span class="comment">//return null</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到使用allOf的话，默认是没有返回值的。当需要获取返回值做一些处理时，可以利用java8的Stream来组合多个future的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAllOf1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(future1, future2, future3)</span><br><span class="line">              .thenApply(v -&gt;</span><br><span class="line">                      Stream.of(future1, future2, future3)</span><br><span class="line">                              .map(CompletableFuture::join)</span><br><span class="line">                              .collect(Collectors.joining(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">              .thenAccept(System.out::println);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get(<span class="number">20</span>, TimeUnit.SECONDS)); <span class="comment">//return null</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anyOf-任意任务执行完成后"><a href="#anyOf-任意任务执行完成后" class="headerlink" title="anyOf: 任意任务执行完成后"></a>anyOf: 任意任务执行完成后</h3><p>多个CompletableFuture谁计算的快，就用那个CompletionStage的结果进行下一步的<strong>消费</strong>操作。</p>
<p>anyOf是CompletableFuture静态方法，和 acceptEither、applyToEither的区别在于，后两者只能使用在两个future中，而anyOf可以使用在多个future中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnyOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;future1执行...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;future1执行完成&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;from future1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;future2执行...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;future2执行完成&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;from future2&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;future3执行...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;future3执行完成&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;from future3&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(future1, future2, future3);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="取消执行线程任务"><a href="#取消执行线程任务" class="headerlink" title="取消执行线程任务"></a>取消执行线程任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果任务未完成,则返回异常</span><br><span class="line">public boolean cancel(boolean mayInterruptIfRunning) </span><br><span class="line">&#x2F;&#x2F;任务是否取消</span><br><span class="line">public boolean isCancelled()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture</span><br><span class="line">            .supplyAsync(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>);  &#125; <span class="keyword">catch</span> (Exception e) &#123; &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .thenApply(data -&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;任务取消前:&quot;</span> + future.isCancelled());</span><br><span class="line">    <span class="comment">// 如果任务未完成,则返回异常,需要对使用exceptionally，handle 对结果处理</span></span><br><span class="line">    future.cancel(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务取消后:&quot;</span> + future.isCancelled());</span><br><span class="line">    future = future.exceptionally(e -&gt; &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//任务取消前:false</span></span><br><span class="line"><span class="comment">//任务取消后:true</span></span><br><span class="line"><span class="comment">//java.util.concurrent.CancellationException</span></span><br><span class="line"><span class="comment">//at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2276)</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h2 id="任务的获取和完成与否判断"><a href="#任务的获取和完成与否判断" class="headerlink" title="任务的获取和完成与否判断"></a>任务的获取和完成与否判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任务是否执行完成</span><br><span class="line">public boolean isDone()</span><br><span class="line">&#x2F;&#x2F;阻塞等待 获取返回值</span><br><span class="line">public T join()</span><br><span class="line">&#x2F;&#x2F; 阻塞等待 获取返回值,区别是get需要返回受检异常</span><br><span class="line">public T get()</span><br><span class="line">&#x2F;&#x2F;等待阻塞一段时间，并获取返回值</span><br><span class="line">public T get(long timeout, TimeUnit unit)</span><br><span class="line">&#x2F;&#x2F;未完成则返回指定value</span><br><span class="line">public T getNow(T valueIfAbsent)</span><br><span class="line">&#x2F;&#x2F;未完成，使用value作为任务执行的结果，任务结束。需要future.get获取</span><br><span class="line">public boolean complete(T value)</span><br><span class="line">&#x2F;&#x2F;未完成，则是异常调用,返回异常结果，任务结束</span><br><span class="line">public boolean completeExceptionally(Throwable ex)</span><br><span class="line">&#x2F;&#x2F;判断任务是否因发生异常结束的</span><br><span class="line">public boolean isCompletedExceptionally()</span><br><span class="line">&#x2F;&#x2F;强制地将返回值设置为value，无论该之前任务是否完成；类似complete</span><br><span class="line">public void obtrudeValue(T value)</span><br><span class="line">&#x2F;&#x2F;强制地让异常抛出，异常返回，无论该之前任务是否完成；类似completeExceptionally</span><br><span class="line">public void obtrudeException(Throwable ex) </span><br></pre></td></tr></table></figure>


<h3 id="completedFuture"><a href="#completedFuture" class="headerlink" title="completedFuture()"></a>completedFuture()</h3><p>将常量值作为CompletableFuture返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">completedFutureTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">      CompletableFuture&lt;String&gt; completableFuture = CompletableFuture</span><br><span class="line">              .supplyAsync(() -&gt; <span class="string">&quot;hello&quot;</span>, executorService)</span><br><span class="line">              .thenComposeAsync(data -&gt; &#123;</span><br><span class="line">                <span class="comment">//thenCompose - 依赖上一个任务的结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;上一个结果: &quot;</span> + data);</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;last&quot;</span>);</span><br><span class="line">              &#125;, executorService);</span><br><span class="line"></span><br><span class="line">      System.out.println(completableFuture.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//上一个结果: hello</span></span><br><span class="line"><span class="comment">//        last</span></span><br></pre></td></tr></table></figure>

<p>以上是CompletableFuture的常用方法，另外由于方法都是返回CompletableFuture，故可以通过各种排列组合，完成日常工作中的复杂逻辑。如获取商品的信息时，需要调用多个服务来处理这一个请求并返回结果等</p>
<h2 id="Java9新增"><a href="#Java9新增" class="headerlink" title="Java9新增"></a>Java9新增</h2><ol>
<li>支持对异步方法的超时调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">orTimeout()</span><br><span class="line">completeOnTimeout()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>支持延迟调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)</span><br><span class="line">Executor delayedExecutor(long delay, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<h2 id="生产建议"><a href="#生产建议" class="headerlink" title="生产建议"></a>生产建议</h2><p>事实上，如果每个操作都很简单的话没有必要用这种多线程异步的方式，因为创建线程还需要时间，还不如直接同步执行来得快。</p>
<p>事实证明，只有当每个操作很复杂需要花费相对很长的时间（比如，调用多个其它的系统的接口；比如，商品详情页面这种需要从多个系统中查数据显示的）的时候用CompletableFuture才合适，不然区别真的不大，还不如顺序同步执行。</p>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>在生产环境下，不建议直接使用上述示例代码形式。因为示例代码中使用的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>结合源码来看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_COMMON_POOL =</span><br><span class="line">        (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class="line"><span class="comment">     * support parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor ASYNC_POOL = USE_COMMON_POOL ?</span><br><span class="line">        ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Fallback if ForkJoinPool.commonPool() cannot support parallelism **/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123; <span class="keyword">new</span> Thread(r).start(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多核情况下，默认使用ForkJoinPool.commonPool()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要说明的是parallelStream和CompletableFuture默认使用的都是 ForkJoinPool.commonPool() 默认线程池；</p>
</blockquote>
<p>基于服务器内核的限制，如果你是八核，每次线程只能起八个;适用于对list密集计算操作充分利用CPU资源，如果需要调用远端服务不建议使用</p>
<p>如果所有 CompletableFuture 都使用默认<a href="/20200728/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/a490755">ForkJoinPool.commonPool()</a> 线程池，一旦有任务执行很慢的 I/O 操作，就会导致所有线<br>程都阻塞在 I/O 操作上，进而影响系统整体性能。<br>所以，建议大家在生产环境使用时，根据不同的业务类型创建不同的线程池，以避免互相影响。</p>
<h1 id="五、延伸"><a href="#五、延伸" class="headerlink" title="五、延伸"></a>五、延伸</h1><p>可以看到CompletableFuture的写法与特性跟RxJava很像，但应用场景还是有些区别的：</p>
<table>
<thead>
<tr>
<th>composable</th>
<th>lazy</th>
<th>resuable</th>
<th>async</th>
<th>cached</th>
<th>push</th>
<th>back</th>
<th>pressure</th>
</tr>
</thead>
<tbody><tr>
<td>CompletableFuture</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Stream</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Observable(RxJava1)</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Observable(RxJava2)</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Flowable(RxJava2)</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>有关rxjava和stream的用法，限于篇幅，后面进行介绍</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>future</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程2-线程池</title>
    <url>/20200723/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/87bed628/</url>
    <content><![CDATA[<h1 id="一、使用线程池的好处"><a href="#一、使用线程池的好处" class="headerlink" title="一、使用线程池的好处"></a>一、使用线程池的好处</h1><ol>
<li>降低系统资源消耗, 通过重用已存在的线程, 降低线程创建和销毁造成的消耗</li>
<li>提高系统响应速度, 当有任务到达时, 通过复用已存在的线程, 无需等待新线程的创建便能立即执行</li>
<li>方便线程并发数的管控。因为线程若是无限制的创建, 可能会导致内存占用过多而产生OOM, 并且会造成cpu过度切换（cpu切换线程是有时间成本的-需要保持当前执行线程的现场, 并恢复要执行线程的现场）。</li>
<li>提供更强大的功能, 如延时定时线程池</li>
<li>……</li>
</ol>
<blockquote>
<p>JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。</p>
</blockquote>
<h1 id="二、线程池实现"><a href="#二、线程池实现" class="headerlink" title="二、线程池实现"></a>二、线程池实现</h1><p>使用Executors中创建线程池的快捷方法, 实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor、CompletableFuture默认使用的是ForkJoinPool）</p>
<h2 id="线程池设计"><a href="#线程池设计" class="headerlink" title="线程池设计"></a>线程池设计</h2><p><img src="excutorUML.png" alt="executorUML"> </p>
 <a id="more"></a>

<ul>
<li><p>Executor</p>
<p>  顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。<br>  用户无需关注如何创建线程, 如何调度线程来执行任务, 用户只需提供Runnable对象, 将任务的运行逻辑提交到执行器(Executor)中, 由Executor框架完成线程的调配和任务的执行部分。</p>
</li>
<li><p>ExecutorService</p>
<p>  ExecutorService接口增加了一些能力：</p>
<ul>
<li>扩充执行任务的能力, 比如获取任务的执行结果、取消任务等功能，补充可以为一个或一批异步任务生成Future的方法</li>
<li>提供了管控线程池的方法, 比如停止线程池、关闭线程池、以及阻塞等待线程池完全终止的方法</li>
</ul>
</li>
</ul>
<ul>
<li><p>AbstractExecutorService</p>
<p>  AbstractExecutorService则是上层的抽象类, 将执行任务的流程串联了起来, 从而使得下层的实现类 ThreadPoolExecutor 只需要实现一个执行任务的方法即可</p>
</li>
<li><p>ThreadPoolExecutor</p>
<p>  最下层的实现类ThreadPoolExecutor实现最复杂的运行部分, ThreadPoolExecutor将会一方面维护自身的生命周期, 另一方面同时管理线程和任务, 使两者良好的结合从而执行并行任务</p>
</li>
</ul>
<h2 id="线程池运行流程"><a href="#线程池运行流程" class="headerlink" title="线程池运行流程"></a>线程池运行流程</h2><p><img src="threadPoolExecutor-1.png" alt="image"> </p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p>
<p>线程池的运行主要分成两部分：</p>
<h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><p>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p>
<ol>
<li><p>直接申请线程执行该任务</p>
</li>
<li><p>缓冲到队列中等待线程执行</p>
</li>
<li><p>拒绝该任务</p>
</li>
</ol>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime, TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime, TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory)</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime, TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime, TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><h4 id="int-corePoolSize"><a href="#int-corePoolSize" class="headerlink" title="int corePoolSize"></a>int corePoolSize</h4><p>线程池中的核心线程数, 默认情况下, 当初始化线程池时，会创建核心线程进入等待状态, 即便他们在线程池中处于空闲状态，从而降低了任务一来时要创建新线程的时间和性能开销。它的数量决定了添加的任务是开辟新的线程去执行, 还是放到workQueue任务队列中去。</p>
<p>除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候, 这时候处于闲置的核心线程在等待新任务到来时会有超时策略, 这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间, 闲置的核心线程就会被终止。</p>
<h4 id="int-maximumPoolSize"><a href="#int-maximumPoolSize" class="headerlink" title="int maximumPoolSize"></a>int maximumPoolSize</h4><p>线程池中所容纳的最大线程数, 如果活动的线程达到这个数值以后, 后续的新任务将会被阻塞。包含核心线程数+非核心线程数。这个参数会根据你使用的workQueue任务队列的类型, 决定线程池会开辟的最大线程数量。</p>
<h4 id="long-keepAliveTime"><a href="#long-keepAliveTime" class="headerlink" title="long keepAliveTime"></a>long keepAliveTime</h4><p>指定当线程池中空闲线程数量超过corePoolSize时, 多余的线程会在多长时间内被销毁</p>
<p>非核心线程闲置时的超时时长, 对于非核心线程, 闲置时间超过这个时间, 非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候, 这个超时时间才会对核心线程产生效果</p>
<h4 id="TimeUnit-unit"><a href="#TimeUnit-unit" class="headerlink" title="TimeUnit unit"></a>TimeUnit unit</h4><p>keepAliveTime的单位, TimeUnit是一个枚举类型, 其包括：</p>
<ul>
<li>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000</li>
<li>MICROSECONDS ： 1微秒 = 1毫秒 / 1000</li>
<li>MILLISECONDS ： 1毫秒 = 1秒 /1000</li>
<li>SECONDS ： 秒</li>
<li>MINUTES ： 分</li>
<li>HOURS ： 小时</li>
<li>DAYS ： 天</li>
</ul>
<h4 id="BlockingQueue-workQueue"><a href="#BlockingQueue-workQueue" class="headerlink" title="BlockingQueue workQueue"></a>BlockingQueue workQueue</h4><p>任务队列, 由于任务可能会有很多，而线程就那么几个，所以那么还未被执行的任务就进入队列中排队，可以选择下面几个阻塞队列：</p>
<ol>
<li><p>SynchronousQueue-直接递交</p>
<p> 内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在</p>
<p> 这种策略会将提交的任务直接传送给工作线程，而不持有。如果当前没有工作线程来处理，即任务放入队列失败，则根据线程池的实现，会引发新的工作线程创建，因此新提交的任务会被处理。这种策略在当提交的一批任务之间有依赖关系的时候避免了锁竞争消耗。值得一提的是，这种策略最好是配合unbounded线程数来使用，从而避免任务被拒绝。同时我们必须要考虑到一种场景，当任务到来的速度大于任务处理的速度，将会引起无限制的线程数不断的增加。</p>
</li>
<li><p>ArrayBlockingQueue-有界队列</p>
<p> 基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序</p>
<p> 有界队列如ArrayBlockingQueue帮助限制资源的消耗，但是不容易控制。队列长度和maximumPoolSize这两个值会相互影响，使用大的队列和小maximumPoolSize会减少CPU的使用、操作系统资源、上下文切换的消耗，但是会降低吞吐量，如果任务被频繁的阻塞如IO线程，系统其实可以调度更多的线程。使用小的队列通常需要大maximumPoolSize，从而使得CPU更忙一些，但是又会增加降低吞吐量的线程调度的消耗。总结一下是IO密集型可以考虑多些线程来平衡CPU的使用，CPU密集型可以考虑少些线程减少线程调度的消耗。</p>
</li>
<li><p>LinkedBlockingQueue-无界队列</p>
<p> 基于链表实现的阻塞队列, 该队列按照FIFO（先进先出）原则对队列中的元素进行排序</p>
<p> 使用无界队列如LinkedBlockingQueue没有指定最大容量的时候，将会引起当核心线程都在忙的时候，新的任务被放在队列上，因此，永远不会有大于corePoolSize的线程被创建，因此maximumPoolSize参数将失效。这种策略比较适合所有的任务都不相互依赖，独立执行。举个例子，如网页服务器中，每个线程独立处理请求。但是当任务处理速度小于任务进入速度的时候会引起队列的无限膨胀。</p>
</li>
<li><p>PriorityBlockingQueue-具有优先级的无限阻塞队列</p>
<p> 根据给定的优先级策略来排序, 可在子线程中实现Comparable接口来实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int compareTo(ThreadTask o) &#123;</span><br><span class="line">        &#x2F;&#x2F;当前对象和其他对象做比较，当前优先级大就返回-1，优先级小就返回1,值越小优先级越高</span><br><span class="line">        return this.priority &gt; o.priority ? -1 : 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DelayQueue-延时队列</p>
</li>
</ol>
<p>要求元素都实现Delayed接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</p>
<ol start="6">
<li>通过实现BlockingQueue接口自定义阻塞队列</li>
</ol>
<blockquote>
<p>有界队列：就是有固定大小的队列。比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0，只是在生产者和消费者中做中转用的 SynchronousQueue。</p>
</blockquote>
<blockquote>
<p>无界队列：指的是没有设置固定大小的队列。这些队列的特点是可以直接入列，直到溢出。当然现实几乎不会有到这么大的容量（超过 Integer.MAX_VALUE），所以从使用者的体验上，就相当于 “无界”。比如没有设定固定大小的 LinkedBlockingQueue</p>
</blockquote>
<h4 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h4><p>线程工厂, 用于创建线程, 一般用默认即可；通过自定义ThreadFactory, 可以按需要对线程池中创建的线程进行一些特殊的设置, 如命名、优先级等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new ThreadFactory() &#123;</span><br><span class="line">    private final AtomicInteger mCount &#x3D; new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">    public Thread new Thread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r,&quot;AsyncTask #&quot; + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RejectedExecutionHandler-handler"><a href="#RejectedExecutionHandler-handler" class="headerlink" title="RejectedExecutionHandler handler"></a>RejectedExecutionHandler handler</h4><p> 拒绝策略；当任务太多来不及处理时, 如何拒绝任务: </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务并直接抛出RejectedExecutionException异常(默认拒绝策略)</td>
<td>如果是比较关键的业务, 推荐此策略, 这样在系统不能承载更大的并发量时,能够及时的通过异常发现。故需做好日志和警报</td>
</tr>
<tr>
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由调用线程(提交任务的线程)处理</td>
<td>适用于让所有任务都执行完毕, 比如存在大量计算的任务，多线程仅仅是增大吞吐量的手段, 最终必须让每个任务都执行完毕</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardPolicy</td>
<td>直接丢弃任务(不抛异常)</td>
<td>因为使用此策略无法发现系统的异常状态, 故一般用于一些无关紧要的业务</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>丢弃队列最前面的任务, 然后重新提交被拒绝的任务</td>
<td>如果业务中允许老任务, 则可以采用</td>
</tr>
<tr>
<td>自定义实现RejectedExecutionHandler</td>
<td>通过实现RejectedExecutionHandler接口自定义handler</td>
<td>如记录日志或持久化不能处理的任务</td>
</tr>
</tbody></table>
<h3 id="线程池和装修公司"><a href="#线程池和装修公司" class="headerlink" title="线程池和装修公司"></a>线程池和装修公司</h3><p>  以运营一家装修公司做个比喻。公司在办公地点等待客户来提交装修请求；公司有固定数量的正式工以维持运转；<br>  旺季业务较多时, 新来的客户请求会被排期, 比如接单后告诉用户一个月后才能开始装修；当排期太多时, 为避免用户等太久, 公司会通过某些渠道（比如人才市场、熟人介绍等）雇佣一些临时工（注意, 招聘临时工是在排期排满之后）；<br>  如果临时工也忙不过来, 公司将决定不再接收新的客户, 直接拒单。</p>
<p>线程池就是程序中的“装修公司”, 代劳各种脏活累活。上面的过程对应到线程池上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line">  int corePoolSize, &#x2F;&#x2F; 正式工数量</span><br><span class="line">  int maximumPoolSize, &#x2F;&#x2F; 工人数量上限, 包括正式工和临时工</span><br><span class="line">  long keepAliveTime, TimeUnit unit, &#x2F;&#x2F; 临时工游手好闲的最长时间, 超过这个时间将被解雇</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue, &#x2F;&#x2F; 排期队列</span><br><span class="line">  ThreadFactory threadFactory, &#x2F;&#x2F; 招人渠道</span><br><span class="line">  RejectedExecutionHandler handler) &#x2F;&#x2F; 拒单方式</span><br></pre></td></tr></table></figure>

<h2 id="ThreadPoolExecutor执行流程"><a href="#ThreadPoolExecutor执行流程" class="headerlink" title="ThreadPoolExecutor执行流程"></a>ThreadPoolExecutor执行流程</h2><p>当一个任务被添加进线程池时：</p>
<ol>
<li><p>线程数量未达到corePoolSize, 则新建一个线程执行任务, 即使此时线程池中存在空闲线程</p>
</li>
<li><p>线程数量达到corePoolSize时, 则将任务放入队列workQueue中, 等待线程池中任务调度执行</p>
</li>
<li><p>当队列workQueue已满, 且maximumPoolSize&gt;corePoolSize时, 则创建新线程执行任务</p>
</li>
<li><p>当队列workQueue已满, 总线程数又达到了maximumPoolSize时, 就会执行拒绝策略RejectedExecutionHandler</p>
</li>
</ol>
<p><img src="executor-submit.png" alt="image"> </p>
<p>另外</p>
<ol>
<li><p>当线程池中超过corePoolSize线程, 空闲时间达到keepAliveTime时, 关闭空闲线程</p>
</li>
<li><p>当设置allowCoreThreadTimeOut(true)时, 线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</p>
</li>
</ol>
<p>由此可以看出, 可能会有以下问题：</p>
<ul>
<li>corePoolSize和maximumPoolSize设置不当会影响效率, 甚至耗尽线程</li>
<li>workQueue设置不当容易导致OOM</li>
<li>handler设置不当会导致提交任务时抛出异常</li>
</ul>
<h2 id="向ThreadPoolExecutor添加任务"><a href="#向ThreadPoolExecutor添加任务" class="headerlink" title="向ThreadPoolExecutor添加任务"></a>向ThreadPoolExecutor添加任务</h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>执行runnable, 没有返回值</p>
<h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><p>提交一个线程任务, 可以接受回调函数的返回值, 适用于需要处理返回着或者异常的业务场景 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h2><p>线程池的处理结果、以及处理过程中的异常都被包装到Future中, 并在调用Future.get()方法时获取, 执行过程中的异常会被包装成ExecutionException, submit()方法本身不会传递结果和任务执行过程中的异常</p>
<h3 id="获取单个结果"><a href="#获取单个结果" class="headerlink" title="获取单个结果"></a>获取单个结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newCachedThreadPool(4);</span><br><span class="line">Future&lt;Object&gt; future &#x3D; executorService.submit(new Callable&lt;Object&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object call() throws Exception &#123;</span><br><span class="line">            throw new RuntimeException(&quot;exception in call~&quot;);&#x2F;&#x2F; 该异常会在调用Future.get()时传递给调用者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">try &#123;</span><br><span class="line">  Object result &#x3D; future.get();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">  &#x2F;&#x2F; interrupt</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">  &#x2F;&#x2F; exception in Callable.call()</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单个任务的超时时间"><a href="#单个任务的超时时间" class="headerlink" title="单个任务的超时时间"></a>单个任务的超时时间</h3><p>V Future.get(long timeout, TimeUnit unit)方法可以指定等待的超时时间, 超时未完成会抛出TimeoutException。</p>
<h3 id="获取多个结果"><a href="#获取多个结果" class="headerlink" title="获取多个结果"></a>获取多个结果</h3><p>如果向线程池提交了多个任务, 要获取这些任务的执行结果, 可以依次调用Future.get()获得。</p>
<p>但对于这种场景, 更应该使用ExecutorCompletionService, ExecutorCompletionService提供了等待所有任务执行结束的有效方式</p>
<p>该类的take()方法总是阻塞等待某一个任务完成, 然后返回该任务的Future对象。向CompletionService批量提交任务后, 只需调用相同次数的CompletionService.take()方法, 就能获取所有任务的执行结果, 获取顺序是任意的, 取决于任务的完成顺序</p>
<blockquote>
<p>CompletionService：一种执行者，可将submit的多个任务的结果按照完成的先后顺序存入一个内部队列，然后可以使用take方法从队列中依次取出结果并移除，如果调用take时计算未完成则会阻塞</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void solve(Executor executor, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span><br><span class="line">   throws InterruptedException, ExecutionException &#123;</span><br><span class="line">   </span><br><span class="line">   CompletionService&lt;Result&gt; ecs &#x3D; new ExecutorCompletionService&lt;Result&gt;(executor);&#x2F;&#x2F; 构造器</span><br><span class="line">   </span><br><span class="line">   for (Callable&lt;Result&gt; s : solvers) &#123;&#x2F;&#x2F; 提交所有任务</span><br><span class="line">       ecs.submit(s);</span><br><span class="line">   &#125;</span><br><span class="line">   int n &#x3D; solvers.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; n; ++i) &#123;&#x2F;&#x2F; 获取每一个完成的任务</span><br><span class="line">       Result r &#x3D; ecs.take().get();</span><br><span class="line">       if (r !&#x3D; null)</span><br><span class="line">           use(r);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个任务的超时时间"><a href="#多个任务的超时时间" class="headerlink" title="多个任务的超时时间"></a>多个任务的超时时间</h3><p>等待多个任务完成, 并设置最大等待时间, 可以通过CountDownLatch完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void testLatch(ExecutorService executorService, List&lt;Runnable&gt; tasks) </span><br><span class="line">    throws InterruptedException&#123;</span><br><span class="line">      </span><br><span class="line">    CountDownLatch latch &#x3D; new CountDownLatch(tasks.size());</span><br><span class="line">      for(Runnable r : tasks)&#123;</span><br><span class="line">          executorService.submit(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                  try&#123;</span><br><span class="line">                      r.run();</span><br><span class="line">                  &#125;finally &#123;</span><br><span class="line">                      latch.countDown();&#x2F;&#x2F; countDown</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      latch.await(10, TimeUnit.SECONDS); &#x2F;&#x2F; 指定超时时间</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>线程中的异常如果不处理的外，外部是无法感知的。异常处理可以用以下几种方式：</p>
<h3 id="直接线程中try-catch"><a href="#直接线程中try-catch" class="headerlink" title="直接线程中try/catch"></a>直接线程中try/catch</h3><h3 id="通过Future对象的get方法接收抛出的异常"><a href="#通过Future对象的get方法接收抛出的异常" class="headerlink" title="通过Future对象的get方法接收抛出的异常"></a>通过Future对象的get方法接收抛出的异常</h3><h3 id="为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"><a href="#为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常" class="headerlink" title="为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"></a>为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(1, r -&gt; &#123;</span><br><span class="line">    Thread t &#x3D; new Thread(r);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">            (t1, e) -&gt; &#123;</span><br><span class="line">                System.out.println(t1.getName() + &quot;线程抛出的异常&quot;+e);</span><br><span class="line">            &#125;);</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line">threadPool.execute(()-&gt;&#123;</span><br><span class="line">    Object object &#x3D; null;</span><br><span class="line">    System.out.print(&quot;result## &quot; + object.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"><a href="#重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用" class="headerlink" title="重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"></a>重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这可是jdk文档里面给的例子。。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> &amp;&amp; r <span class="keyword">instanceof</span> Future&lt;?&gt;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = ((Future&lt;?&gt;) r).get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException ce) &#123;</span><br><span class="line">                t = ce;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;</span><br><span class="line">                t = ee.getCause();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// ignore/reset</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h2><p>需要注意的是，如果线程池不关闭的话，会一直占用内存，需手动关闭</p>
<blockquote>
<p>Executors作为局部变量时，创建了线程，一定要记得调用executor.shutdown();来关闭线程池，如果不关闭，会有线程泄漏问题。</p>
</blockquote>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><p>表示不再接受新任务, 但不会强行终止已经提交或者正在执行中的任务, 经常和pool.awaitTermination(1, TimeUnit.SECONDS) 配合使用，这个方法会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long start &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">    pool.execute(new Job());</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br><span class="line">while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(&quot;线程还在执行。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long end &#x3D; System.currentTimeMillis();</span><br><span class="line">LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start));</span><br></pre></td></tr></table></figure>

<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h3><p>对于尚未执行的任务全部取消, 正在执行的任务全部发出interrupt(), 停止执行 </p>
<blockquote>
<p>invokeAll: ExecutorService使用invokeAll()启动集合中的每个Callable, 只有在所有任务完成后，invokeAll() 才会返回一个 Future 列表，每个任务一个 Future。但java8后推荐使用CompletableFuture</p>
</blockquote>
<p>下面我们来看看java默认提供的几个线程池</p>
<h1 id="三、-java内置的线程池"><a href="#三、-java内置的线程池" class="headerlink" title="三、 java内置的线程池"></a>三、 java内置的线程池</h1><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>可缓存线程池：</p>
<ul>
<li>线程数无限制</li>
<li>有空闲线程则复用空闲线程, 若无空闲线程则新建线程</li>
<li>一定程序减少频繁创建/销毁线程, 减少系统开销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建方式</span><br><span class="line">ExecutorService cachedThreadPool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用：执行很多短期异步的小程序或者负载较轻的服务器, 可以使得任务快速得到执行, 因为任务时间执行短, 可以很快结束, 也不会造成cpu过度切换</p>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>定长线程池：</p>
<ul>
<li>可控制线程最大并发数（同时执行的线程数）</li>
<li>超出的线程会在队列中等待</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建方式</span><br><span class="line">ExecutorService fixedThreadPool &#x3D; Executors.newFixedThreadPool(int nThreads);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用：执行长期的任务, 因为采用无界的阻塞队列, 所以实际线程数量永远不会变化, 适用于负载较重的场景, 对当前线程数量进行限制。（保证线程数可控, 不会造成线程过多, 导致系统负载更为严重）如果某个线程因为执行异常而结束，那么线程池会补充一个新线程</p>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>单线程化的线程池：</p>
<ul>
<li>有且仅有一个工作线程执行任务</li>
<li>所有任务按照指定顺序执行, 即遵循队列的入队出队规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建方式</span><br><span class="line">ExecutorService singleThreadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用：一个任务一个任务执行的场景，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</p>
<h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>定长线程池：</p>
<ul>
<li>支持定时及周期性任务执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建方式</span><br><span class="line">ExecutorService scheduledThreadPool &#x3D; Executors.newScheduledThreadPool(int corePoolSize);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;源码</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ScheduledThreadPoolExecutor():</span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用：延时或者周期性执行任务的场景</p>
<blockquote>
<p>同样可以模拟心跳机制，如果用户希望取消心跳， scheduleAtFixedRate 调用将返回一个 ScheduledFuture 实例，它不仅封装了结果（如果有），还拥有一个 cancel 方法来关闭计划的操作</p>
</blockquote>
<h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><p>Java 8新增的具有抢占式操作的线程池，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序，哪个线程抢到任务，就由它执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建方式</span><br><span class="line">ExecutorService executorService &#x3D; Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static ExecutorService newWorkStealingPool() &#123;</span><br><span class="line">        return new ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             null, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Executors有一个静态方法,该方法可以对现有的ExecutorService进行包装,使其只暴露出ExecutorService的方法,因此不能对其进行配置,如果我们需要创建不可更改的线程池,可以使用这个方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Executors.unconfigurableExecutorService(executorService);&#x2F;&#x2F;不可配置的线程池</span><br><span class="line">Executors.unconfigurableScheduledExecutorService(scheduledExecutorService);&#x2F;&#x2F;不可配置的调度线程池</span><br></pre></td></tr></table></figure>

<h1 id="四、配置线程池"><a href="#四、配置线程池" class="headerlink" title="四、配置线程池"></a>四、配置线程池</h1><h2 id="为何不推荐java提供的几种线程池"><a href="#为何不推荐java提供的几种线程池" class="headerlink" title="为何不推荐java提供的几种线程池"></a>为何不推荐java提供的几种线程池</h2><p>客户端程序使用这些快捷方法没什么问题, 对于服务端需要长期运行的程序, 创建线程池应该直接使用ThreadPoolExecutor的构造方法, 避免无界队列(比如线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM)可能导致的OOM以及线程个数限制不当导致的线程数耗尽等问题</p>
<p>所以阿里巴巴java开发手册中明确指出,线程池不允许使用Executors去创建：</p>
<p><img src="executor-1.jpg" alt="image"> </p>
<h2 id="线程池大小设置"><a href="#线程池大小设置" class="headerlink" title="线程池大小设置"></a>线程池大小设置</h2><p>线程池大小的设置，在 「Java 并发编程实战」一书中，Brian Goetz 提供了不少优化建议。如果线程池数量过多，竞争 CPU 和内存资源，导致大量时间在上下文切换上。反之，如果线程池数量过少，<br>无法充分利用 CPU 多核优势。</p>
<p>线程池大小与 CPU 处理器的利用率之比可以用下面公式估算</p>
<p><img src="excutor-size.png" alt="线程池大小设置"></p>
<p>虽然线程池大小的设置受到很多因素影响，但是这里给出一个参考公式：</p>
<blockquote>
<p>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</p>
</blockquote>
<p>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。这个公式进一步转化为：</p>
<p>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
<p>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</p>
<p>所以并不是单纯的只是配一个CUP核心数就ok了。但一般都是整数倍</p>
<h3 id="CPU密集型任务"><a href="#CPU密集型任务" class="headerlink" title="CPU密集型任务"></a>CPU密集型任务</h3><p>尽量使用较小的线程池, 一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高, 若开过多的线程数, 会造成CPU过度切换。</p>
<h3 id="IO密集型任务"><a href="#IO密集型任务" class="headerlink" title="IO密集型任务"></a>IO密集型任务</h3><p>可以使用稍大的线程池, 一般为2*CPU核心数。 IO密集型任务CPU使用率并不高, 因此可以让CPU在等待IO的时候有其他线程去处理别的任务, 充分利用CPU时间。</p>
<h3 id="混合型任务"><a href="#混合型任务" class="headerlink" title="混合型任务"></a>混合型任务</h3><p>可以将任务分成IO密集型和CPU密集型任务, 然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大, 那么就会比串行执行来的高效。<br>因为如果划分之后两个任务执行时间有数据级的差距, 那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务, 最终的时间仍然取决于后执行完的任务, 而且还要加上任务拆分与合并的开销, 得不偿失。</p>
<h1 id="五、SpringBoot中使用线程池"><a href="#五、SpringBoot中使用线程池" class="headerlink" title="五、SpringBoot中使用线程池"></a>五、SpringBoot中使用线程池</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>直接使用JDK中的线程池类</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;taskQueueThreadPool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildTaskQueueThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> poolSize = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(poolSize, poolSize, <span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>), <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;task-queue-thread-%d&quot;</span>).build(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审核队列线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;examineQueueThreadPool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildExamineQueueThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> poolSize = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(poolSize, poolSize, <span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>), <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;examine-queue-thread-%d&quot;</span>).build(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(<span class="number">50</span>);</span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(<span class="number">1000</span>);</span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(<span class="string">&quot;Data-Job&quot;</span>);</span><br><span class="line">        threadPoolTaskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        threadPoolTaskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;asyncPoolTaskExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">getAsyncThreadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">20</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">&quot;oKong-&quot;</span>);</span><br><span class="line">        <span class="comment">// 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者</span></span><br><span class="line">        taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//调度器shutdown被调用时等待当前被调度的任务完成</span></span><br><span class="line">        taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//等待时长</span></span><br><span class="line">        taskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">defaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//核心线程数目</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//指定最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">64</span>);</span><br><span class="line">        <span class="comment">//队列中最大的数目</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//线程名称前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;defaultThreadPool_&quot;</span>);</span><br><span class="line">        <span class="comment">//rejection-policy：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">//CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">        <span class="comment">//对拒绝task的处理策略</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//线程空闲后的最大存活时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//加载</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncServiceExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;start asyncServiceExecutor&quot;</span>);</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//配置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//配置最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//配置队列大小</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">99999</span>);</span><br><span class="line">        <span class="comment">//配置线程池中的线程的名称前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;async-service-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//执行初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>//原始(不推荐)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Resource(name &#x3D; &quot;taskQueueThreadPool&quot;)</span><br><span class="line">private ExecutorService taskQueueThreadPool;</span><br><span class="line"></span><br><span class="line">public void execute() &#123;</span><br><span class="line">    taskQueueThreadPool.execute(new TaskCommitThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//SpringBoot提供的@Async(“asyncServiceExecutor”)注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Async(&quot;asyncServiceExecutor&quot;)</span><br><span class="line">public void executeAsync() &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;&gt;&gt;start executeAsync&quot;);</span><br><span class="line">    try&#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;end executeAsync&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意调用者与被调用者不能在同一个类中</p>
</blockquote>
<blockquote>
<p>@Async 注解的方法只能返回void或者future类型的返回值</p>
</blockquote>
<h2 id="ThreadPoolTaskExecutor-推荐"><a href="#ThreadPoolTaskExecutor-推荐" class="headerlink" title="ThreadPoolTaskExecutor(推荐)"></a>ThreadPoolTaskExecutor(推荐)</h2><p>Spring框架自己实现的线程池类</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//实现AsyncConfigurer接口对异常线程池更加细粒度的控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异步方法调用时要使用的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心池大小</span></span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列大小</span></span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程空闲时间</span></span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程前缀名称</span></span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">&quot;task-async-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置拒绝策略</span></span><br><span class="line">        taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待任务在关机时完成--表明等待所有线程执行完</span></span><br><span class="line">        taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//等待时间 （默认为0，此时立即停止），并没等待xx秒后强制停止</span></span><br><span class="line">        taskExecutor.setAwaitTerminationSeconds(<span class="number">60</span> * <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在使用void返回类型的异步方法执行期间抛出异常时要使用的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被@Async 的方法在独立线程调用，不能被@ControllerAdvice全局异常处理器捕获，所以需要自己设置异常处理</span></span><br><span class="line"><span class="comment">//        return new SimpleAsyncUncaughtExceptionHandler();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAsyncExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Exception message - &quot;</span> + throwable.getMessage());</span><br><span class="line">            log.info(<span class="string">&quot;Method name - &quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">for</span> (Object param : objects) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Parameter value - &quot;</span> + param);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用策略</p>
</blockquote>
<ul>
<li>ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException异常(默认)。</li>
<li>ThreadPoolExecutor.DiscardPolic 丢弃任务，但是不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy 丢弃队列最前面的任务，然后重新尝试执行任务</li>
<li>ThreadPoolExecutor.CallerRunsPolic 由调用线程处理该任务</li>
</ul>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>直接在被调用的方法上加上@Async即可</p>
<h3 id="定义多个线程池"><a href="#定义多个线程池" class="headerlink" title="定义多个线程池"></a>定义多个线程池</h3><p>实际业务中可能会根据场景不同，使用不同的线程池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;AsyncConfig 中新增线程池即可</span><br><span class="line">    @Bean(&quot;simpleThreadPool&quot;)</span><br><span class="line">    public ThreadPoolTaskExecutor simpleThreadPool()&#123;</span><br><span class="line">        ThreadPoolTaskExecutor simpleThreadPool &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        simpleThreadPool.setCorePoolSize(5);</span><br><span class="line">        simpleThreadPool.setMaxPoolSize(200);</span><br><span class="line">        simpleThreadPool.setQueueCapacity(25);</span><br><span class="line">        simpleThreadPool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        simpleThreadPool.setThreadNamePrefix(&quot;simple-async-&quot;);</span><br><span class="line">        simpleThreadPool.initialize();</span><br><span class="line"></span><br><span class="line">        return simpleThreadPool;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在需要使用该线程池的方法中，加上@Async(“simpleThreadPool”)即可</p>
<blockquote>
<p>如果@Async未指定值，则会使用默认的线程池，如果指定了线程池，则使用指定的线程池。</p>
</blockquote>
<blockquote>
<p>如果业务场景中存在并发量在某些特殊时间段下特别高，可以将线程池的各个配置在application.yml中配置，或者通过web端动态配置，不同情况下不同的线程池策略</p>
</blockquote>
<h3 id="观察线程池执行情况"><a href="#观察线程池执行情况" class="headerlink" title="观察线程池执行情况"></a>观察线程池执行情况</h3><p>如果需要观察线程池执行情况，继承ThreadPoolTaskExecutor，编写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisiableThreadPoolTaskExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolTaskExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印队列的详细信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showThreadPoolInfo</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = getThreadPoolExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==threadPoolExecutor)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;, &#123;&#125;,taskCount [&#123;&#125;], completedTaskCount [&#123;&#125;], activeCount [&#123;&#125;], queueSize [&#123;&#125;]&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>.getThreadNamePrefix(),</span><br><span class="line">                prefix,</span><br><span class="line">                threadPoolExecutor.getTaskCount(),</span><br><span class="line">                threadPoolExecutor.getCompletedTaskCount(),</span><br><span class="line">                threadPoolExecutor.getActiveCount(),</span><br><span class="line">                threadPoolExecutor.getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do execute&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">long</span> startTimeout)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do execute&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.execute(task, startTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;?&gt; submitListenable(Runnable task) &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do submitListenable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submitListenable(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">submitListenable</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do submitListenable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submitListenable(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将原有的ThreadPoolTaskExecutor改为自定义后的线程池类</p>
<h1 id="六、线程池在业务中的实践"><a href="#六、线程池在业务中的实践" class="headerlink" title="六、线程池在业务中的实践"></a>六、线程池在业务中的实践</h1><h2 id="1-快速响应用户请求"><a href="#1-快速响应用户请求" class="headerlink" title="1. 快速响应用户请求"></a>1. 快速响应用户请求</h2><p>用户发起的实时请求，服务追求响应时间。这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>
<h2 id="2-快速处理批量任务"><a href="#2-快速处理批量任务" class="headerlink" title="2. 快速处理批量任务"></a>2. 快速处理批量任务</h2><p>离线的大量计算任务，需要快速执行。与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>
<blockquote>
<p>思考</p>
</blockquote>
<p>在Java1.4之前，已经提供了Runnable接口、Thread类、Timer类和synchronize关键字，它们已经足以完成各种各样的多线程编程任务，为什么还要提供执行者这样的概念呢？这是因为Java的设计者想把线程的创建、执行和调度分离。</p>
<p>在concurrent包出现之前，线程的创建基本上靠new一个Thread对象，执行靠start()方法，而线程的调度则完全依赖程序员在具体代码中自己写出来。</p>
<p>而concurrent包出现之后，线程的创建还是依靠Thread、Runnable和Callable对象的实例化；而线程的执行则靠Executor、ExecutorService的对象执行execute()方法或submit()方法；线程的调度则被固化为几个具体的线程池类，如ThreadPoolExecutor、ScheduledThreadPoolExecutor、ExecutorCompletionService等等。这样表面上增加了复杂度，而实际上成功将线程的创建、执行和调度的业务逻辑分离，使程序员能够将精力集中在线程中业务逻辑的编写，大大提高了编码效率，降低了出错的概率，而且大大提高了性能</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>关于浏览器和网络我学到的20件事</title>
    <url>/20210301/%E4%BA%92%E8%81%94%E7%BD%91/3a485887/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章<strong>转载</strong>自Google Chrome Team的文章：<a href="http://www.20thingsilearned.com/zh-CN/all/print">20 Things I Learned About Browsers and the Web</a> 国内可能打不开，非常有意思，在此记录下来，以防丢失。</p>
 <a id="more"></a>

<p>20 Things I Learned About Browsers and the Web 里面的20件事包括了：</p>
<ol>
<li>What is the Internet? ：什么是互联网</li>
<li>Cloud Computing ：云端运算</li>
<li>Web Apps：网站应用程序</li>
<li>HTML, Javascript, CSS and more </li>
<li>HTML5</li>
<li>3D in the Browser：浏览器中的3D</li>
<li>A Browser Madrigal：浏览器大合唱</li>
<li>Plug-ins：插件</li>
<li>Browser Extensions：浏览器扩展程序</li>
<li>Synchronizing the Browser：同步浏览器</li>
<li>Browser Cookies：浏览器cookies</li>
<li>Browsers and privacy：浏览器与隐私</li>
<li>Malware, phishing and security risks：恶意软件、网上诱骗和安全风险</li>
<li>新一代的浏览器如何帮您抵御恶意软件和网上诱骗</li>
<li>Using web addresses to stay safe: 使用网址，确保安全</li>
<li>IP address and DNS：IP地址和DNS</li>
<li>Validating identities online：在线身份验证</li>
<li>Evolving to a faster web：向更快的网络时代迈进</li>
<li>Open source and browsers：开放源代码和浏览器</li>
<li>19 thins later: 最后一个须知…</li>
</ol>
<p>如今许多人都离不开网络，我们只要动动手指就能获得全球信息，并且在瞬间接触到世界各地的人和活<br>动。</p>
<p>所有这些超强体验都归功于开放的互联网。世界上的任何人都能通过任何已联网的设备，通过浏览器上网。</p>
<hr>
<p>但是浏览器和网络的工作原理究竟是怎样的呢？万维网是如何发展到如今我们所了解和喜爱的样子的？我们<br>需要了解哪些事情才能安全有效地浏览网络？</p>
<p>“我了解到的关于浏览器和网络的 20 件事”是一个简短的指南，面向的是所有想要了解浏览器和网络基<br>本知识的人。本指南介绍了以下内容：</p>
<p>首先我们会介绍一下互联网，这是网络存在的基础。我们还会介绍当今网络是如何通过云计算和网络应<br>用程序运作的。</p>
<p>接着，我们会介绍 HTML 和 JavaScript 等网页构建基础，并且回顾它们的发明和发展对于您日常访问<br>的网站起到了怎样的影响。我们还会介绍现代浏览器，以及它如何帮助用户更安全地访问网络。</p>
<p>最后，我们会展望在浏览器和网络技术领域令人兴奋的创新，我们相信在未来可以获得更快速更让人身<br>临其境的在线体验。</p>
<p>虽然网络生活让我们觉得自由自在而且无所不能，但是我们还是应该了解更多些相关知识。正如我们想<br>要了解现实生活中居住小区的基本情况（例如水电安全、注意事项、周边服务等），我们也越来越有必要了<br>解关于在线生活的一系列类似信息。这就是我们编写本指南的用意。在谈到浏览器功能时举的很多例子中，<br>我们经常会提到“Chrome 浏览器”这款大家熟知的开放源代码浏览器。我们希望您在阅读本指南时享受到和我<br>们编写时一样的乐趣。</p>
<p>祝您浏览愉快！</p>
<p>“Google Chrome 浏览器”小组谨此向插图绘制者克里斯托弗•尼曼 (Christoph Niemann) 致上由衷谢意<br>2010 年 11 月</p>
<h1 id="What-is-the-Internet-什么是互联网"><a href="#What-is-the-Internet-什么是互联网" class="headerlink" title="What is the Internet? 什么是互联网"></a>What is the Internet? 什么是互联网</h1><blockquote>
<p>要知道什么是互联网，就要知道什么是 TCP/IP</p>
</blockquote>
<p><img src="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%92%E8%81%94%E7%BD%91.png" alt=" "></p>
<p>互联网究竟是什么？对某些人来说，互联网就是用来与朋友交流、读新闻、购物和玩游戏的。而对其他<br>一些人来说，互联网则可能是他们当地的宽带提供商，<br>或者是城市之间乃至越洋过海传输数据的地下电缆和光纤。谁的看法正确呢？</p>
<p>要讨论这一点，我们不妨从互联网诞生的 1974 年开始说起。那一年，几位天才的计算机研究人员发明<br>了一种称为“互联网协议组”的技术，简称“TCP/IP”。</p>
<hr>
<p>TCP/IP 制定了一套规则，可以让不同的计算机彼此“交谈”，并且发送和接收信息。</p>
<p>TCP/IP 有点类似于人类之间的交流：人们在交谈时会按照语法规则组织语言，从而确保彼此可以相互理<br>解和交流看法。同样地，TCP/IP 也提供了一套交流规则，从而确保互连设备可以彼此了解，以便发送和接收<br>信息。随着这种互连设备从一个房间扩展到许多房间，再扩展到许多建筑物、城市乃至国家，互联网便诞生<br>了。</p>
<p>互联网的早期创建者发现，如果先将数据和信息分成小块独立发送，然后再重新组合，那么传送效率会<br>更高。这些小块称为数据包。所以，当您通过互联网发送电子邮件时，完整的电子邮件内容会先分成许多数<br>据包发送到收件人邮箱，然后再重新组合。当您在 YouTube 等网站观看视频时，情况同样如此：视频文件会<br>分成许多数据包，从世界各地的多个 YouTube 服务器发送出去，然后重新组合，还原成您在浏览器中看到的<br>视频。</p>
<hr>
<p>网速如何？如果将互联网的流量比作水流，那么互联网的带宽就相当于每秒流过的水量。所以工程师们<br>所说的带宽实际上是指通过您的互联网连接每秒所能发送的数据量。这是反映您连接速度的一项指标。如<br>今，凭借更精良的实体基础设施（例如光纤电缆，其传输速度接近光速），网络连接的速度可以更快，而且<br>可以更好地在物理介质上进行信息编码，即使是铜线这样的老式介质也完全没问题。</p>
<p>互联网是一个令人着迷的高度技术化体系，但是对于我们大多数人来说，其实很容易使用，完全不必考<br>虑其中所涉及的电缆和方程式之类复杂的东西。</p>
<p>另外，互联网也是我们所熟知和喜爱的万维网存在的支柱：正是互联网连接实现了互连的网页和应用程序，<br>带我们走进了一个不断发展的开放世界。事实上，如今网络中的网页数量可能已经像人脑中的神经元或者银<br>河系中的星星那么多了。</p>
<p>在接下来的两章中，我们会介绍如今的网络是如何通过云计算和网络应用程序在现实生活中应用的。</p>
<h1 id="Cloud-Computing-云端运算"><a href="#Cloud-Computing-云端运算" class="headerlink" title="Cloud Computing 云端运算"></a>Cloud Computing 云端运算</h1><blockquote>
<p>为什么卡车碾过我的笔记本也没关系</p>
</blockquote>
<p>互联网时代的现代计算机技术是相当神奇和卓越的。当您抱着您的笔记本电脑宅在家里看 YouTube 视频<br>或使用搜索引擎时，实际上利用了遍布全球的无数台计算机的集体力量，正是它们远程提供了您所需的信<br>息。这简直就像有一台大型超级计算机随时听候您的差遣，而这一切都归功于互联网。</p>
<p>这种现象就是我们通常所说的“云计算”。如今我们都可以在网络上读新闻、听音乐、购物、看电视以及<br>存储文件。</p>
<p><img src="%E4%BA%91%E7%AB%AF%E8%BF%90%E7%AE%97-1.png" alt=" "></p>
<p>在我们所生活的城市中，几乎每个博物馆、银行和政府部门都有自己的网站。结果如何呢？我们可以通过这<br>些网站进行付帐和预约等活动，因此节省了排队和打电话的时间。许多日常事务可以转由网络进行处理，这<br>样我们可以生活得更加丰富多彩。</p>
<hr>
<p>云计算还有其他一些好处。几年前，如果计算机出现了病毒感染或硬件故障之类的问题，很多人都会担<br>心文档、照片和文件丢失。如今，我们已不再将数据存储局限在个人计算机中，而是迁移到网络上，将数据<br>在线储存到“云”中。如果您在线上传照片、存储重要文件并使用 Gmail 或 Yahoo! Mail 这样网络电子邮件，<br>那么即使一辆 18 轮大卡车碾过您的笔记本电脑，您的所有数据仍会安全地保存在网络上。不论您在世界的<br>哪个角落，都可以通过任何一台接入互联网的计算机访问这些数据。</p>
<p><img src="%E4%BA%91%E7%AB%AF%E8%BF%90%E7%AE%97-2.png" alt=" "></p>
<h1 id="Web-Apps-网站应用程序"><a href="#Web-Apps-网站应用程序" class="headerlink" title="Web Apps 网站应用程序"></a>Web Apps 网站应用程序</h1><blockquote>
<p>或者说 “生命、自由以及对应用程序的追求”</p>
</blockquote>
<p><img src="%E7%BD%91%E7%AB%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.png" alt=" "></p>
<p>如果您玩网络游戏，使用网上照片编辑器或者依赖“Google 地图”、Twitter、Amazon、YouTube 或<br>Facebook 等基于网络的服务，那么您就已经是网络应用程序世界中的一个活跃分子了。</p>
<p>网络应用程序究竟是什么？跟我们有什么关系呢？</p>
<hr>
<p>“App”是应用程序 (application) 的缩写。应用程序也称为程序或软件。以往，开发应用程序是为了完成综<br>合密集型的任务，例如财务管理或文字处理。现在，在网络浏览器和智能手机的网络世界中，应用程序通常<br>是较为灵活的程序，专门针对单一任务。尤其是网络应用程序，可以在网络浏览器中运行这些任务，并且往<br>往能够提供丰富的互动体验。</p>
<p>“Google 地图”就是一个网络应用程序的绝佳示例。它专门用来处理一项任务：在网络浏览器中提供实用<br>的地图功能。您可以平移和缩放地图，搜索大学或咖啡厅，并且获得行车路线等等。您需要的所有信息都会<br>根据您的要求动态显示在网络应用程序中。</p>
<p>我们可以总结出网络应用程序的四大优点：</p>
<ol>
<li><p>我可以从任何地方访问自己的数据。</p>
<p>在过去的桌面应用程序时代，数据通常存储在计算机的硬盘中。如果我外出度假，但是将计算机留在了家<br>里，那么就无法查收电子邮件、查看照片或访问任何需要的数据了。而在网络应用程序的新时代，我的电子<br>邮件和所有数据都存储在网络上。您可以使用任何一台可以上网的计算机，通过网络浏览器获取所需的数<br>据。</p>
</li>
<li><p>我的应用程序总是最新版本。</p>
<p>我今天使用的 YouTube 是什么版本？明天呢？答案是：永远都是最新的。网络应用程序会自动更新，所以总<br>是只有一个版本：包含了所有最新功能和改进的最新版本。没有必要每次都手动升级到新版本，也不必在花<br>费大量安装时间后才能使用。</p>
</li>
<li><p>可以在所有安装了网络浏览器的设备上使用。</p>
<p>对于传统的计算机技术，有些程序只能在特定的系统或设备上运行。例如，许多为 PC 编写的程序无法在苹<br>果机上运行。为每种系统或设备开发相应的软件不仅耗时，而且成本很高。相反，网络则是一个开放的平<br>台。任何人都可以在连接到网络的设备上通过浏览器访问网络，无论这样的设备是笔记本电脑、桌面计算机<br>还是手机。这意味着我即便使用朋友的笔记本电脑或网吧的计算机，也能运行我喜爱的网络应用程序。</p>
</li>
<li><p>更加安全。</p>
<p>网络应用程序是在浏览器中运行的，无需下载到自己的计算机上。由于应用程序代码与计算机代码是分开<br>的，因此网络应用程序不会影响我计算机上的其他任务，也不会影响计算机的总体性能。这也表示我在面对<br>病毒、恶意软件和间谍软件等威胁时，可以得到更好的保护。</p>
</li>
</ol>
<h1 id="HTML-Javascript-CSS-and-more"><a href="#HTML-Javascript-CSS-and-more" class="headerlink" title="HTML, Javascript, CSS and more"></a>HTML, Javascript, CSS and more</h1><blockquote>
<p>AJAX 不再是从前的样子了</p>
</blockquote>
<p>网页都是用 HTML 语言编写的，这是一种网络编程语言，可以指示浏览器如何在网页上构建和展现内<br>容。换句话说，HTML 为网页提供了构建基础。很长一段时间以来，这些构建基础都很简单，而且是静态<br>的，只包含文本行、链接和图片。</p>
<p>如今，我们的要求更高了，例如会想要在线下棋或者无缝滚动浏览周边地图，但不想每下一步棋或每滚<br>动一下地图都要等待整个网页重新载入。</p>
<p><img src="html.png" alt=" "></p>
<p>这种动态网页的构想，从 JavaScript 脚本语言发明伊始就已经萌生了。各种主流网络浏览器都支持<br>JavaScript，这就意味着网页中可以包含更多重要的实时互动内容。例如，如果您填写了一张在线表单，然后<br>点击“提交”按钮，那么网页就会使用 JavaScript 实时检查您输入的内容，并且在发现您填错时立即提醒您。</p>
<p><img src="html-1.png" alt=" "></p>
<p><img src="html-2.png" alt=" "></p>
<p>但是实际上，我们现在所了解的动态网页是在 JavaScript 引入了 XHR(XMLHttpRequest) 后才实现的，<br>然后首先应用到 Microsoft Outlook 网络版、Gmail 和“Google 地图”等网络应用程序中。XHR 无需重新载入<br>整个网页，即可更改网页的各个部分，包括游戏、地图、视频、在线用户调研等。这样，网络应用程序也因<br>此变得更快速，响应也更及时。</p>
<p><img src="html-3.png" alt=" "></p>
<p>在引入 CSS（层叠样式表）后，网页拥有了更丰富的表现力。CSS 可让程序员以轻松而有效的方法来定<br>义网页布局，并通过颜色、圆角、渐变和动画等设计元素美化网页。</p>
<p>网络程序员通常将 JavaScript、XHR、CSS 以及其他几种网络技术的强力组合称为 AJAX（异步<br>JavaScript 和 XML）。HTML 也在持续发展，新版 HTML 标准中不断加入新的功能和改进。</p>
<p>无数的技术人员、点子专家、编程人员和组织创造了种种网络技术，并确保 Internet Explorer、Firefox、<br>Safari 和 “Google Chrome 浏览器”等网络浏览器支持这些技术，正是这些人的不懈努力，网络世界才有了今<br>日的繁荣。网络技术与浏览器之间相辅相成，把网络打造成一个开放友好的构建平台，供网络开发人员开发<br>各种实用而有趣的网络应用程序，以便我们在日常生活中使用。</p>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><blockquote>
<p>或在开始，还没有&lt; VIDEO &gt;的时候</p>
</blockquote>
<p>在 HTML 诞生 20 多年后，我们仍在探究这样的问题：什么是网络？未来的网络会变成什么样？对于我<br>们这些用户来说，什么样的功能和应用程序才是有趣、实用甚至是不可或缺的呢？开发人员需要借助什么工<br>具来开发优秀的网站和应用程序？最后，如何在网络浏览器中实现网络的种种优势？</p>
<p>对上述问题的探究催生了最新版本的 HTML，也就是 HTML5。它具备了一系列新功能，可以帮助网页<br>设计人员和开发人员们开发强大的下一代网络应用程序。以 HTML5 中的 <video> 标记为例。在早期的网络<br>中，视频并不是一个主要的部分，或者说根本没有；</p>
<p><img src="html5.png" alt=" "></p>
<p>互联网用户只有安装了称为“插件”的额外软件，才能在浏览器中观看视频。而不久之后，轻松观看视频就成<br>了广大用户迫切需要的一项功能。利用 HTML5 中引入的 <video> 标记，可以轻松地在网页中嵌入和播放视<br>频，无需安装其他软件。</p>
<p>HTML5 还提供了其他一些很棒的功能，例如离线功能（用户即使在没有网络连接的情况下，也能与网<br>络应用程序互动）以及拖放功能。例如在 Gmail 中，用户只要将桌面上的文件拖放到浏览器窗口中，即可瞬<br>间完成附件添加操作。</p>
<p>HTML5 就和网络本身一样， 也在根据用户的需求和开发人员的构想而不断发展。作为一种开放式标<br>准，HTML5 结合了网络显著的一些优势：不受地域限制，都能在装有新一代浏览器的设备上运行。</p>
<p>但是，就像只有在高清电视机上才能观看高清电视节目一样，用户必须使用兼容 HTML5 的最新版浏览器，<br>才能访问那些采用了 HTML5 功能的网站和应用程序。好在有很多不同的浏览器可供互联网用户选择，买电<br>视机要花钱，浏览器可是能免费进行下载的哦。</p>
<h1 id="3D-in-the-Browser：浏览器中的3D"><a href="#3D-in-the-Browser：浏览器中的3D" class="headerlink" title="3D in the Browser：浏览器中的3D"></a>3D in the Browser：浏览器中的3D</h1><blockquote>
<p>更有深度的浏览</p>
</blockquote>
<p><img src="%E6%94%AF%E6%8C%813D%E5%8A%9F%E8%83%BD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8.png" alt=" "></p>
<p>3D 图形与动画的确魅力无穷，因为它们能够很好地展现所有细节，例如光影、倒影与逼真的纹理等。<br>然而，迄今为止仍难以实现令人瞩目的 3D 体验，尤其是在互联网上。</p>
<p>为什么会这样呢？主要原因是，要在游戏和其他应用程序中营造 3D 体验，就必须用海量的数据来显示<br>复杂精细的纹理和形状。以前，大多数常用系统都因为互联网带宽和计算能力方面的限制，无法处理如此海<br>量的数据。</p>
<p>不久之前，一切都改变了：基于浏览器的 3D 时代来临了！</p>
<p>如今的宽带网络帮助解决了带宽需求问题。许多家庭和办公室现在都安装了宽带，带宽远超十年前。因<br>此，可以通过互联网发送大量数据，从而达到在浏览器中体验逼真 3D 效果的要求。而且，如今的计算机在<br>性能上也远非从前可比：处理器与内存得到了显著提升，即便是目前普通档次的笔记本电脑或台式计算机，<br>也能处理复杂的 3D 图形。</p>
<p>但是关键还在于浏览器功能有了长足的发展，否则单纯依靠宽带或者计算能力都是无济于事的。许多现<br>代浏览器都采用了开放网络技术，如 WebGL 和 3D CSS。凭借这些技术，网络开发人员可以为网络应用程<br>序打造出酷炫的 3D 效果，而我们无需安装其他插件就能体验这种效果。最重要的是，许多现代浏览器现在<br>都能采用了一种称为“硬件加速”的技术。这意味着浏览器可以使用图形处理单元（即 GPU）加快计算速度，<br>以满足同时呈现 3D 和日常 2D 网页内容的需要。</p>
<hr>
<p>那么为什么浏览器对 3D 的支持这么重要呢？因为现在 3D 技术已经与 HTML5、JavaScript 和其他强大<br>的新技术一起成为了网络开发的常用工具，网络开发人员可以使用这些技术开发强大的下一代网络应用程<br>序。而对用户而言，这意味着可以通过更好的新方式直观地查看实用信息，在网上体验 3D 环境和玩 3D 游<br>戏时能够获得更多乐趣。</p>
<p>最重要的是，浏览器对 3D 的支持为网络应用程序带来了种种好处：您能够与全球的朋友们分享、协作<br>和个性化最新的应用程序。毋庸置疑，人人都能获得更多数据，体验更多乐趣。</p>
<h1 id="A-Browser-Madrigal：浏览器大合唱"><a href="#A-Browser-Madrigal：浏览器大合唱" class="headerlink" title="A Browser Madrigal：浏览器大合唱"></a>A Browser Madrigal：浏览器大合唱</h1><blockquote>
<p>新老浏览器的对决</p>
</blockquote>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E5%90%88%E5%94%B1.png" alt=" "></p>
<blockquote>
<p>老古董般的浏览器与现代浏览器<br>无法并存：<br>现代浏览器速度快、功能全、安全好<br>老版浏览器运行慢，弱点一大堆<br>一有恶意攻击就疲软。</p>
</blockquote>
<p>大多数互联网用户可能尚未意识到，过时的旧版网络浏览器会对我们的网络生活，尤其是网络安全造成<br>多大的负面影响。您肯定不愿意长年累月都开着一辆轮胎磨秃、刹车失灵而且发动机常常罢工的老爷车。同<br>样，您也不应该每天使用过时的旧版浏览器来访问网页和网络应用程序。</p>
<p>赶快升级到最新版本的现代浏览器吧，例如 Mozilla Firefox、Apple Safari、Microsoft Internet<br>Explorer、Opera 或者“Google Chrome 浏览器”。这样做是很有必要的，理由有以下三点：</p>
<ul>
<li><p>第一，旧版浏览器通常无法更新最新的安全补丁和功能，因而极易受到攻击。浏览器的安全漏洞可能导<br>致用户密码被盗、恶意软件偷偷侵入计算机甚至其他更严重的后果。而最新版本的浏览器能帮助您抵御网上<br>诱骗和恶意软件等安全威胁。</p>
</li>
<li><p>第二，网络的发展十分迅速。旧版浏览器可能无法支持当今网站和网络应用程序中的许多最新功能。只<br>有最新版本的浏览器在速度方面进行了改进，再加上对 HTML5、CSS3 以及快速 JavaScript 等现代网络技术<br>的支持，可以让您快速地访问网页和运行应用程序。</p>
</li>
</ul>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E5%90%88%E5%94%B1-1.png" alt=" "></p>
<ul>
<li>第三，旧版浏览器阻碍了网络创新的步伐。如果大量的互联网用户都墨守旧版浏览器，网络开发人员就<br>不得不在设计网站时兼顾新旧技术。面对有限的时间和资源，他们不得不为了照顾旧版浏览器的低标准，而<br>停止为现代浏览器开发创新性的下一代网络应用程序。（想象一下吧，这就好比如今的高速公路工程师们被<br>迫按照老爷车的安全行驶标准去设计高速公路。）因此，无论对于广大网络用户还是网络创新而言，过时的<br>浏览器都是有百害而无一利的。</li>
</ul>
<hr>
<p>如果您对自己老迈的浏览器依依不舍，这也是无可厚非的。有些情况下，您可能无法升级浏览器。如果<br>您发现在办公用计算机上无法升级浏览器，请与贵公司的 IT 管理员联系。如果您无法升级旧版 Internet<br>Explorer，可以使用“Google Chrome 浏览器内嵌框架”插件，在 Internet Explorer 中引入“Google Chrome 浏<br>览器”的部分功能，从而获得一些现代网络应用程序的先进功能。</p>
<p>过时的旧版浏览器不仅会损害用户的利益，而且阻碍了整个网络的创新步伐。因此，请您务必花一点时<br>间将您喜爱的现代浏览器升级到最新版本。</p>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E5%90%88%E5%94%B1-2.png" alt=" "></p>
<h1 id="Plug-ins：插件"><a href="#Plug-ins：插件" class="headerlink" title="Plug-ins：插件"></a>Plug-ins：插件</h1><blockquote>
<p>吃饺子要蘸醋</p>
</blockquote>
<p><img src="%E6%8F%92%E4%BB%B6.png" alt=" "></p>
<p>在万维网发展的早期阶段，第一版 HTML 无法传输像视频这样高级的内容，基本上只限于文本、图片<br>和链接。</p>
<p>为了打破早期 HTML 的限制并且传输更多互动内容，插件应运而生。<br>插件是一种附加软件，专门用来处理特定类型的内容。例如，用户可以下载并安装 Adobe Flash Player 等插<br>件，以便观看包含视频或互动游戏的网页。</p>
<hr>
<p>插件与浏览器之间的互动程度如何？说来奇怪，它们之间几乎没有互动。插件模式很像电视上的画中<br>画：浏览器在网页上为插件界定一个明确的空间，然后就置身事外了。插件可以自由运用这个空间，完全不<br>受浏览器的影响。</p>
<p>这种独立性意味着一个特定的插件可以适用于多种不同的浏览器。然而，这种普遍性也让插件成为了浏<br>览器安全攻击的主要目标。如果您运行的不是最新版插件，那么您的计算机会更容易遭到安全攻击，因为过<br>时的插件不包含最新的安全修补程序。</p>
<p>我们今天使用的插件模式主要还是沿袭自早期的网络。不过，网络社区目前正在寻找插件现代化的新用<br>途，例如通过巧妙的方法更加无缝地集成插件，以便对插件内容进行搜索和链接，并且可以让插件与网页的<br>其余部分互动。</p>
<p>更重要的是，现在一些浏览器供应商和插件提供商会展开合作，共同保护用户免受安全风险。例如，“Google<br>Chrome 浏览器”小组和 Adobe Flash Player 团队已经展开合作，将 Flash Player 集成到了浏览器<br>中。“Chrome 浏览器”的自动更新机制有助于确保 Flash Player 插件永不过时，并且一直收到最新的安全修补<br>程序和补丁。</p>
<h1 id="Browser-Extensions：浏览器扩展程序"><a href="#Browser-Extensions：浏览器扩展程序" class="headerlink" title="Browser Extensions：浏览器扩展程序"></a>Browser Extensions：浏览器扩展程序</h1><blockquote>
<p>浏览器变身“百变金刚”</p>
</blockquote>
<p>浏览器扩展程序可让您对浏览器添加新的功能，名副其实地“扩展”浏览器。</p>
<p>这意味着您可以对浏览器进行自定义，添加最重要的功能。您可以将扩展程序视为在浏览器现有功能的<br>基础上增加新的强大功能。</p>
<p>这些功能可大可小，完全取决于您的需要。例如，您可以安装一个汇率换算扩展程序，安装完成后，浏<br>览器地址栏旁就会显示一个新的按钮。</p>
<p>点击该按钮即可将当前网页上的所有价格换算成您指定的币种。如果您是一个习惯在网上规划行程和预订的<br>背包客，那么这款扩展程序就很有帮助。您可以在所有网页上使用这类扩展程序的类似功能。</p>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F.png" alt=" "></p>
<p>浏览器扩展程序也可以在网页外部自行运行。电子邮件通知扩展程序可以集成到浏览器工具栏中，在后<br>台检查您的电子邮件帐户中是否收到了新邮件，然后通知您。在这种情况下，无论您在浏览什么网页，该扩<br>展程序总是会在后台运行。这样，您就无需在一个独立窗口中登录电子邮件来查收新邮件。</p>
<p>浏览器扩展程序刚诞生时，开发人员通常必须使用一些不常见的编程语言或者大型的主流编程语言（如<br>C++）编写这些程序。这对于工作量、时间和专业的知识的要求都很高。向浏览器添加更多的代码还会增加<br>安全隐患，因为这为攻击者提供了更多可乘之机。以前有些扩展程序的代码晦涩难懂，使得扩展程序背负了<br>导致浏览器崩溃的恶名。</p>
<p>如今，大多数浏览器都允许开发人员使用友好的基础网络编程语言开发扩展程序，例如 HTML、<br>JavaScript 和 CSS。这些语言同时也是开发当今大多数网络应用程序和网页所用的语言，因此如今的扩展程<br>序与网络应用程序和网页之间的兼容性更好。扩展程序开发起来更加迅速、简单和安全，而且会随着作为开<br>发基础的网络标准一起不断完善。</p>
<hr>
<p>要找新的扩展程序，可以查看浏览器的扩展程序库。您会在其中找到成千上万的扩展程序，它们能带给<br>您更高效或更有趣的浏览体验，有些可让您在搜索时在网页上标注突出显示内容以及做笔记；有些可通过浏<br>览器界面为您带来精彩的体育赛事实况报道。</p>
<h1 id="Synchronizing-the-Browser：同步浏览器"><a href="#Synchronizing-the-Browser：同步浏览器" class="headerlink" title="Synchronizing the Browser：同步浏览器"></a>Synchronizing the Browser：同步浏览器</h1><blockquote>
<p>又有卡车碾过我的笔记本了</p>
</blockquote>
<p><img src="%E5%90%8C%E6%AD%A5%E6%B5%8F%E8%A7%88%E5%99%A8.png" alt=" "></p>
<p>恭喜您，您现在已经步入“云”中了！您在收发电子邮件、听音乐以及做每一件事时，几乎都用到了网络<br>应用程序。无论身在何处，您只要通过任意一台可以上网的计算机，就可以在线保存重要文档、照片和各种<br>文件了。</p>
<p>就算是一辆 18 轮的大卡车呼啸着碾碎您的笔记本电脑，您也不会丢失任何数据。明智的您早已将自己<br>的重要信息保存到网上，这时候您只要找到另一台可以上网的设备，就可以拿到重要信息并继续工作了。</p>
<hr>
<p>但是，像书签、浏览器扩展程序和浏览器偏好设置这些日常使用的内容会怎么样呢？它们会随着您的笔<br>记本电脑一起灰飞烟灭吗？</p>
<p>以前是会的。那时候您必须重新寻找您喜爱的各种扩展程序，重新收集曾经辛辛苦苦添加到书签的各个<br>网站。但现在再也不用这么麻烦了！如今，像 Firebox 和“Chrome 浏览器”等许多浏览器都已着手开发一项称<br>为同步的功能。同步功能可让您将浏览器设置在线保存到“云”中，这样就算您的计算机融化了，这些设置也<br>不会丢失。</p>
<p>另外，如果您要用到多台计算机（比如工作时使用笔记本电脑，在家使用台式计算机），有了同步功能<br>就会非常方便。您不必手动地为每一台计算机重新创建收藏网站的书签，也不必重新配置浏览器。<br>只要浏览器具备同步功能，您在一台计算机上所作的更改就会在几秒内自动在其他同步的计算机上反映出<br>来。</p>
<p>以“Chrome 浏览器”为例，同步功能可以将所有的书签、扩展程序、偏好设置以及主题保存到您的<br>Google 帐户。您在使用其他任何可以上网的计算机时，只需打开“Chrome 浏览器”，然后通过浏览器的同步<br>功能登录您的 Google 帐户。瞧！您喜爱的所有浏览器设置这时就可以在新的计算机上使用了。</p>
<p>无论您要使用多少台计算机，只要可以上网并且安装了可同步到“云”的现代浏览器，就万事俱备了。哪<br>怕这些计算机都被传说中的卡车压坏也没关系。</p>
<h1 id="Browser-Cookies：浏览器cookies"><a href="#Browser-Cookies：浏览器cookies" class="headerlink" title="Browser Cookies：浏览器cookies"></a>Browser Cookies：浏览器cookies</h1><blockquote>
<p>多亏了记录功能</p>
</blockquote>
<p>“Cookie”看起来不像是一个技术名词，但却为互联网用户提供了一项至关重要的功能：记录访问过的网<br>站或正在访问的网站。</p>
<p>Cookie 是由您访问的网站向您的浏览器发送的一小段文本。其中包含了您希望该网站记住的关于访问活<br>动的信息，例如首选语言或其他一些设置。浏览器会保存这些数据，并在您下次访问该网站时调用它们，为<br>您提供更方便和个性化的访问体验。</p>
<p>例如，您在访问一个电影网站时表示某喜剧片最受您的喜爱，那么该网站所发送的 Cookie 就会记录这一<br>点，这样当您下次访问时，就会看到很多的喜剧片。</p>
<p><img src="cookies.png" alt=" "></p>
<p>在线购物车也使用 Cookie。例如，您在收费电影网站浏览 DVD 时，会发现在不登录的情况下也可以将<br>DVD 添加到购物车中。即使您在该网站的各个不同页面上浏览，您的购物车也不会“忘记”您挑选的 DVD，<br>因为您的选择已经通过浏览器的 Cookie 保存下来了。另外，在线广告也会使用 Cookie 记录您的兴趣爱好，<br>并在您访问网页时显示相关的广告。</p>
<p>但是有些人不喜欢使用 Cookie，因此大多数现代浏览器都提供了管理 Cookie 的功能，以满足不同用户<br>的需要。您可以针对不同网站设置用于管理 Cookie 的特定规则，从而更好地保护自己的隐私。这就意味着<br>您可以选择自己信任的网站，只允许这些网站的 Cookie，而阻止其他网站的 Cookie。Cookie 的类型有很<br>多，包括只在某个特定浏览会话期间存在的“仅限会话的 Cookie”，以及可持续多个浏览器会话的“永久<br>Cookie”。</p>
<p>因此，现代浏览器通常都提供了微调控制方法，可让您根据自己的偏好设置不同类型的 Cookie，例如将永久<br>Cookie 设置为单一会话 Cookie。</p>
<p>在“Google Chrome 浏览器”中，“选项”菜单中提供了一个特殊的直接链接，点击后即可转到 Adobe Flash<br>Player 的存储设置管理器。您可以通过该链接方便地控制由 Adobe Flash Player 存储的本地数据（通常也称<br>为“Flash Cookie”），这些数据包含了您访问过的基于 Flash 的网站或应用程序的信息。就像您可以管理浏览<br>器 Cookie 一样，您也能轻松地控制 Flash Cookie 的设置。</p>
<h1 id="Browsers-and-privacy：浏览器与隐私"><a href="#Browsers-and-privacy：浏览器与隐私" class="headerlink" title="Browsers and privacy：浏览器与隐私"></a>Browsers and privacy：浏览器与隐私</h1><blockquote>
<p>在浏览器中保护自己的隐私</p>
</blockquote>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E9%9A%90%E7%A7%81.png" alt=" "></p>
<p>安全与隐私是紧密相关的，但并不完全等同。</p>
<p>您可以想象一下自己家里的安全和隐私保障措施：门锁和报警系统帮助您防盗，而窗帘和百叶窗可以防<br>止路人窥视您的生活隐私。</p>
<p>同样，浏览器的安全保障可帮助您抵御恶意软件、网上诱骗和其他在线攻击，而隐私保护功能则可在您<br>的计算机上帮助保护您在浏览方面的隐私。</p>
<hr>
<p>让我们更深入地了解一下隐私。打个比方：您是跑步爱好者，每天都要跑上几里路。如果您随身携带一<br>个 GPS 设备来记录每天的跑步数据，就可以在这个设备上创建一份跑步数据日志：您跑到什么地方、跑了<br>多远、平均速度是多少以及消耗了多少卡路里。</p>
<p>而当您浏览网页时，计算机也会在本地生成并存储一份类似的浏览器数据日志，其中包括关于您所浏览<br>网站的记录、发送到浏览器的 Cookie 以及您下载的所有文件。如果您将浏览器设置为保存密码或表单数<br>据，那么这些数据也会存储在您的计算机上。</p>
<p>有些人可能没有意识到，所有这些浏览数据都是可以随时从计算机中清除的。只要通过浏览器的“选<br>项”或“偏好设置”菜单，就能轻松完成这样的操作。（不同浏览器的菜单名称会有所区别。）事实上，大部分<br>最新版的现代浏览器还提供了一种“隐私”或“隐身”模式。例如，在“Chrome 浏览器”的隐身模式下，您浏览的<br>所有网页均不会显示在浏览历史记录中。另外，在您关闭所有已打开的隐身窗口后，系统会删除所有新的<br>Cookie。如果您与其他人共用自己的计算机，或者在当地图书馆或网吧使用公共计算机，那么这种模式就非<br>常方便。</p>
<hr>
<p>通过浏览器中的所有这些隐私控制功能，您可以控制计算机本地上的浏览数据或由浏览器发送给网站的<br>特定数据。但浏览器的隐私设置无法控制另外的这些网站获取您的数据，例如您以前在这些网站上提交的个<br>人信息。</p>
<p>当然，也有一些方法可以限制网站在您浏览的同时获取某些信息。很多浏览器可以让您针对不同的网站<br>调整隐私偏好设置，并且自行选择 Cookie、JavaScript 和插件等特定数据。例如，您可以设置相应的规则，<br>只允许自己信任的一系列网站的 Cookie，并让浏览器阻止其他所有网站的 Cookie。</p>
<p>在隐私与效率之间总会存在一点冲突。收集来自广大用户的实际汇总数据和反馈确实有助于改善产品和<br>用户体验。关键是在坚持严格的隐私标准的同时，在隐私与效率之间找到最佳平衡点。<br>下面以浏览器 Cookie 作为实际的例子来说明这一点。一方面，如果使用 Cookie，您经常访问的网站就<br>能够记录您购物车中的商品，让您保持登录状态，并且根据您以前的浏览记录提供更实用、更个性化的浏览<br>体验。</p>
<p>而另一方面，允许浏览器 Cookie 就意味着网站会收集和记录您先前浏览过的信息。如果您愿意，可以<br>随时选择阻止 Cookie。这样，您下次希望对浏览器隐私设置进行微调时，可以在浏览器的“选项”或“偏好设<br>置”菜单中修改相应的隐私设置。</p>
<h1 id="Malware-phishing-and-security-risks：恶意软件、网上诱骗和安全风险"><a href="#Malware-phishing-and-security-risks：恶意软件、网上诱骗和安全风险" class="headerlink" title="Malware, phishing and security risks：恶意软件、网上诱骗和安全风险"></a>Malware, phishing and security risks：恶意软件、网上诱骗和安全风险</h1><blockquote>
<p>披着羊皮的狼</p>
</blockquote>
<p>当您在闹市使用自动取款机时，可能会四下张望，以确保没有人偷窥您的密码或窃取现金。其实，您或<br>许应该先检查一下自动取款机是不是真的。当您浏览网页和进行网上交易时，需要提防两大安全风险：恶意<br>软件和网上诱骗。某些个人或组织会利用这些攻击手段，企图窃取您的个人信息或侵入您的计算机。</p>
<p><img src="%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9.png" alt=" "></p>
<p>那么，网上诱骗和恶意软件攻击究竟是什么？</p>
<p>网上诱骗是指某些人假冒他人（通常是通过虚假网站）骗取您的个人信息。（“网上诱骗”的说法是从英<br>文中的“钓鱼”一词演化来的，因为这些图谋不轨的人像钓鱼一样投下诱饵，然后等别人上钩。）网上诱骗的<br>惯用手段是这样的：攻击者向您发送一封电子邮件，但是表面上看好像是由您所熟悉的银行或网络服务提供<br>商发送的。这封邮件的主题可能是“请更新您的银行个人信息！”邮件中包含了网上诱骗链接，您点击后以为<br>自己进入的是银行网站，实际却是虚假网站。这个虚假网站会提示您登录，这样您就在不经意间向攻击者透<br>露了自己的银行帐号、信用卡号、密码或其他敏感信息。</p>
<p>恶意软件则有所不同，通常会在您不知道的情况下安装到您的计算机上。这种软件可能会提示您下载一<br>个防病毒软件，而实际上它本身就是病毒。或者，有些网页在您访问时甚至不做任何提示就将软件安装到了<br>您的计算机上。这种软件的真正意图是从您的计算机中窃取信用卡号或密码，有时还会损害您的计算机。恶<br>意软件安装到您的计算机中以后，不仅难以删除，而且还可以自由访问它发现的所有数据和文件，并将这些<br>信息发往别处，这通常会对您的计算机造成严重损害。</p>
<hr>
<p>最新版的现代网络浏览器是抵御网上诱骗和恶意软件攻击的第一道防线。例如，大多数现代浏览器都能<br>帮助您分析网页，以寻找可能存在恶意软件的迹象，并在发现它们时提醒您。</p>
<p>另外，攻击者可能并不总是利用高超的技术手段侵入您的计算机，有时候也会耍一些小花招诱骗您做出<br>错误的决定。下面几章会向您介绍如何就保护网上安全做出更明智的决定，以及如何借助浏览器和其他网络<br>技术。</p>
<h1 id="新一代的浏览器如何帮您抵御恶意软件和网上诱骗"><a href="#新一代的浏览器如何帮您抵御恶意软件和网上诱骗" class="headerlink" title="新一代的浏览器如何帮您抵御恶意软件和网上诱骗"></a>新一代的浏览器如何帮您抵御恶意软件和网上诱骗</h1><blockquote>
<p>小心这些坏家伙!</p>
</blockquote>
<p>在您浏览网页的时候，最新版本的浏览器能保护您免受网上诱骗和恶意软件的攻击。这是通过限制您上<br>网时面临的三类安全风险实现的：</p>
<p><strong>风险 1：您遭到黑客攻击的频率有多大</strong></p>
<p>在访问恶意虚假网站或者遭到入侵的熟悉网站时，您都有可能受到攻击。大部分现代浏览器都可以预先检查<br>您访问的每个网页，如果发现某个疑似恶意的网页，就会提醒您注意。这样，您就能做出明智的判断：是否<br>真的要访问这个网页。</p>
<p><img src="%E6%8A%B5%E5%BE%A1%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6.png" alt=" "></p>
<p>例如，“Google Chrome 浏览器”采用了“安全浏览”技术，这种技术也应用于其他几种现代浏览器。当您<br>浏览网页时，浏览器会将每个网页与疑似存在网上诱骗和恶意软件的网站列表进行快速比对。这个列表会在<br>您的本地计算机上进行存储和维护，从而帮助您保护浏览隐私。如果从本地列表中找到了匹配项，浏览器就<br>会向 Google 发送一条请求，以获取更多信息。（这条请求是完全加密的，不会以纯文本形式发送。）如果<br>Google 通过验证确定是匹配项，“Chrome 浏览器”就会显示一个红色警告页面，提醒您尝试访问的网页可能<br>存在风险。</p>
<p><strong>风险 2：您的浏览器对于攻击行为的抵抗力如何</strong></p>
<p>未升级的旧版浏览器可能存在会遭到攻击的安全漏洞。无论是操作系统、浏览器还是插件，所有过期的软件<br>都存在同样的安全问题。</p>
<p>因此很有必要使用最新版的浏览器，并且及时为操作系统和插件打上安全补丁，确保它们的安全修补程序总<br>是最新的。</p>
<p>有些浏览器可自动检查更新，并根据用户的操作安装更新。“Chrome 浏览器”和其他一些浏览器在更新方<br>面更为先进，都内置了自动更新功能。这些浏览器会定期运行更新检查，然后自动升级到最新的版本，而升<br>级过程并不影响浏览。此外，“Chrome 浏览器”中还集成了 Adobe Flash Player 和 PDF 查看器，这些热门插<br>件也是可以自动更新的。</p>
<p><strong>风险 3：您的浏览器漏洞遭到攻击后会造成多大损失</strong></p>
<p>“Chrome 浏览器”和 Internet Explorer 等现代浏览器额外内置了一个称为“沙盒”的保护层。就像现实中的沙盒<br>有护壁防止沙子流出一样，浏览器的沙盒构建了一个封闭的环境，可防止恶意软件和其他安全威胁侵害您计<br>算机。在您打开恶意网页时，浏览器的沙盒会阻止恶意代码传播到浏览器外部并自行安装到您的硬盘上。这<br>样，恶意代码就不能读取、更改或进一步损害您计算机中的数据。</p>
<p>总而言之，现代浏览器可以通过以下手段，保护您免受网络安全威胁：第一，检查您要访问的网站是否<br>存在恶意软件或网上诱骗；第二，发现更安全的新版本后，会提供更新提示或进行自动更新；第三，使用浏<br>览器沙盒阻止恶意代码进一步损害计算机。</p>
<p><img src="%E6%8A%B5%E5%BE%A1%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6-1.png" alt=" "></p>
<p>在下面几章中，我们会介绍一些关于网址的基本知识，帮助您对要访问的网站作出更明智的选择。</p>
<h1 id="Using-web-addresses-to-stay-safe-使用网址，确保安全"><a href="#Using-web-addresses-to-stay-safe-使用网址，确保安全" class="headerlink" title="Using web addresses to stay safe:使用网址，确保安全"></a>Using web addresses to stay safe:使用网址，确保安全</h1><blockquote>
<p>或者说，“我的名字叫网址”</p>
</blockquote>
<p><img src="%E4%BD%BF%E7%94%A8%E7%BD%91%E5%9D%80.png" alt=" "></p>
<p>统一资源定位符（也就是人们熟知的 URL，即网址）或许听起来挺复杂的，但是不用担心，这其实就是<br>您要访问特定网页或网络应用程序时，在浏览器中键入的网址。</p>
<p>当您输入一个网址后，位于世界某个地方的托管服务器就会抓取相应的网站，通过很长的电缆将该网站<br>传输到您的本地互联网连接，并最终显示在您计算机上的浏览器中。</p>
<hr>
<p>下面是关于网址的几个示例：</p>
<p><img src="bbc.png" alt=" "><br>…访问英国广播公司的新闻网站（“.co.uk”表示这个网站是在英国注册的）</p>
<p><img src="google.png" alt=" "><br>…访问 Google 搜索引擎。</p>
<p><img src="museodelprado.png" alt=" "><br>…访问马德里普拉多美术馆 (Museo Nacional Del Prado) 的网站（“.es”表示这个网站是在西班牙注册的）</p>
<p><img src="bankofamerica.png" alt=" "><br>…访问美国银行的网上银行网站（“https://”表示这是加密连接）</p>
<hr>
<p>我们每天都会在浏览器中键入网址，已经觉得习以为常了。但是我们应该了解网址的方方面面，这有助<br>于抵御各种网上诱骗或安全攻击。</p>
<p>我们以下面的这个网址为例：</p>
<p><img src="google-maps.png" alt=" "></p>
<p>网址的第一部分称为协议。在上面的示例中，HTTP 协议是“超文本传输协议”的缩写。</p>
<p>协议后面的“<a href="http://www.google.com”部分网站是所属的主机的名称.任何个人或公司在创建新网站时,都会注/">www.google.com”部分网站是所属的主机的名称。任何个人或公司在创建新网站时，都会注</a><br>册一个属于自己的主机名，而且也只供自己使用。我们后面就会说到，这一点是非常重要的。</p>
<p>网址中的主机名部分后面可能还有路径，可以将您转到该主机上的某个特定网页，就像直接跳到书中的<br>某一章或某一页。让我们回到示例，其中的路径告诉主机服务器，您想访问 <a href="http://www.google.com/">www.google.com</a> 上的“地<br>图”(map) 网络应用程序（也就是“Google 地图”）。有时，这种路径会作为子域放到主机名的前面，例<br>如，“maps.google.com”对应“Google 地图”，“news.google.com”对应“Google 新闻”。</p>
<hr>
<p>现在我们来谈谈安全性。要判断您是否遭到网上诱骗或误入虚假网站，有一种方法就是仔细观察浏览器<br>地址栏中的网址。尤其请留意主机名：切记，使用主机名的只能是合法拥有者。</p>
<p>例如，您为了访问美国银行的网站而点击了某个链接：</p>
<p>合法网址：</p>
<ul>
<li><a href="http://www.bankofamerica.com/">www.bankofamerica.com</a> 是合法网址，因为主机名是正确的。</li>
<li><a href="http://www.bankofamerica.com/smallbusiness">www.bankofamerica.com/smallbusiness</a> 也是合法网址，因为主机名同样是正确的。这个网址的路径指向的是关<br>于小型企业的子网页。</li>
</ul>
<p>可疑网址：</p>
<ul>
<li>bankofamerica.xyz.com 不是美国银行的网站。“bankofamerica”实际上是 xyz.com 网站的子域。</li>
<li><a href="http://www.xyz.com/bankofamerica">www.xyz.com/bankofamerica</a> 也不是美国银行的网址。“bankofamerica”实际上是 <a href="http://www.xyz.com/">www.xyz.com</a> 中的路径。</li>
</ul>
<p>如果您要使用密码或帐号等敏感信息访问银行网站或进行在线交易，请首先检查地址栏中的网址！应确<br>保网址的协议是“https://”，并且浏览器地址栏中显示锁形图标。“https://”表示服务器与浏览器之间传输数据所<br>用的是安全连接。</p>
<hr>
<p>使用安全连接的美国银行网站的完整网址应该是这样的：<a href="https://www.bankofamerica.com.安全连接可以/">https://www.bankofamerica.com。安全连接可以</a><br>确保其他人无法窃取或篡改您所发送的敏感信息。所以“https://”是一个好的标志。但请注意，您依然很有必要<br>检查网址的主机名，以确保自己访问的是合法网站。（这样可以识破那些使用了安全连接的虚假网站！）</p>
<p>在下一章中，我们会介绍键入浏览器地址栏中的网址如何将您转到相应的网页。</p>
<p><img src="%E4%BD%BF%E7%94%A8%E7%BD%91%E5%9D%80.png" alt=" "></p>
<h1 id="IP-address-and-DNS：IP地址和DNS"><a href="#IP-address-and-DNS：IP地址和DNS" class="headerlink" title="IP address and DNS：IP地址和DNS"></a>IP address and DNS：IP地址和DNS</h1><blockquote>
<p>幽灵电话亭</p>
</blockquote>
<p><img src="IP%E5%9C%B0%E5%9D%80%E5%92%8CDNS.png" alt=" "></p>
<p>您想不想知道，当您在地址栏中键入网址时，浏览器是如何找到对应网页的？<br>每一个网址（例如，“<a href="http://www.google.com”)都对应一个用数字表示的互联网协议/">www.google.com”）都对应一个用数字表示的互联网协议</a> (IP) 地址。<br>如下所示：</p>
<p>74.125.19.147</p>
<p>IP 地址就是一串数字，用来表示网络上某个特定设备所在的位置，例如哪里是 google.com 或哪里是您<br>的计算机。</p>
<hr>
<p>这有点像妈妈的电话号码：拨打您妈妈的电话号码可以告知接线员将电话接到您妈妈那儿，而 IP 地址可以<br>指示您的计算机与网络上的哪台设备通信，也就是收发数据。</p>
<p>世界上有 350 亿台设备（或更多）连接在互联网上，浏览器并不能自动识别其中的每个 IP 地址，只能<br>使用所谓的“域名系统”（即 DNS）一个一个地查找。DNS 实质上就是网络“电话簿”：电话薄的作用是将“全<br>聚德烤鸭”这样的名称转换成对应的电话号码；而 DNS 则是将网址（例如，“<a href="http://www.google.com”)转换成要连/">www.google.com”）转换成要连</a><br>接的对应 IP 地址（例如，“74.125.19.147”），从而获得您想要的信息（在本例中也就是 Google 首页）。<br>当您在网络浏览器中键入“google.com”时，浏览器会通过 DNS 查找 google.com 的 IP 地址并与之连<br>接，等待目标地址做出响应以确认连接，然后将您要访问 google.com 网页的请求发送到该 IP 地址。位于该<br>IP 地址的 Google 服务器在收到请求后将所请求的网页发送回您计算机的 IP 地址，让您的浏览器显示该网<br>页。</p>
<p>不过，使用浏览器获取和载入网页与打电话相比，在很多方面还是有区别的。您打电话时可能是这样一<br>个流程：查找电话号码，拨号，等待对方接听，接通后说“喂”，等待对方回应，然后开始对话。有时候连接<br>出现问题，您就得重播。而在网络上，类似的流程是在瞬间完成的；您刚在浏览器中键<br>入“<a href="http://www.google.com”,google/">www.google.com”，Google</a> 首页就显示出来了。</p>
<p>下一章我们会介绍一下，使用浏览器获取和载入网站时，如何通过扩展验证证书验证网站的身份。</p>
<h1 id="Validating-identities-online：在线身份验证"><a href="#Validating-identities-online：在线身份验证" class="headerlink" title="Validating identities online：在线身份验证"></a>Validating identities online：在线身份验证</h1><blockquote>
<p>“您就是那谁吧?”</p>
</blockquote>
<p>在现实生活中，您可以直接看到与您分享信息的对象。您可以与对方面对面地交谈，或者在银行分行这<br>样可以信赖的场所会面。您会通过这种方式产生第一印象，判断对方是否值得信赖。</p>
<p>但是在网络上，很难知道网站背后的人究竟是谁。我们通常所依赖的一些表面迹象可能是假的。例如，<br>虚假网页会模仿真实银行网站的徽标、图标和设计风格，就好象是在您住的街区开了一家冒牌店面。</p>
<p>幸运的是，有一些工具可以帮助您判断网站的真伪。有些网站具备扩展验证证书，可让您判断运营该网<br>站的组织名称。这种扩展验证证书所提供的信息可帮助您确保不会将个人信息透露给虚假网站。</p>
<p><img src="%E5%9C%A8%E7%BA%BF%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.png" alt=" "></p>
<p>下面的示例介绍了如何在浏览器中进行扩展验证。如果某个银行的网站已经通过了扩展验证，那么该银<br>行的名称就会显示地址栏的锁形图标与网址之间的绿色框中。</p>
<p><img src="Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A9%E5%B1%95%E9%AA%8C%E8%AF%81%E6%A0%87%E5%BF%97%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="Chrome 浏览器中扩展验证标志的示例"></p>
<p>大多数浏览器都提供了扩展验证标志，只要在浏览器地址栏的绿色部分中查找相关组织的名称就可以发<br>现。您还可以点击此类标志，从而查看相关网站的安全信息以及数字证书。</p>
<hr>
<p>网站拥有者必须通过一系列的检查，在合法身份和权威性得到确认后，才能获得扩展验证证书。在前面<br>的示例中，对 bankofamerica.com 的扩展验证得到了肯定的结果，该网站确实是美国银行的官方网站。您可以将这种证书看成一条纽带，将网址的域名与现实中的某种身份联系在了一起。</p>
<p>只有在您信任运营该网站的组织的情况下，才可以向该网站提供敏感信息。因此，以后您在网络上处理<br>敏感信息之前，请务必先查看相关网站的安全信息。您会发现，这样做绝对是值得的。</p>
<h1 id="Evolving-to-a-faster-web：向更快的网络时代迈进"><a href="#Evolving-to-a-faster-web：向更快的网络时代迈进" class="headerlink" title="Evolving to a faster web：向更快的网络时代迈进"></a>Evolving to a faster web：向更快的网络时代迈进</h1><blockquote>
<p>加快网络上图片、视频和 JAVASCRIPT 的速度</p>
</blockquote>
<p><img src="%E5%90%91%E6%9B%B4%E5%BF%AB%E7%9A%84%E7%BD%91%E7%BB%9C%E6%97%B6%E4%BB%A3%E8%BF%88%E8%BF%9B.png" alt=" "></p>
<p>如今的网络就像一锅色香味俱全的大杂烩，有着海量的图片、照片、视频以及奇妙的网络应用程序。网<br>络上某些最生动的体验来自于各种图片和视频，例如，家庭度假的共享相册或者战地记者发布的在线视频报<br>道。</p>
<p>如今的网络已经远远超出了当初那种简单文本和链接的范畴。这意味着每当您的浏览器载入一个网页<br>时，都需要处理更多的数据和更复杂的代码。</p>
<hr>
<p>数据量和复杂程度究竟提高了多少呢？下面的一些统计数据足以令人震惊：</p>
<ul>
<li>按每页字节数计算，目前一个常见网页上的图片和照片占据了大约 65% 的信息量。</li>
<li>每分钟有总时长 35 小时的视频上传到 YouTube。（这就好比好莱坞每周要发行 13 万部新片，不过爆米花<br>消耗量可没这么多。）</li>
<li>JavaScript 程序的源代码已经从只有几行增加到了几百 KB，每次载入网页或应用程序时都必须处理这些<br>JavaScript 程序。</li>
</ul>
<p>那么，这些汹涌而来的数据会减慢浏览器载入网页的速度吗？互联网会很快因为堵塞而变得一团糟吗？</p>
<p>这不太可能。计算机科学家们找到了将图片和照片压缩成较小文件的方法，以便于发送和下载，使它们<br>可以在网络上广泛应用。GIF 和 JPEG 是早期文件压缩系统中最常用的格式。同时，插件的发明打破了<br>HTML 的早期限制，让视频可以嵌入在网页中并进行播放。</p>
<hr>
<p>将来，用户利用 HTML5 中的 <video> 标记就可以轻松地在网页中嵌入和播放视频了。Google 还与网<br>络社区在 WebM 项目上展开合作，致力于开发一种免费的开放源代码视频格式，可以适应网络上的各种计算<br>机性能和带宽条件，这样无论是内布拉斯加州农家的计算机还是内罗毕的智能手机，都能收到高品质的视<br>频。</p>
<p>不过，包含较大照片或其他图片的网页在载入时依然很慢。因此，Google 的一些工程师一直在尝试进一<br>步压缩图片的新方法，同时还要保持图片的质量和分辨率。初步结果如何呢？非常乐观。他们开发出了一种称为 WebP 的新图片格式，可以将普通图片文件的大小压缩 39%。</p>
<p>在现代浏览器中运行 JavaScript 代码的引擎也经过了重新设计，能够比以往更快地处理代码。这些快速<br>JavaScript 引擎（如“Google Chrome 浏览器”的 V8 引擎）已成为所有现代浏览器的核心部分。这意味着基<br>于 JavaScript 的下一代网络应用程会拥有极高的实用性，并彻底摆脱 JavaScript 代码复杂度日益增加所带来<br>的羁绊。</p>
<p>“Google Chrome 浏览器”等现代浏览器还采用了一种称为“DNS 预解析”的技术，可以更快地抓取和载入<br>网页。通过 DNS 查找将网址转换为 IP 地址的过程称为“解析”，反之则称为“反向解析”。“Chrome 浏览<br>器”会通过 DNS 预解析同时查找网页上的其他所有链接，并在后台将这些链接预解析为 IP 地址。因此，当<br>您实际点击网页上的某个链接后，浏览器就能立即将您转到新的网页。</p>
<hr>
<p>随着使用次数的增加，“Chrome 浏览器”还能通过以前的访问记录获取信息，这样您在下次访问某个以前曾访<br>问过的网页时，“Chrome 浏览器”就会自动预解析该网页上的所有相关链接和元素。</p>
<p>或许有一天，浏览器能在载入网页前就做出预测，不仅知道要预解析哪些链接，还知道要预先抓取哪些<br>网站元素（如图片或视频）。这会使网络速度更快。</p>
<p>我们希望在不久的将来，浏览器载入新网页就像翻书一样快。</p>
<h1 id="Open-source-and-browsers：开放源代码和浏览器"><a href="#Open-source-and-browsers：开放源代码和浏览器" class="headerlink" title="Open source and browsers：开放源代码和浏览器"></a>Open source and browsers：开放源代码和浏览器</h1><blockquote>
<p>站在巨人的肩膀上</p>
</blockquote>
<p><img src="%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8.png" alt=" "></p>
<p>如今的互联网站在了巨人们的肩膀上：技术人员、点子专家、开发人员以及那些不断拓展创新范围和分<br>享自己知识的组织。</p>
<p>分享精神正是开放源代码的核心所在。</p>
<p>“开放源代码”意味着将软件的内部运行方式（也就是“源代码”）公布于众，而软件也会以一种开放和协作的<br>方式编写。任何人都可以查看源代码、了解它的原理、对它进行调整或补充，并在其他产品或服务中重复使<br>用。</p>
<hr>
<p>开放源代码软件在网络的很多方面（包括现代浏览器）都起着巨大的作用。开放源代码浏览器 Mozilla<br>Firefox 的发布，为日后很多出色的浏览器创新功能铺平了道路。“Google Chrome 浏览器”也是在 Mozilla<br>Firefox 浏览器的某些组件以及开放源代码呈现引擎 WebKit 等基础上开发的。本着同一种精神，Google 开<br>放了“Chrome 浏览器”的源代码，让全世界的网络社区都可以在他们自己的产品中使用“Chrome 浏览器”的创<br>新，甚至进一步完善“Chrome 浏览器”的源代码。</p>
<p>这种开放源代码的浏览器更快、更简单而且更安全，它的受益者并不单单是网页开发人员和普通用户。<br>像 Google 这样的公司也在公开分享构想的过程中受益匪浅。</p>
<p>更好的浏览器可以为用户提供更好的网络体验，而用户在获得更好的体验后，又会浏览更多的网络内容。更<br>好的浏览器还可以帮助企业开发出具有最新先进功能的网络应用程序，这同样可以改善用户体验。</p>
<p>浏览器并不是网络中唯一能采用开放源代码做法的地方。您可以去问一下任何一位网络开发人员，他们<br>在托管和发布网站的过程中，可能都会用到开放源代码的 Apache HTTP Server；或者，他们是在安装了<br>Linux 开放源代码操作系统的计算机上开发了代码，以上只是几个示例。开放源代码社区会一如既往地为改<br>进网络而努力，让网络成为可供下一代人站立的宽阔肩膀。</p>
<h1 id="19-thins-later-最后一个须知…"><a href="#19-thins-later-最后一个须知…" class="headerlink" title="19 thins later: 最后一个须知…"></a>19 thins later: 最后一个须知…</h1><blockquote>
<p>云计算时代的生活</p>
</blockquote>
<p>…现在我们要说第 20 件事情了。让我们概括一下。</p>
<p>如今的网络是一个多姿多彩、生动直观、注重实效、古灵精怪、繁忙热闹、朋友汇聚、有趣并且非常实<br>用的地方。我们许多人都生活在互联网上的云计算中：我们使用基于网络的应用程序在浏览器中在线读新<br>闻、看电影、和朋友聊天以及处理我们的日常事务。网络应用程序让我们可以在任何地方做这些事情，就算<br>是自己的笔记本电脑留在家里也可以。</p>
<p>这一切都要归功于 HTML、JavaScript 和 CSS 等网络标准，以及浏览器插件。HTML5 的新功能可以帮<br>助开发人员构建颇具创意的下一代网络应用程序。</p>
<p><img src="%E4%BA%91%E8%AE%A1%E7%AE%97%E6%97%B6%E4%BB%A3%E7%9A%84%E7%94%9F%E6%B4%BB.png" alt=" "></p>
<p>云计算还有哪些其他的前景？<br>只有新一代的浏览器才能充分利用网络的各种<br>新功能。</p>
<ul>
<li>新一代的浏览器还能保护用户免受恶意软件和网上诱骗的攻击。</li>
<li>开放源代码共享为我们提供了更好的浏览器以及速度更快、内容更丰富而且架构更精密的网络。开放源代码<br>的智能将会为网络开创更加美好的未来。</li>
<li>未来有哪些值得期待的事情？浏览器支持 3D 功能，载入速度更快，在各种设备之间同步，以及其他一些事<br>情。</li>
<li>要成为网络达人，您需要自学一些东西，例如：针对各种不同的内容（包括 Cookie）控制浏览器的隐私设<br>置。</li>
<li>只要您注意浏览器中一些可见的提示，上网就会更安全，例如检查您要访问的网址，寻找“https://”安全连接或<br>扩展验证。</li>
</ul>
<p>最后总结</p>
<p><strong>使用新一代的浏览器</strong>，这是首当其冲的。或者尝试使用一种新型浏览器，看它能否更好地满足您的需<br>要，为您提供更愉快的浏览体验。</p>
<p><strong>网络会以惊人的速度不断发展！</strong> 支持像 HTML5、CCS3 和 WebGL 等尖端网络技术，因为这些技术会<br>帮助网络社区构想并实现创新的美好未来。</p>
<p><strong>最后，尝试一下新事物。</strong> 网络上每天都会出现新奇而令人兴奋的事物，不妨尝试一下您以前没有想过能<br>在网上做的事情，比如搜索前十代的祖先，或者观看从喜马拉雅山攀登营地发来的实时网络影像。您会对自<br>己的发现大吃一惊！</p>
]]></content>
      <categories>
        <category>互联网</category>
      </categories>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-SpringSecurity整合</title>
    <url>/20200722/java/springboot/1e755469/</url>
    <content><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>以下代码基于SpringBoot 2.4.1(SpringSecurity 5.4.2)</p>
<h2 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h2><p>使用SpringBoot可以很轻松的完成SpringSecurity的集成，因为SpringBoot默认帮我们做了<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-hello-auto-configuration">很多事</a></p>
<blockquote>
<p>默认创建一个UserDetailsService具有用户名user和随机生成的密码的Bean，并将其记录到控制台</p>
</blockquote>
<p>未整理完成……</p>
 <a id="more"></a>

<p>直接pom.xml中加入引用即可:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写一个测试controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，浏览器中输入<a href="http://localhost:8080/">http://localhost:8080/</a>, 此时会自动跳转到SpringSecurity提供的默认登录页，输入用户名(user)和密码(从控制台中找到随机密码)后页面输出: hello world</p>
<p>如果不想用随机密码，可在application.yml(默认application.properties建议改下后缀)配置默认账户密码:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h2 id="Web表单登录"><a href="#Web表单登录" class="headerlink" title="Web表单登录"></a>Web表单登录</h2><p>SpringSecurity提供了一个默认的登录页面，我们需要改用为自己的登录页面(不想改也没关系，毕竟默认的登录页比有些自定义的还好看些):</p>
<ul>
<li>新建WebSecurityConfig用于对SpringSecurity进行配置(大部分配置都是在这个类中修改):</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        super.configure(http);</span></span><br><span class="line">        http</span><br><span class="line">                .formLogin(form -&gt; form</span><br><span class="line">                        .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                        .permitAll()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>为了编写方便，引入<a href="https://www.thymeleaf.org/">Thymeleaf</a>模板：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编写登录页(src/main/resources/templates/login.html)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.error&#125;&quot;</span>&gt;</span></span><br><span class="line">    用户名或密码错误.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.logout&#125;&quot;</span>&gt;</span></span><br><span class="line">    您已登出.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>登录页面根据自己的需求进行改写，但需要注意: 必须发送的登录请求为POST形式的/login, 必须包含username和password字段(即可以不用Thymeleaf或者使用ajax模拟form表单请求), 否则需要改写:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果登录页面引用了js、css等静态资源的话需要加入</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">        http</span><br><span class="line">                .formLogin(form -&gt; form</span><br><span class="line">                        .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                        .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                        .usernameParameter(<span class="string">&quot;custom_username&quot;</span>)</span><br><span class="line">                        .passwordParameter(<span class="string">&quot;custom_password&quot;</span>)</span><br><span class="line">                        .permitAll()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为我们引入了web模块，使用的是Spring MVC，则需要一个映射GET形式的/login 到我们创建的登录页面的controller(当然也可以使用统一的WebMvcConfig, 这里就不展开了):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新启动项目，访问<a href="http://localhost:8080/">http://localhost:8080/</a>, 此时会自动跳转到我们编写的登录页，输入用户名和密码后页面输出: hello world</p>
<p><a href="https://github.com/jonesun/spring-security-demo/tree/master/web-server">示例源码-web-server</a></p>
<h2 id="Web前后端分离"><a href="#Web前后端分离" class="headerlink" title="Web前后端分离"></a>Web前后端分离</h2><p>日常开发中经常会使用前后端分离技术： 将web页面做成静态页面(可能使用vue等技术)单独部署，后台提供restful接口</p>
<ul>
<li>改写WebSecurityConfig:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取用户账号密码及权限信息</span></span><br><span class="line">        <span class="keyword">return</span> username -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;username: &quot;</span> + username);</span><br><span class="line">            <span class="keyword">return</span> User.withUsername(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).passwordEncoder(s -&gt; s).roles(<span class="string">&quot;USER&quot;</span>).build();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置默认的加密方式（强hash方式加密）</span></span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果登录页面引用了js、css等静态资源的话需要加入</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/*.html&quot;</span>,<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        super.configure(http);</span></span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .successHandler((httpServletRequest, httpServletResponse, authentication) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;登录成功: &quot;</span> + httpServletRequest.getSession().getId());</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;data&quot;</span>, authentication);</span><br><span class="line">                    httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                    PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .failureHandler((req, resp, ex) -&gt; &#123;</span><br><span class="line"><span class="comment">//                    ex.printStackTrace();</span></span><br><span class="line">                    resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> UsernameNotFoundException || ex <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;账户被禁用&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录失败!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;data&quot;</span>, authentication);</span><br><span class="line">                    resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">//未登录</span></span><br><span class="line">                .authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">                    resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//权限不足</span></span><br><span class="line">                .accessDeniedHandler((request, httpServletResponse, ex) -&gt; &#123;</span><br><span class="line">                    httpServletResponse.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">                    httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line"><span class="comment">//                    httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);</span></span><br><span class="line">                    PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//1,允许任何来源 *表示任何请求都视为同源(生产环境尽量在配置文件中动态配置部署到的域名)，若需指定ip和端口可以改为如“localhost：8080”</span></span><br><span class="line">        corsConfiguration.setAllowedOriginPatterns(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">//2,允许任何请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">//3,允许任何方法</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">//4,允许凭证</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 一定要开启cors允许跨域访问，这样就可以让session共享，但生产环境中不要直接允许所有请求，根据实际情况指定域名列表</p>
</blockquote>
<ul>
<li>在任意文件夹中新建html静态文件:</li>
</ul>
<p>login.html 建议引入Jquery的ajax表单提交插件<a href="https://github.com/jquery-form/form">jquery-form</a>，以便处理form表单请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.5.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.form.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/web-server-rest/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;submitBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;#loginForm&#x27;</span>).ajaxForm(&#123;</span></span><br><span class="line">            beforeSubmit: validate,</span><br><span class="line"><span class="javascript">            xhrFields: &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;,    <span class="comment">//前端适配：允许session跨域</span></span></span><br><span class="line"><span class="javascript">            crossDomain: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//返回数据处理</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">                $(location).attr(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            error: <span class="function"><span class="keyword">function</span> (<span class="params">ex</span>) </span>&#123;</span></span><br><span class="line">                alert(ex);</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ex);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;校验参数&quot;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.html <strong>ajax请求需加上withCredentials以便支持跨域请求(将cookie中JSESSIONID发送到服务端)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.5.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">这是首页</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;logoutBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登出&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// dataType: &quot;json&quot;,</span></span></span><br><span class="line"><span class="javascript">            crossDomain: <span class="literal">true</span>,</span></span><br><span class="line">            xhrFields: &#123;</span><br><span class="line"><span class="javascript">                withCredentials: <span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            url:<span class="string">&quot;http://localhost:8080/web-server-rest/api/sayHello&quot;</span>,</span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            error: <span class="function"><span class="keyword">function</span> (<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;异常处理&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(jqXHR);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(textStatus);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(errorThrown);</span></span><br><span class="line">                if(jqXHR.status === 403) &#123;</span><br><span class="line"><span class="javascript">                    <span class="comment">//可以编写一个公共js, 遇到接口返回需要登录时统一跳转到登录页</span></span></span><br><span class="line"><span class="javascript">                    $(location).attr(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;login.html&#x27;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#logoutBtn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                type:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">                crossDomain: <span class="literal">true</span>,</span></span><br><span class="line">                xhrFields: &#123;</span><br><span class="line"><span class="javascript">                    withCredentials: <span class="literal">true</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;http://localhost:8080/web-server-rest/logout&quot;</span>,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(data);</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                error: <span class="function"><span class="keyword">function</span> (<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(jqXHR);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(textStatus);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(errorThrown);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>概念解析</p>
</blockquote>
<p>CSRF: 跨站请求伪造,是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法</p>
<p>对普通用户可能由浏览器处理的任何请求使用CSRF保护。如果仅创建非浏览器客户端使用的服务，则可能需要禁用CSRF保护。</p>
<p>CORS: 跨域资源共享, 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p>Spring Security的默认设置是禁用缓存以保护用户的内容。</p>
<blockquote>
<p><strong>cors实现了直接跨域,安全性和灵活性更高</strong>,关键在配置好AllowedOrigin。CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。</p>
</blockquote>
<p>还有一种支持跨域访问的方式就是[nginx](SpringBoot 实现前后端分离的跨域访问（Nginx）)]了，有兴趣可以了解下</p>
<p>关于cors的介绍可以参考<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></p>
<p>使用这种方式的好处在于: cookie+sessionId的维护由浏览器自动完成，无需额外编写代码</p>
<p><a href="https://github.com/jonesun/spring-security-demo/tree/master/web-rest">示例源码-web-rest</a></p>
<blockquote>
<p>如果是一般的中小型项目，这种方式就行了，而如果项目访问量较大, 或者需要支持分布式的话，会面临以下问题:</p>
</blockquote>
<ul>
<li>服务端保存大量数据，增加服务端压力</li>
<li>服务端保存用户状态，不支持集群化部署</li>
</ul>
<p>这个时候可以进行改造采用redis将session缓存起来，配合一些分布式session共享技术</p>
<h2 id="前后端分离-为app、桌面程序或者小程序等提供服务"><a href="#前后端分离-为app、桌面程序或者小程序等提供服务" class="headerlink" title="前后端分离-为app、桌面程序或者小程序等提供服务"></a>前后端分离-为app、桌面程序或者小程序等提供服务</h2><p>因为不是基于浏览器，无法使用session, 这里就需要引入<a href="https://jwt.io/">jwt</a>技术了，但JWT是一种规范，并没有和某一种语言绑定在一起，实际使用过程中可根据自己需要选择相应库：</p>
<ul>
<li>com.auth0: ava-jwt </li>
<li>org.bitbucket.b_c: jose4j </li>
<li>com.nimbusds: nimbus-jose-jwt</li>
<li>io.jsonwebtoken: jjwt-root</li>
<li>io.fusionauth: fusionauth-jwt</li>
<li>io.vertx: vertx-auth-jwt </li>
<li>……</li>
</ul>
<p>之前看到Spring Security OAuth中使用的是nimbus-jose-jwt，我们就以这个库来举下例子</p>
<ol>
<li>pom.xml中加入依赖:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.nimbusds<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nimbus-jose-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个是为了演示时使用随机数生成keyId 非必须 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写JwtUtils</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nimbusds.jose.JOSEException;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jose.JWSAlgorithm;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jose.JWSHeader;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jose.JWSSigner;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jose.crypto.RSASSASigner;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jose.crypto.RSASSAVerifier;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jwt.JWTClaimsSet;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jwt.SignedJWT;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.RandomStringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPairGenerator;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.InvalidKeySpecException;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间50秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">1000</span> * <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 这里仅仅为了演示rsa的加解密功能，实际项目中需自行生成好再读取。或者使用jks的方式读取</span></span><br><span class="line">    <span class="comment">//公钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String publicKeyStr = <span class="string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvSja2vpalTbaNg8ChQt133AC6RPD3mpvkPzezb5lw48+AmVyodtJ817Uoi6p+QpkeNyxoivRYEq4Swyf8F18galvstKsR56cjr4oG4XngV0IKNbG+u+/LWqrI8i64PVhn5+wV8L9gwxF/F6tqh4uxoMLK1UAiQ+Pbwk7VTCiVgDAllIk8hAxGKXYN2e2i/ZjeP3jjvyClTYxBKEXWD+EqTflGnbLDs9yqcLgjwcpH+9csY6b7KCIbvFUY/CWJi9n7shRYZZHv3aTJAMbo3VpwDEOpXQXbrZw6mYF7OrHjWVWiMmUHhaVXk73gOx/DbyNp89UOa+t7wyk0A5coPii5wIDAQAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String privateKeyStr = <span class="string">&quot;MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC9KNra+lqVNto2DwKFC3XfcALpE8Peam+Q/N7NvmXDjz4CZXKh20nzXtSiLqn5CmR43LGiK9FgSrhLDJ/wXXyBqW+y0qxHnpyOvigbheeBXQgo1sb6778taqsjyLrg9WGfn7BXwv2DDEX8Xq2qHi7GgwsrVQCJD49vCTtVMKJWAMCWUiTyEDEYpdg3Z7aL9mN4/eOO/IKVNjEEoRdYP4SpN+UadssOz3KpwuCPBykf71yxjpvsoIhu8VRj8JYmL2fuyFFhlke/dpMkAxujdWnAMQ6ldBdutnDqZgXs6seNZVaIyZQeFpVeTveA7H8NvI2nz1Q5r63vDKTQDlyg+KLnAgMBAAECggEAYSK3sDdbiMBQMe5nRtbpwsGMXRAvRum1POj9qP2a2F+YYjaiNQec5ALQgjAgTKjPi1kZRsPlkuML3E4xW4dGRncxysxwd561mn9/rRKIHWAerooMSBQRQktCcu/DN34KkaO5NHgHIuKMldowp+kz7/CfLbNKwRdieoxtEYQV+L8rjCYOQUHJMez02G8N4IRkLmY73XlHKQmKBHSuLP/IKNZQbJrmr6Tsjj5NoBKHTSuuEY3QDDqMbZHNh3XYoYOVNnFbqDRjlUx4BLQgLpz5KBOxcV+xP5xyuPZuUlWuS9+3ADeiCptiTO9fDZHxZDHjw0qJo7KBWgLbL+e14KCO8QKBgQDsot+ZVJI9jpOoqPbej7jDDlRSo3zV73IfIHKPiNnbCRJgFUCYXIf6xtOi5+z908T1Cv3e6aQGW8pNUTwco1EMuNgMIPmITMoq6NWzBsbIVw+plIWpOzJQnIPsN8UZAAaxtP+DLrYCgOKDfQa7jKgMlgjWIzIovP7e2oG2eWKTewKBgQDMo207lNmvqIMr8LD3guEjN7GJOVp8yHKbpqMjZwwLoI3BADJDWef0nT/fyB1agfvq80IeA3f6H/ID0qztkNVEqfQWoDrN08Q8pn5K+GGXIirkSivzIM4+mV1SOHDgyoNks8pK2gGmG5bO3SvUlo1Q6MW1pXOrSVwJ0krltvTMhQKBgFIEhdGEQYe6ci1kGuS7FcPtpIZcCfmwm3J0caCUQ0Yq18abtx7X+32NCm+NSVQU4VA5dhKcEnDtwamYvWgDpyTssF1L1JFMZEoJF4CMmbt4iYIyaz1juiW8ifEGx3bJzogrfuA+AXHOsDP40quQrfJm0js+SbVbBE/Dlm/jlKofAoGAUuVQ9nXRyOqGWGJkDZ+i+9UvwdrN4QaCBrN2Gn0/z+X2BlzB/66H2/tnSIuT+Hn3RrHL8sSM8XHHY+0PyByHiA0gp5m4uHA0ai03s77yKXrZzSiOrSp44brWptvePfFLUJvUMoYlbNh4Osw1WSSzkjb5ACBJvvU0p3XciTmX6NECgYEAgoN0GvFls1A+Jhcr9BqVCk+jHcAUhxmQtuQjgGPnUUovrbCc/PtfiM9FKvpxa30SbBjW4t7itfqKLg1zpJcnCOhrhQl7QnnRpGFkRh9STA3xsjsp/dRS5popNR6iGOvEulgobWxK9Ogln61mreZFQSmHVjWPSQQOitJiKWmWxAI=&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            generateRSAKey();</span></span><br><span class="line"><span class="comment">//        &#125; catch (NoSuchAlgorithmException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private static void generateRSAKey() throws NoSuchAlgorithmException &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span></span><br><span class="line"><span class="comment">//        keyPairGenerator.initialize(2048);</span></span><br><span class="line"><span class="comment">//        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span></span><br><span class="line"><span class="comment">//        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span></span><br><span class="line"><span class="comment">//        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        publicKeyStr = Base64.getEncoder().encodeToString(publicKey.getEncoded());</span></span><br><span class="line"><span class="comment">//        privateKeyStr = Base64.getEncoder().encodeToString(privateKey.getEncoded());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;公钥：&quot; + publicKeyStr);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;私钥：&quot; + privateKeyStr);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildToken</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//keyId 全数字的随机值</span></span><br><span class="line">            String keyId = RandomStringUtils.random(<span class="number">32</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            JWSSigner jwsSigner = <span class="keyword">new</span> RSASSASigner(getRSAPrivateKey(privateKeyStr));</span><br><span class="line"></span><br><span class="line">            JWSHeader header = <span class="keyword">new</span> JWSHeader.Builder(JWSAlgorithm.RS512).keyID(keyId).build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String payloadText = <span class="string">&quot;I am jonesun [RSA]&quot;</span>;</span><br><span class="line">            JWTClaimsSet claimsSet = <span class="keyword">new</span> JWTClaimsSet.Builder()</span><br><span class="line">                    .subject(authentication.getName())</span><br><span class="line">                    .issuer(<span class="string">&quot;http://localhost:8080/web-server-jwt/&quot;</span>)</span><br><span class="line">                    <span class="comment">// 设置登录用户的角色</span></span><br><span class="line">                    .audience(authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.toList()))</span><br><span class="line">                    .claim(<span class="string">&quot;payloadText&quot;</span>, payloadText)</span><br><span class="line">                    .expirationTime(<span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME))</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            SignedJWT signedJWT = <span class="keyword">new</span> SignedJWT(header, claimsSet);</span><br><span class="line">            signedJWT.sign(jwsSigner);</span><br><span class="line">            <span class="keyword">return</span> signedJWT.serialize();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JWTClaimsSet <span class="title">verifyToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        SignedJWT jwt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jwt = SignedJWT.parse(token);</span><br><span class="line">            <span class="comment">//使用公钥 进行解密</span></span><br><span class="line">            RSASSAVerifier rsassaVerifier = <span class="keyword">new</span> RSASSAVerifier(getRSAPublicKey(publicKeyStr));</span><br><span class="line">            <span class="comment">//校验是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!jwt.verify(rsassaVerifier)) &#123;</span><br><span class="line">                <span class="comment">//todo token无效</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> jwt.getJWTClaimsSet();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException | JOSEException | NoSuchAlgorithmException | InvalidKeySpecException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RSAPublicKey <span class="title">getRSAPublicKey</span><span class="params">(String publicKeyStr)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException </span>&#123;</span><br><span class="line">        <span class="comment">// base64编码的公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] decoded = Base64.getDecoder().decode(publicKeyStr);</span><br><span class="line">        <span class="keyword">return</span> (RSAPublicKey) KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>).generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(decoded));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RSAPrivateKey <span class="title">getRSAPrivateKey</span><span class="params">(String privateKeyStr)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] decoded = Base64.getDecoder().decode(privateKeyStr);</span><br><span class="line">        <span class="keyword">return</span> (RSAPrivateKey) KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>).generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(decoded));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>加入JwtLoginFilter过滤器-用于生成token</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.serverjwt.JWTUtils;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.serverjwt.LoginUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationServiceException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录的过滤器</span></span><br><span class="line"><span class="comment"> * 在用户的登录的过滤器中校验用户是否登录成功</span></span><br><span class="line"><span class="comment"> * 如果登录成功，则生成一个 token 返回给客户端，登录失败则给前端一个登录失败的提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtLoginFilter</span><span class="params">(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> AntPathRequestMatcher(defaultFilterProcessesUrl));</span><br><span class="line">        setAuthenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest req, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> AuthenticationException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 支持json与form表单登录方式</span></span><br><span class="line">        String contentType = req.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (req.getContentType().startsWith(MediaType.APPLICATION_FORM_URLENCODED_VALUE)) &#123;</span><br><span class="line">            String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="comment">//进行登录校验，如果校验成功，会到 successfulAuthentication 的回调中，否则到 unsuccessfulAuthentication 的回调中</span></span><br><span class="line">            <span class="keyword">return</span> getAuthenticationManager().authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.getContentType().startsWith(MediaType.APPLICATION_JSON_VALUE)) &#123;</span><br><span class="line">            LoginUser loginUser = <span class="keyword">new</span> ObjectMapper().readValue(req.getInputStream(), LoginUser.class);</span><br><span class="line">            <span class="keyword">return</span> getAuthenticationManager().authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(loginUser.getUsername(), loginUser.getPassword()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;contentType not supported: &quot;</span> + contentType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse resp, FilterChain chain, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String jwt = JWTUtils.buildToken(authentication);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>, jwt);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;error&quot;</span>, failed.getMessage());</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的LoginUser为简单的用户名密码，可自行添加字段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加入JwtFilter过滤器-用于验证接口token有效性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.jonesun.serverjwt.JWTUtils;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jwt.JWTClaimsSet;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.GenericFilterBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">// 获取 token ，注意获取方式要跟前台传的方式保持一致</span></span><br><span class="line">        <span class="comment">// 这里请求时注意认证方式选择 Bearer Token，会用 header 传递</span></span><br><span class="line">        String jwtToken = req.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (jwtToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 校验后需做一些逻辑上的判断: 如是否为空、是否有效等</span></span><br><span class="line">        JWTClaimsSet jwtClaimsSet = JWTUtils.verifyToken(jwtToken.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取用户名</span></span><br><span class="line">        String username = jwtClaimsSet.getSubject();</span><br><span class="line">        logger.info(<span class="string">&quot;username: &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户角色，注意 &quot;authorities&quot; 要与生成 token 时的保持一致</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = jwtClaimsSet.getAudience().stream().map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        UsernamePasswordAuthenticationToken token = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, <span class="keyword">null</span>, authorities);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置到Spring Security中，用于后面的校验(这步是关键)</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>配置过滤器到WebSecurityConfig中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.serverjwt.filter.JwtFilter;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.serverjwt.filter.JwtLoginFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.NoOpPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jone.sun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-23 15:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取用户账号密码及权限信息</span></span><br><span class="line">        <span class="keyword">return</span> username -&gt; User.withUsername(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).passwordEncoder(s -&gt; s).roles(<span class="string">&quot;USER&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo 设置默认的加密方式 此处仅为演示用，实际项目请改为其他加密方式如BCryptPasswordEncoder采用了SHA-256 +随机盐+密钥对密码进行加密，更加安全</span></span><br><span class="line">       <span class="comment">//Spring Security默认使用DelegatingPasswordEncoder</span></span><br><span class="line">        <span class="comment">//PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();</span></span><br><span class="line">        <span class="comment">//return new BCryptPasswordEncoder();</span></span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> JwtLoginFilter(<span class="string">&quot;/login&quot;</span>, authenticationManager()), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> JwtFilter(), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">//未登录</span></span><br><span class="line">                .authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">                    resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;未登录-token为空&quot;</span>);</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//权限不足</span></span><br><span class="line">                .accessDeniedHandler((request, httpServletResponse, ex) -&gt; &#123;</span><br><span class="line">                    httpServletResponse.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">                    httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                    httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line"><span class="comment">//                    httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);</span></span><br><span class="line">                    PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//1,允许任何来源 *表示任何请求都视为同源(生产环境尽量在配置文件中动态配置部署到的域名)，若需指定ip和端口可以改为如“localhost：8080”</span></span><br><span class="line">        corsConfiguration.setAllowedOriginPatterns(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">//2,允许任何请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">//3,允许任何方法</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">//4,允许凭证</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>编写测试：这里我们还是用html演示，实际上可以改写为任意平台使用http发送请求即可</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.5.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.form.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/web-server-jwt/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;submitBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;模拟json登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;#loginForm&#x27;</span>).ajaxForm(&#123;</span></span><br><span class="line">            beforeSubmit: validate,</span><br><span class="line"><span class="javascript">            xhrFields: &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;,    <span class="comment">//前端适配：允许session跨域</span></span></span><br><span class="line"><span class="javascript">            crossDomain: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//返回数据处理</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">//测试是否可以获取到数据</span></span></span><br><span class="line"><span class="javascript">                test(<span class="string">&quot;Bearer &quot;</span> + data.token);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            error: <span class="function"><span class="keyword">function</span> (<span class="params">ex</span>) </span>&#123;</span></span><br><span class="line">                alert(ex);</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ex);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#myBtn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                type:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">                crossDomain: <span class="literal">true</span>,</span></span><br><span class="line">                xhrFields: &#123;</span><br><span class="line"><span class="javascript">                    withCredentials: <span class="literal">true</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;http://localhost:8080/web-server-jwt/login&quot;</span>,</span></span><br><span class="line"><span class="javascript">                contentType: <span class="string">&quot;application/json;charset=utf-8&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data: <span class="built_in">JSON</span>.stringify(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;),</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(data);</span></span><br><span class="line">                    test(data.token);</span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                error: <span class="function"><span class="keyword">function</span> (<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(jqXHR);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(textStatus);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(errorThrown);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;校验参数&quot;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">token</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">            dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="javascript">            crossDomain: <span class="literal">true</span>,</span></span><br><span class="line">            xhrFields: &#123;</span><br><span class="line"><span class="javascript">                withCredentials: <span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// request.setRequestHeader(&quot;Authorization&quot;, sessionStorage.getItem(&quot;Authorization&quot;));</span></span></span><br><span class="line"><span class="javascript">                request.setRequestHeader(<span class="string">&quot;Authorization&quot;</span>, token);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            url:<span class="string">&quot;http://localhost:8080/web-server-jwt/api/sayHello&quot;</span>,</span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            error: <span class="function"><span class="keyword">function</span> (<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;异常处理&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(jqXHR);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(textStatus);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(errorThrown);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// if(jqXHR.status === 403) &#123;</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//     //可以编写一个公共js, 遇到接口返回需要登录时统一跳转到登录页</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//     $(location).attr(&#x27;href&#x27;, &#x27;login.html&#x27;);</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// &#125;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/jonesun/spring-security-demo/tree/master/jwt">示例源码-jwt</a></p>
<h2 id="同时支持web表单、web前后端分离和jwt"><a href="#同时支持web表单、web前后端分离和jwt" class="headerlink" title="同时支持web表单、web前后端分离和jwt"></a>同时支持web表单、web前后端分离和jwt</h2><p>日常有些项目可能需要支持后台管理页面+h5+app, 那就需要我们的后台服务同时支持web表单、web前后端分离和jwt等方式登录了</p>
<p>改写WebSecurityConfig即可: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.multiplehttpsecurityserver.filter.JwtFilter;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.multiplehttpsecurityserver.filter.JwtLoginFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.DisabledException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.provisioning.InMemoryUserDetailsManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.WebAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ensure the passwords are encoded properly</span></span><br><span class="line">        User.UserBuilder users = User.withDefaultPasswordEncoder();</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(users.username(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;111111&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>).build());</span><br><span class="line">        manager.createUser(users.username(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtApiWebSecurityConfigurationAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.</span><br><span class="line">                    antMatcher(<span class="string">&quot;/app/**&quot;</span>)</span><br><span class="line">                    .authorizeRequests(authorize -&gt; authorize</span><br><span class="line">                            .anyRequest().hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                    )</span><br><span class="line">                    .addFilterBefore(<span class="keyword">new</span> JwtLoginFilter(<span class="string">&quot;/app/login&quot;</span>, authenticationManager()), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                    .addFilterBefore(<span class="keyword">new</span> JwtFilter(), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                    .cors()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable()</span><br><span class="line">                    .exceptionHandling()</span><br><span class="line">                    <span class="comment">//未登录</span></span><br><span class="line">                    .authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">                        resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                        resp.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;未登录-token为空&quot;</span>);</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//权限不足</span></span><br><span class="line">                    .accessDeniedHandler((request, httpServletResponse, ex) -&gt; &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                        httpServletResponse.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">                        httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line"><span class="comment">//                    httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);</span></span><br><span class="line">                        PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiWebSecurityConfigurationAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            http.antMatcher(<span class="string">&quot;/fore-web/**&quot;</span>)</span><br><span class="line">                    .authorizeRequests(authorize -&gt; authorize</span><br><span class="line">                            .anyRequest().hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                    )</span><br><span class="line">                    .cors()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="string">&quot;/fore-web/login&quot;</span>)</span><br><span class="line">                    .successHandler((httpServletRequest, httpServletResponse, authentication) -&gt; &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;登录成功: &quot;</span> + httpServletRequest.getSession().getId());</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                        map.put(<span class="string">&quot;data&quot;</span>, authentication);</span><br><span class="line">                        httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                        PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .failureHandler((req, resp, ex) -&gt; &#123;</span><br><span class="line"><span class="comment">//                    ex.printStackTrace();</span></span><br><span class="line">                        resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                        resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> UsernameNotFoundException || ex <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                            map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                            map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;账户被禁用&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录失败!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .logout()</span><br><span class="line">                    .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">                        map.put(<span class="string">&quot;data&quot;</span>, authentication);</span><br><span class="line">                        resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .exceptionHandling()</span><br><span class="line">                    <span class="comment">//未登录</span></span><br><span class="line">                    .authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">                        resp.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line">                        resp.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//权限不足</span></span><br><span class="line">                    .accessDeniedHandler((request, httpServletResponse, ex) -&gt; &#123;</span><br><span class="line">                        httpServletResponse.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">                        httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">                        httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.toString());</span><br><span class="line"><span class="comment">//                    httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);</span></span><br><span class="line">                        PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;)</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FormLoginWebSecurityConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line"><span class="comment">//                    .authorizeRequests(authorize -&gt; authorize</span></span><br><span class="line"><span class="comment">//                            .anyRequest().authenticated()</span></span><br><span class="line"><span class="comment">//                    )</span></span><br><span class="line">                    .authorizeRequests(authorize -&gt; authorize</span><br><span class="line">                            .anyRequest().hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                    )</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and() <span class="comment">//权限不足</span></span><br><span class="line">                    .exceptionHandling()</span><br><span class="line">                    .accessDeniedHandler((request, httpServletResponse, ex) -&gt; &#123;</span><br><span class="line">                        request.setAttribute(WebAttributes.ACCESS_DENIED_403, ex);</span><br><span class="line">                        httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                        RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">&quot;forbidden&quot;</span>);</span><br><span class="line">                        dispatcher.forward(request, httpServletResponse);</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                    .formLogin(withDefaults());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//1,允许任何来源 *表示任何请求都视为同源(生产环境尽量在配置文件中动态配置部署到的域名)，若需指定ip和端口可以改为如“localhost：8080”</span></span><br><span class="line">        corsConfiguration.setAllowedOriginPatterns(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">//2,允许任何请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">//3,允许任何方法</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">//4,允许凭证</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/jonesun/spring-security-demo/tree/master/multiple-http-security">示例源码-multiple-http-security</a></p>
<h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><p>以上代码都是模拟了用户数据，实际项目中更多的用户数据是保存在数据库中的，Spring Security提供了一个JdbcUserDetailsManager，下面我们就看下如何集成</p>
<ol>
<li>执行创建数据库表sql：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE SCHEMA if not exists &#96;spring_security_test&#96; ;</span><br><span class="line"></span><br><span class="line">use &#96;spring_security_test&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE users (</span><br><span class="line">                       username VARCHAR(50) NOT NULL PRIMARY KEY,</span><br><span class="line">                       password VARCHAR(500) NOT NULL,</span><br><span class="line">                       enabled BOOLEAN NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE authorities (</span><br><span class="line">                             username VARCHAR(50) NOT NULL,</span><br><span class="line">                             authority VARCHAR(50) NOT NULL,</span><br><span class="line">                             CONSTRAINT fk_authorities_users FOREIGN KEY (username)</span><br><span class="line">                                 REFERENCES users (username)</span><br><span class="line">);</span><br><span class="line">create unique index ix_auth_username on authorities (username,authority);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个是参考org/springframework/security/core/userdetails/jdbc/users.ddl，具体可根据自己的项目扩展</p>
</blockquote>
<ol start="2">
<li>pom.xml 加入jdbc和mysql相关依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>application.yml中加入数据库相关配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root123</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spring_security_test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>改写MultiHttpSecurityConfig的userDetailsService</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        // ensure the passwords are encoded properly</span></span><br><span class="line"><span class="comment">//        User.UserBuilder users = User.withDefaultPasswordEncoder();</span></span><br><span class="line"><span class="comment">//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span></span><br><span class="line"><span class="comment">//        manager.createUser(users.username(&quot;user&quot;).password(&quot;111111&quot;).roles(&quot;USER&quot;).build());</span></span><br><span class="line"><span class="comment">//        manager.createUser(users.username(&quot;admin&quot;).password(&quot;123456&quot;).roles(&quot;USER&quot;, &quot;ADMIN&quot;).build());</span></span><br><span class="line"></span><br><span class="line">        JdbcUserDetailsManager manager = <span class="keyword">new</span> JdbcUserDetailsManager();</span><br><span class="line">        manager.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//todo 为测试方便手动加入两个用户 实际项目根据自己需要改为注册方式</span></span><br><span class="line">        <span class="keyword">if</span> (!manager.userExists(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!manager.userExists(<span class="string">&quot;user&quot;</span>)) &#123;</span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;111111&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h3><p>国内项目中很多会集成Mybatis，改写为Mybatis也比较简单，我们来参考实现JdbcUserDetailsManager自己的MybatisUserDetailManager</p>
<ol>
<li><p>首先引入Mybatis，参考<a href="/20200929/java/springboot/c091a644">SpringBoot-集成Mybatis</a></p>
</li>
<li><p>编写自定义的UserDetailsService</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.jonesun.multiplehttpsecurityserver.dao.AuthorityDao;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.multiplehttpsecurityserver.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.multiplehttpsecurityserver.model.AuthorityDO;</span><br><span class="line"><span class="keyword">import</span> com.jonesun.multiplehttpsecurityserver.model.UserDO;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthorityDao authorityDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        UserDO userDO = userDao.getByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">&quot;用户: &quot;</span> + username + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户: &quot;</span> + username + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;AuthorityDO&gt; authorityDOList = authorityDao.listByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (authorityDOList == <span class="keyword">null</span> || authorityDOList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">&quot;用户:  &quot;</span> + username + <span class="string">&quot; 无任何权限&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户:  &quot;</span> + username + <span class="string">&quot; 无任何权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = authorityDOList.stream()</span><br><span class="line">                .map(authorityDO -&gt; <span class="keyword">new</span> SimpleGrantedAuthority(authorityDO.getAuthority()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(userDO.getUsername(), userDO.getPassword(), userDO.getEnabled(),</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, authorities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>改写改写MultiHttpSecurityConfig的userDetailsService</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MybatisUserDetailsService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/jonesun/spring-security-demo/tree/master/multiple-http-security">示例源码-multiple-http-security</a></p>
<blockquote>
<p>如果是企业内部需要使用域账户来控制的，可以结合Spring LDAP使用，具体代码可自己搜索下</p>
</blockquote>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><blockquote>
<p>要使用Spring Security测试支持，必须加入spring-security-test依赖项</p>
</blockquote>
<p>具体查看<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test">官方教程</a></p>
<h1 id="Spring-Security-with-OAuth2"><a href="#Spring-Security-with-OAuth2" class="headerlink" title="Spring Security with OAuth2"></a>Spring Security with OAuth2</h1><p>以上都是单体应用的权限管理，现在Spring Cloud比较火，下面我们就看下如何在Spring Cloud下或者或者编写一个专门用于权限认证的微服务，这里就会涉及到OAuth2的概念了，推荐看下<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a></p>
<h2 id="选择哪个库"><a href="#选择哪个库" class="headerlink" title="选择哪个库?"></a>选择哪个库?</h2><p>使用SpringSecurity来实现OAuth2，之前网上的文章中大都推荐使用<a href="https://github.com/spring-projects/spring-security-oauth">spring-security-oauth</a>，但目前(2020年12月)在其github上看到了这个: </p>
<blockquote>
<p>The Spring Security OAuth project is deprecated. The latest OAuth 2.0 support is provided by Spring Security. See the OAuth 2.0 Migration Guide for further details.</p>
</blockquote>
<p>大体意思就是: 不建议使用Spring Security OAuth项目。Spring Security提供了最新的OAuth 2.0支持。(2.4.x 版本开始相关类都已标注为过时)</p>
<blockquote>
<p>2019年11月下旬，Spring官方在Spring Security OAuth 2.0路线图中 指出2.3.x版本将在2020年3月到达项目生命周期的终点（End Of Life），随后将会发布2.4.x和2.5.x。<br>后续2.4.x和2.5.x补丁和安全修复程序支持将持续到2021年5月，另外2.5.x的安全修复支持将持续到2022年5月项目终止日期。<br>相同的寿命终止时间表适用于对应的Spring Boot 2自动配置项目。<br>Spring Security OAuth 2.0会在2022年5月项目终止后开放给Spring社区中的成员直接管理。</p>
</blockquote>
<p>好，那就还回到Spring Security查看<a href="https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide">Spring Security OAuth 2.0迁移指南</a>, 但前面的一句话是这么说的:</p>
<blockquote>
<p>This document contains guidance for moving OAuth 2.0 Clients and Resource Servers from Spring Security OAuth 2.x to Spring Security 5.2.x. Since Spring Security doesn’t provide Authorization Server support, migrating a Spring Security OAuth Authorization Server is out of scope for this document.</p>
</blockquote>
<p>大体意思就是: 本文档包含有关将OAuth 2.0客户端和资源服务器从Spring Security OAuth 2.x迁移到Spring Security 5.2.x的指南。由于Spring Security不提供Authorization Server支持，因此迁移Spring Security OAuth Authorization Server超出了本文档的范围。</p>
<p>继而找到<a href="https://github.com/spring-projects-experimental/spring-authorization-server">spring-authorization-server</a></p>
<p>总结一下: <strong>Spring Authorization Server将替代Spring Security OAuth为 Spring 社区提供OAuth2.0授权服务器支持</strong>(等待其发行正式版本后, 目前该项目的最新发行版为0.0.3，可以进行尝鲜)，在此之前建议迁移到Spring Security 5.2.+, <a href="https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update">官方文章-Spring Security OAuth 2.0路线图更新</a></p>
<p><strong>所以答案是：使用Spring Security来实现Oauth2</strong></p>
<p>如果看到的博客或者代码中使用的groupId是</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那使用的就是Spring Security OAuth项目，不建议使用(虽然也挺好用的，有兴趣可以找找相关资源看看，或者接手的项目使用的是这个的可以了解下): </p>
<p>授权服务器(能够成功验证资源拥有者和获取授权，并在此之后分发令牌的服务器) <a href="https://github.com/jonesun/spring-security-demo/tree/master/oauth2-server">示例源码-oauth2-server</a><br>资源服务器(存储用户的数据资源，能够接受和响应受保护资源请求的服务器) <a href="https://github.com/jonesun/spring-security-demo/tree/master/oauth2-resource">示例源码-oauth2-resource</a></p>
<p>spring-cloud-starter-security也是依赖这个包的也尽量不要用。里面的类也被废弃了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充一点，最近发布的Spring cloud 2020.0.0版本已经<a href="https://spring.io/blog/2020/12/22/spring-cloud-2020-0-0-aka-ilford-is-available">将Spring Cloud Security这个项目删除了</a> ，其代码已经移到了 Spring Cloud 各个子项目中了。</p>
</blockquote>
<h2 id="开始使用OAuth2"><a href="#开始使用OAuth2" class="headerlink" title="开始使用OAuth2"></a>开始使用OAuth2</h2><p>OAuth2.0 定义了四个角色:</p>
<ul>
<li>Client：客户端，第三方应用程序。</li>
<li>Resource Owner：资源所有者，授权 Client 访问其帐户的用户。</li>
<li>Authorization server：授权服务器，服务商专用于处理用户授权认证的服务器。</li>
<li>Resource server：资源服务器，服务商用于存放用户受保护资源的服务器，它<strong>可以与授权服务器是同一台服务器，也可以是不同的服务器</strong>。</li>
</ul>
<p>oauth2-server专用术语:</p>
<ul>
<li>Access token：用于访问受保护资源的令牌。</li>
<li>Authorization code：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。</li>
<li>Scope：授予应用程序的权限范围。</li>
<li>JWT：Json Web Token 是一种用于安全传输的数据传输格式</li>
</ul>
<p>OAuth2.0 定义了四种授权模式，以应对不同情况时的授权:</p>
<ul>
<li>authorization_code: 授权码模式(功能最完整、流程最严密的授权模式，第三方如github提供的默认模式)</li>
<li>implicit: 隐式授权模式(现已不推荐)</li>
<li>password: 密码模式</li>
<li>client_credentials: 客户端模式</li>
</ul>
<blockquote>
<p>刷新访问令牌(access token): 访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权</p>
</blockquote>
<h3 id="实现OAuth2客户端-spring-boot-starter-oauth2-client"><a href="#实现OAuth2客户端-spring-boot-starter-oauth2-client" class="headerlink" title="实现OAuth2客户端 spring-boot-starter-oauth2-client"></a>实现OAuth2客户端 spring-boot-starter-oauth2-client</h3><p>以下都默认采用authorization_code授权码的方式</p>
<h4 id="使用Github作为授权服务器"><a href="#使用Github作为授权服务器" class="headerlink" title="使用Github作为授权服务器"></a>使用Github作为授权服务器</h4><ol>
<li>首先在Github中新增<a href="https://github.com/settings/developers">OAuth App</a></li>
</ol>
<p><img src="github-new-oauth.png" alt="github-new-oauth"></p>
<p>默认情况下，Spring Boot将此重定向URI配置为/login/oauth2/code/{registrationId}。因此回调地址填: <a href="http://localhost:8080/oauth2-client/login/oauth2/code/github">http://localhost:8080/oauth2-client/login/oauth2/code/github</a></p>
<blockquote>
<p>地址取决于你项目的配置，这里只是演示</p>
</blockquote>
<ol start="2">
<li>新建好Spring Boot项目，pom.xml中加入：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-boot-starter-oauth2-client，默认已经引用了Spring Security，因此不需要显式添加它</p>
</blockquote>
<ol start="4">
<li>application.yml中加入配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/oauth2-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">registration:</span></span><br><span class="line">          <span class="attr">github:</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">&lt;your</span> <span class="string">client</span> <span class="string">id&gt;</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">&lt;your</span> <span class="string">client</span> <span class="string">secret&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>client-id和client-secret从第一步中创建好的Github的OAuth App中获取</p>
</blockquote>
<ol start="5">
<li>创建测试Controller:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>打开浏览器访问<a href="http://localhost:8080/oauth2-client/%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%86%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%88%B0Github%E7%9A%84%E6%8E%88%E6%9D%83%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%A1%AE%E8%AE%A4%E5%90%8E%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AEapi">http://localhost:8080/oauth2-client/，页面将会跳转到Github的授权页面，确认后即可访问api</a></p>
<blockquote>
<p>除了GitHub外，Spring Security项目还包含Google、Facebook和Okta的默认配置。</p>
</blockquote>
<h4 id="使用码云Gitee作为授权服务器"><a href="#使用码云Gitee作为授权服务器" class="headerlink" title="使用码云Gitee作为授权服务器"></a>使用码云Gitee作为授权服务器</h4><ol>
<li>类似Github，在码云中<a href="https://gitee.com/oauth/applications/new">创建第三方应用</a></li>
</ol>
<p><img src="gitee-new-oauth.png" alt="gitee-new-oauth"></p>
<p>回调地址写<a href="http://localhost:8080/oauth2-client/login/oauth2/code/gitee">http://localhost:8080/oauth2-client/login/oauth2/code/gitee</a></p>
<ol start="2">
<li>application.yml中改写配置(由于官方并没有gitee的默认配置，故需要自己配置provider)</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">registration:</span></span><br><span class="line">          <span class="attr">github:</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">&lt;your</span> <span class="string">client</span> <span class="string">id&gt;</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">&lt;your</span> <span class="string">client</span> <span class="string">secret&gt;</span></span><br><span class="line">          <span class="attr">gitee:</span></span><br><span class="line">            <span class="attr">provider:</span> <span class="string">gitee</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">&lt;your</span> <span class="string">client</span> <span class="string">id&gt;</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">&lt;your</span> <span class="string">client</span> <span class="string">secret&gt;</span></span><br><span class="line">            <span class="attr">authorizationGrantType:</span> <span class="string">authorization_code</span></span><br><span class="line">            <span class="attr">redirectUri:</span> <span class="string">&quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;</span></span><br><span class="line">            <span class="attr">clientName:</span> <span class="string">&#x27;码云&#x27;</span></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="attr">gitee:</span></span><br><span class="line">            <span class="attr">authorization-uri:</span> <span class="string">https://gitee.com/oauth/authorize</span></span><br><span class="line">            <span class="attr">token-uri:</span> <span class="string">https://gitee.com/oauth/token</span></span><br><span class="line">            <span class="attr">user-info-uri:</span> <span class="string">https://gitee.com/api/v5/user</span></span><br><span class="line">            <span class="attr">user-name-attribute:</span> <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>client-id和client-secret从第一步中创建好的码云中的第三方应用中获取</p>
</blockquote>
<ol start="3">
<li>打开浏览器访问<a href="http://localhost:8080/oauth2-client/%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%86%E4%BC%9ASpring">http://localhost:8080/oauth2-client/，页面将会Spring</a> Security默认的OAuth 2.0的登录页，选择码云，确认后即可访问api</li>
</ol>
<p>码云相关配置可参考<a href="https://gitee.com/api/v5/oauth_doc#/">官网-OAuth文档</a> ，其他第三方如QQ、微信、新浪微博等都提供了OAuth2的授权服务，可以到各自官方网站查看说明即可</p>
<h4 id="自定义登录页"><a href="#自定义登录页" class="headerlink" title="自定义登录页"></a>自定义登录页</h4><p>实际项目中肯定不会直接用默认的登录页, 需要实现自己的登录页</p>
<ol>
<li>编写LoginController，用于映射页面(为了方便读取数据pom.xml中引入thymeleaf)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.client.registration.ClientRegistration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String authorizationRequestBaseUri = <span class="string">&quot;oauth2/authorization&quot;</span>;</span><br><span class="line">    Map&lt;String, String&gt; oauth2AuthenticationUrls = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientRegistrationRepository clientRegistrationRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoginPage</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将可用的客户端及其授权端点的映射发送到view</span></span><br><span class="line">        Iterable&lt;ClientRegistration&gt; clientRegistrations = <span class="keyword">null</span>;</span><br><span class="line">        ResolvableType type = ResolvableType.forInstance(clientRegistrationRepository).as(Iterable.class);</span><br><span class="line">        <span class="keyword">if</span> (type != ResolvableType.NONE &amp;&amp;</span><br><span class="line">                ClientRegistration.class.isAssignableFrom(type.resolveGenerics()[<span class="number">0</span>])) &#123;</span><br><span class="line">            clientRegistrations = (Iterable&lt;ClientRegistration&gt;) clientRegistrationRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clientRegistrations.forEach(registration -&gt;</span><br><span class="line">                oauth2AuthenticationUrls.put(registration.getClientName(),</span><br><span class="line">                        authorizationRequestBaseUri + <span class="string">&quot;/&quot;</span> + registration.getRegistrationId()));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;urls&quot;</span>, oauth2AuthenticationUrls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写自定义的登录页login.html</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义OAuth2登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Login with:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:each</span>=<span class="string">&quot;url : $&#123;urls&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;url.key&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url.value&#125;&quot;</span>&gt;</span>Client<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改SecurityConfig配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ClientRegistrationRepository clientRegistrationRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OAuth2AuthorizedClientService authorizedClientService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .oauth2Login()</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .clientRegistrationRepository(clientRegistrationRepository)</span><br><span class="line">                .authorizedClientService(authorizedClientService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>打开浏览器访问<a href="http://localhost:8080/oauth2-client/%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%BE%E7%A4%BA%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84OAuth">http://localhost:8080/oauth2-client/，页面就显示我们自己的OAuth</a> 2.0的登录页了，后面也可以同时支持用户名/密码登录的方式(MultiHttpSecurityConfig)</li>
</ol>
<h4 id="自定义身份验证成功和失败"><a href="#自定义身份验证成功和失败" class="headerlink" title="自定义身份验证成功和失败"></a>自定义身份验证成功和失败</h4><p>可以使用不同的方法来控制验证后的行为：</p>
<ul>
<li>defaultSuccessUrl() 和failureUrl() –将用户重定向到给定的URL</li>
<li>successHandler() 和failureHandler() –在身份验证过程之后执行自定义逻辑</li>
</ul>
<blockquote>
<p>创建一个实现AuthenticationSuccessHandler或AuthenticationFailureHandler接口的类，重写继承的方法，然后使用successHandler() 和failureHandler()方法设置bean即可</p>
</blockquote>
<p><a href="https://github.com/jonesun/spring-security-demo/tree/master/oauth2/oauth2-client">示例源码-oauth2-client</a></p>
<h3 id="实现OAuth2授权服务器"><a href="#实现OAuth2授权服务器" class="headerlink" title="实现OAuth2授权服务器"></a>实现OAuth2授权服务器</h3><p>如果要自己实现OAuth2 的授权服务器，一个选择就是用第三方的例如<a href="https://www.keycloak.org/">KeyCloak</a> ,<br>另外可以尝鲜<a href="https://github.com/spring-projects-experimental/spring-authorization-server">Spring Authorization Server</a> -期待下正式版</p>
<blockquote>
<p>另外还有一些授权服务器的提供商Keycloak和ForgeRock等，有兴趣可以了解下</p>
</blockquote>
<h4 id="使用KeyCloak搭建OAuth2授权服务器"><a href="#使用KeyCloak搭建OAuth2授权服务器" class="headerlink" title="使用KeyCloak搭建OAuth2授权服务器"></a>使用KeyCloak搭建OAuth2授权服务器</h4><p>Keycloak是RedHat管理的开源身份和访问管理解决方案，由JBoss用Java开发。Spring Boot可以嵌入Keycloak, 当然Keycloak也可以作为独立服务器运行</p>
<p><a href="https://www.baeldung.com/keycloak-embedded-in-spring-boot-app">嵌入在Spring Boot应用程序中的Keycloak</a></p>
<p>Keycloak目前的访问类型共有3种，可根据自己项目的需要进行配置：</p>
<ul>
<li>confidential：适用于服务端应用，且需要浏览器登录以及需要通过密钥获取access token的场景。典型的使用场景就是服务端渲染的web系统。</li>
<li>public：适用于客户端应用，且需要浏览器登录的场景。典型的使用场景就是前端web系统，包括采用vue、react实现的前端项目等。</li>
<li>bearer-only：适用于服务端应用，不需要浏览器登录，只允许使用bearer token请求的场景。典型的使用场景就是restful api。</li>
</ul>
<ol>
<li><p>配置并添加Client(可参考网上一些教程)<br><img src="keycloak-new-client.png" alt="keycloak-new-client"></p>
</li>
<li><p>OAuth2 Client项目中配置</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">registration:</span></span><br><span class="line">          <span class="attr">keycloak:</span></span><br><span class="line">            <span class="attr">provider:</span> <span class="string">keycloak</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">oauth2-client</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">d7a1acbc-40c8-4c68-a903-b5d01dac2a35</span></span><br><span class="line">            <span class="attr">authorizationGrantType:</span> <span class="string">authorization_code</span></span><br><span class="line">            <span class="attr">redirectUri:</span> <span class="string">&quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;</span></span><br><span class="line">            <span class="attr">clientName:</span> <span class="string">&#x27;keycloak&#x27;</span></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="attr">keycloak:</span></span><br><span class="line">            <span class="attr">issuer-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun</span></span><br><span class="line">            <span class="attr">authorization-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun/protocol/openid-connect/auth</span></span><br><span class="line">            <span class="attr">token-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun/protocol/openid-connect/token</span></span><br><span class="line">            <span class="attr">jwk-set-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun/protocol/openid-connect/certs</span></span><br><span class="line">            <span class="attr">user-info-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun/protocol/openid-connect/userinfo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>client-id默认为我们在keycloak创建的client名称、client-secret可以打开credentialsTab栏获取</p>
</blockquote>
<ol start="3">
<li>与之前使用github一样，打开浏览器测试OAuth2 Client项目即可，这里可以在Controller中获取到token信息client.getAccessToken().getTokenValue()，有了token就可以在任意资源服务器中获取资源了</li>
</ol>
<h4 id="使用Spring-Authorization-Server搭建OAuth2授权服务器"><a href="#使用Spring-Authorization-Server搭建OAuth2授权服务器" class="headerlink" title="使用Spring Authorization Server搭建OAuth2授权服务器"></a>使用Spring Authorization Server搭建OAuth2授权服务器</h4><p>先占个坑，刚在github看到目前的<a href="https://github.com/spring-projects-experimental/spring-authorization-server/issues/154">0.0.3版本暂时还不支持Spring Boot 2.4.0</a>，等这个项目发布更稳定的版本后再研究下</p>
<h3 id="实现OAuth2资源服务器-spring-boot-starter-oauth2-resource-server"><a href="#实现OAuth2资源服务器-spring-boot-starter-oauth2-resource-server" class="headerlink" title="实现OAuth2资源服务器 spring-boot-starter-oauth2-resource-server"></a>实现OAuth2资源服务器 spring-boot-starter-oauth2-resource-server</h3><ol>
<li><p>pom.xml中加入引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-resource-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>spring-boot-starter-oauth2-resource-server, 默认已经引用了Spring Security，因此不需要显式添加它</p>
</blockquote>
</li>
<li><p>application.yml中加入配置:</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">jwt:</span></span><br><span class="line">          <span class="comment"># 授权服务器将颁发的JWT令牌的iss声明中包含的值</span></span><br><span class="line">          <span class="attr">issuer-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun</span></span><br><span class="line">          <span class="attr">jwk-set-uri:</span> <span class="string">http://localhost:8083/auth/realms/jonesun/protocol/openid-connect/certs</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置ResourceServerConfig：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .mvcMatcher(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写测试ApiController</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apiHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;apiHelloWorld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用测试工具如postman或编写测试代码，那之前OAuth2 Client登录获取到的token添加到Header中即可访问资源服务器受保护的资源</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;localhost:8180&#x2F;oauth2-resource-server&#x2F;api&#x2F;hello</span><br><span class="line">authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJJYV9uS2NHY1hkR3FNbWFTQ0RySkR2ZzNzYS1lN21RX2xRLTNnQkhocDAwIn0.eyJleHAiOjE2MDk0MDQ5MzUsImlhdCI6MTYwOTQwNDYzNSwiYXV0aF90aW1lIjoxNjA5NDAzODk0LCJqdGkiOiI1NzAwZTkwNS04ZmE1LTRkOWItOTdiYy1kYzVlYjIzZDY1ZjIiLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgwODMvYXV0aC9yZWFsbXMvam9uZXN1biIsImF1ZCI6ImFjY291bnQiLCJzdWIiOiJkYmYyMDE5Yi05N2U4LTQzZDQtOWEyNi00YTQzZGVhZmU5NjMiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJvYXV0aDItY2xpZW50Iiwic2Vzc2lvbl9zdGF0ZSI6IjM3MmNlYmE3LThlZGItNDFhNi1iNWIwLWQxYTdmYThhMGNmMyIsImFjciI6IjAiLCJyZWFsbV9hY2Nlc3MiOnsicm9sZXMiOlsib2ZmbGluZV9hY2Nlc3MiLCJ1bWFfYXV0aG9yaXphdGlvbiJdfSwicmVzb3VyY2VfYWNjZXNzIjp7ImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2UtYWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sInNjb3BlIjoicHJvZmlsZSBlbWFpbCBqb25lc3Vuc2VjdXJpdHkiLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsIm5hbWUiOiJqb25lIHN1biIsInByZWZlcnJlZF91c2VybmFtZSI6ImpvbmVzdW4iLCJnaXZlbl9uYW1lIjoiam9uZSIsImZhbWlseV9uYW1lIjoic3VuIiwiZW1haWwiOiJzdW5qb25lcjdAZ21haWwuY29tIn0.XuqlW8Ry9Le7_0Aao8e1WGfUmSnEz27P3vFK44toQJaN7XVNqVkdOKTt36JgV6ctguRyaDT1xmow78Y1yZM-5_Ki74aLHWsHgt9aITxdMRNygW6WC3dY3y9-8EcHkh8WgvDbTr58JNEmerSCkC7UFPvhKPcvfQGTjG1XmDwmTDTP7umhZBK408HxLjqJWr6GulIGya_QCJrLCCoO5QDhsiT5tfGqaANtQapfC-TS11NvEoPP9U2oqUtJ6xdosT9AIj9BZbpezCQ5nsE5zb5XvKvmph45VDPa2l9y9YMpdnECTvIX7hEyyMEu_nQfZcyASUazOpyv7Q95fCBEhABUcg</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>综上，<strong>就可以实现在OAuth Client中使用OAuth授权服务器(或第三方授权登录)，拿到token后访问OAuth资源服务器中的相关资源</strong></p>
<p><img src="OAuth2%E6%B5%81%E7%A8%8B.png" alt="OAuth2流程"></p>
<blockquote>
<p><strong>以下为笔者草稿，不建议阅读，文章整理好后会进行删除</strong></p>
</blockquote>
<h1 id="SpringSecurity核心类"><a href="#SpringSecurity核心类" class="headerlink" title="SpringSecurity核心类"></a>SpringSecurity核心类</h1><blockquote>
<p>以下源码来自SpringSecurity-5.3.3版本</p>
</blockquote>
<h2 id="Authentiction"><a href="#Authentiction" class="headerlink" title="Authentiction"></a>Authentiction</h2><p>包含了用户身份信息，密码，细节信息，认证信息，以及权限列表等:</p>
<ul>
<li>getAuthorities，权限列表,通常是代表权限的字符串列表；</li>
<li>getCredentials，密码信息,由用户输入的密码凭证，<strong>认证之后会移出，来保证安全性</strong>；</li>
<li>getDetails，细节信息，Web应用中一般是访问者的ip地址和sessionId；</li>
<li>getPrincipal, 最重要的身份信息，一般返回UserDetails的实现类</li>
</ul>
<blockquote>
<p> Authentication继承自来自于java.security包的Principal类,而本身又是spring.security包中的接口。也就是说，Authentication是Spring Security中最高级别的认证</p>
</blockquote>
<blockquote>
<p>AuthenticationManager、AccessDecisionManager 和 AbstractSecurityInterceptor 属于 Spring Security 框架的基础铁三角。AuthenticationManager 和 Access-DecisionManager 负责制定规则，AbstractSecurityInterceptor 负责执行</p>
</blockquote>
<h2 id="AuthenticationToken"><a href="#AuthenticationToken" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h2><p>所有的认证请求都会被封装成一个Token的实现，比如最容易理解的UsernamePasswordAuthenticationToken，在Spring Security中提交的用户名和密码，会被封装成了UsernamePasswordAuthenticationToken</p>
<h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>用户认证的管理类(权限验证控制器), 所有的认证请求(如login)都会通过生成一个Authentiction传给AuthenticationManager接口的唯一方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authentication authenticate(Authentication authentication) throws AuthenticationException)</span><br></pre></td></tr></table></figure>
<p>进行认证处理。当然由于是接口，所以具体的校验动作会转发给具体的实现类。而AuthenticationManager默认实现类为ProviderManager，然后ProviderManager根据配置的AuthenticationProvider列表，按照顺序进行依次认证，每个provider都会尝试认证，或者通过简单地返回null来跳过验证。如果所有实现都返回null，那么ProviderManager将抛出一个ProviderNotFoundException</p>
<h2 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h2><p>认证的具体实现类，当然这个类也是接口，而且只有两个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 真正的认证</span><br><span class="line">    **&#x2F;</span><br><span class="line">    Authentication authenticate(Authentication var1) throws AuthenticationException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 满足什么样的身份信息才进行如上认证</span><br><span class="line">    **&#x2F;</span><br><span class="line">    boolean supports(Class&lt;?&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以一般实现一个AuthenticationProvider就相当于提供一种认证方式(比如提交的用户名密码通过和数据库内的内容进行比较，那就有一个DaoProvider)。而Spring对于主流的认证方式都已经提供了默认实现:</p>
<ul>
<li>DaoAuthenticationProvider 从数据库中读取用户信息验证身份</li>
<li>AnonymousAuthenticationProvider 匿名用户身份认证</li>
<li>RememberMeAuthenticationProvider 已存cookie中的用户信息身份认证</li>
<li>AuthByAdapterProvider 使用容器的适配器验证身份</li>
<li>CasAuthenticationProvider 使用cas实现单点登陆登录</li>
<li>JaasAuthenticationProvider 从JASS登陆配置中获取用户信息验证身份</li>
<li>RemoteAuthenticationProvider 根据远程服务验证用户身份</li>
<li>RunAsImplAuthenticationProvider 对身份已被管理器替换的用户进行验证</li>
<li>X509AuthenticationProvider 从X509认证中获取用户信息验证身份</li>
<li>TestingAuthenticationProvider 单元测试时使用</li>
<li>…</li>
</ul>
<blockquote>
<p>当然也可以自己实现AuthenticationProvider接口来自定义认证</p>
</blockquote>
<h2 id="UserDetailService"><a href="#UserDetailService" class="headerlink" title="UserDetailService"></a>UserDetailService</h2><p>通过上面分析可以知道用户认证是通过各种Provider来实现的，所以需要拿到系统已经保存的用户认证相关信息(即根据用户名加载用户)的任务则是交给了UserDetailsService而这个就是由UserDetailService来实现的，当然这个类也是接口，并且只有唯一的方法(UserDetails loadUserByUsername(String username))，常用的实现类有JdbcDaoImpl和InMemoryUserDetailsManager，前者从数据库中加载用户，后者从内存中。还可以自己实现UserDetailsService</p>
<blockquote>
<p>在DaoAuthenticationProvider的实现中，对应的方法便是retrieveUser，返回一个UserDetails。然后再将UsernamePasswordAuthenticationToken和UserDetails密码的比对，这便是交给additionalAuthenticationChecks方法完成的，如果这个void方法没有抛异常，则认为比对成功</p>
</blockquote>
<h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><p>UserDetails接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展</p>
<blockquote>
<p>它和Authentication接口类似，都包含了用户名，密码以及权限信息，而区别就是Authentication中的getCredentials来源于用户提交的密码凭证，而UserDetails中的getPassword取到的则是用户正确的密码信息，认证的第一步就是比较两者是否相同，除此之外，Authentication中的getAuthorities是认证用户名和密码成功之后，由UserDetails中的getAuthorities传递而来。而Authentication中的getDetails信息是经过了AuthenticationProvider认证之后填充的</p>
</blockquote>
<h2 id="AbstractAuthenticationProcessingFilter"><a href="#AbstractAuthenticationProcessingFilter" class="headerlink" title="AbstractAuthenticationProcessingFilter"></a>AbstractAuthenticationProcessingFilter</h2><p>Provider认证成功后，AbstractAuthenticationProcessingFilter 在 successfulAuthentication 方法中对登录成功进行了处理，通过 SecurityContextHolder.getContext().setAuthentication() 方法将 Authentication 认证信息对象绑定到 SecurityContext<br>下次请求时，在过滤器链头的 SecurityContextPersistenceFilter 会从 Session 中取出用户信息并生成 Authentication（默认为 UsernamePasswordAuthenticationToken），并通过 SecurityContextHolder.getContext().setAuthentication() 方法将 Authentication 认证信息对象绑定到 SecurityContext<br>需要权限才能访问的请求会从 SecurityContext 中获取用户的权限进行验证</p>
<blockquote>
<p>UsernamePasswordAuthenticationFilter继承于AbstractAuthenticationProcessingFilter</p>
</blockquote>
<h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h2><p>当用户通过认证之后，就会为这个用户生成一个唯一的SecurityContext，里面包含用户的认证信息Authentication。通过SecurityContext我们可以获取到用户的标识Principle和授权信息GrantedAuthrity。在系统的任何地方只要通过SecurityHolder.getSecruityContext()就可以获取到SecurityContext。</p>
<blockquote>
<p>在Shiro中通过SecurityUtils.getSubject()到达同样的目的</p>
</blockquote>
<h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>负责存储当前安全上下文信息。即保存着当前用户是什么，是否已经通过认证，拥有哪些权限。。。等等。SecurityContextHolder默认使用ThreadLocal策略来存储认证信息，意味着这是一种与线程绑定的策略。在Web场景下的使用Spring Security，在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object principal &#x3D; SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">if (principal instanceof UserDetails) &#123;</span><br><span class="line">    String username &#x3D; ((UserDetails) principal).getUsername();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    String username &#x3D; principal.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AuthenticationSuccessHandler"><a href="#AuthenticationSuccessHandler" class="headerlink" title="AuthenticationSuccessHandler"></a>AuthenticationSuccessHandler</h2><p>登陆认证成功处理过滤器</p>
<h2 id="AuthenticationFailureHandler"><a href="#AuthenticationFailureHandler" class="headerlink" title="AuthenticationFailureHandler"></a>AuthenticationFailureHandler</h2><p>登陆失败处理过滤器</p>
<p>使用Spring Security为的就是写最少的代码，实现更多的功能，在定制化Spring Security，核心思路就是：重写某个功能，然后配置。</p>
<ul>
<li>比如你要查自己的用户表做登录，那就实现UserDetailsService接口；</li>
<li>比如前后端分离项目，登录成功和失败后返回json，那就实现AuthenticationFailureHandler/- AuthenticationSuccessHandler接口；</li>
<li>比如扩展token存放位置，那就实现HttpSessionIdResolver接口；</li>
<li>等等…</li>
</ul>
<h1 id="spring-security-jwt"><a href="#spring-security-jwt" class="headerlink" title="spring-security-jwt"></a>spring-security-jwt</h1><p>spring-security-jwt 是 Spring Security Crypto 提供的 JWT 工具包 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-security-jwt.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>核心类只有一个: org.springframework.security.jwt.JwtHelper 。它提供了两个非常有用的静态方法:</p>
<h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>JwtHelper 提供的第一个静态方法就是 encode(CharSequence content, Signer signer) 这个是用来生成jwt的方法 需要指定 payload跟 signer 签名算法。payload 存放了一些可用的不敏感信息：</p>
<ul>
<li>iss jwt签发者</li>
<li>sub jwt所面向的用户</li>
<li>aud 接收jwt的一方</li>
<li>iat jwt的签发时间</li>
<li>exp jwt的过期时间，这个过期时间必须要大于签发时间 iat</li>
<li>jti jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li>
</ul>
<p>除了以上提供的基本信息外，我们可以定义一些我们需要传递的信息，比如目标用户的权限集 等等。切记不要传递密码等敏感信息，因为 JWT 的前两段都是用了 BASE64 编码，几乎算是明文了。</p>
<h1 id="security-oauth2-整合的3个核心配置类"><a href="#security-oauth2-整合的3个核心配置类" class="headerlink" title="security oauth2 整合的3个核心配置类"></a>security oauth2 整合的3个核心配置类</h1><ol>
<li><p>资源服务配置 ResourceServerConfiguration</p>
</li>
<li><p>授权认证服务配置 AuthorizationServerConfiguration</p>
</li>
<li><p>security 配置 SecurityConfiguration</p>
</li>
</ol>
<h1 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h1><ul>
<li>当已登录用户再次访问登录界面时，跳转到index页面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当已登录用户再次访问登录界面时，跳转到index页面</span></span><br><span class="line">        Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span>(auth <span class="keyword">instanceof</span> AnonymousAuthenticationToken)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:index&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义了登录成功处理接口后，保持原先系统的自动转向处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        super.configure(http);</span></span><br><span class="line">        <span class="comment">//原有配置中加入</span></span><br><span class="line">        http</span><br><span class="line">                .successHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">                    <span class="comment">//记录登录日志，初始化用户菜单等等</span></span><br><span class="line">                    String  redirectUrl = <span class="string">&quot;index&quot;</span>; <span class="comment">//缺省的登录成功页面</span></span><br><span class="line">                    SavedRequest savedRequest = (SavedRequest) req.getSession().getAttribute(<span class="string">&quot;SPRING_SECURITY_SAVED_REQUEST&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(savedRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        redirectUrl =   savedRequest.getRedirectUrl();</span><br><span class="line">                        logger.info(<span class="string">&quot;redirectUrl: &quot;</span> + redirectUrl);</span><br><span class="line">                        req.getSession().removeAttribute(<span class="string">&quot;SPRING_SECURITY_SAVED_REQUEST&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resp.sendRedirect(redirectUrl);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>spring-security-data</p>
<p><strong>security-spring的使用参考<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/">Spring Security Reference 官方网站</a> 、<br><a href="https://github.com/spring-projects/spring-security-samples">官方Github-sample</a><br>和大神baeldung的文章<a href="https://www.baeldung.com/spring-security-oauth">Spring Security OAuth 2指南</a></strong></p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx的使用</title>
    <url>/20210922/nginx/6aeab245/</url>
    <content><![CDATA[<h1 id="docker-中运行nginx"><a href="#docker-中运行nginx" class="headerlink" title="docker 中运行nginx"></a>docker 中运行nginx</h1><h2 id="拉取nginx最新镜像"><a href="#拉取nginx最新镜像" class="headerlink" title="拉取nginx最新镜像"></a>拉取nginx最新镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>

<p>如果需要指定版本，可以到<a href="https://hub.docker.com/_/nginx?tab=tags&page=1&ordering=last_updated"> Docker Hub 镜像仓库</a> 选择指定Tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx:1.21.3</span><br></pre></td></tr></table></figure>

<p>查看是否拉取成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="docker-images.png" alt="docker-images"></p>
<h2 id="运行nginx"><a href="#运行nginx" class="headerlink" title="运行nginx"></a>运行nginx</h2><p>一般需要代理转发，需要修改配置。直接修改容器的配置不是很方便，这时候，可以用上挂载功能，让容器加载或写入宿主机器上的挂载目录。<br>这样，我们直接在宿主机上就可以修改配置或查看日志了。</p>
<p>首先在宿主机上创建3个nginx的文件夹(笔者是使用Windows版的Docker Desktop进行测试的，故宿主机是windows，如果是部署到Linux的话则使用mkdir -p进行创建)：</p>
<p>html: 挂载静态页面目录<br>conf: 挂载nginx的主配置文件，以方便在宿主机上直接修改容器的配置文件<br>log: 挂载容器内nginx的日志，容器运行起来之后，可以直接在宿主机的这个目录中查看nginx日志</p>
<p><img src="windows%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="windows宿主机创建文件夹"></p>
<h3 id="拷贝容器中默认的配置文件"><a href="#拷贝容器中默认的配置文件" class="headerlink" title="拷贝容器中默认的配置文件"></a>拷贝容器中默认的配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先简单运行nginx</span></span><br><span class="line">docker run --name nginx -it -p 80:80 -d nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx 运行的容器ID</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到nginx的容器id如笔者的是02e4a2b4767a 拷贝conf到宿主机对应目录 </span></span><br><span class="line">docker cp 容器id:/etc/nginx/nginx.conf D:\Software\docker\env\nginx\conf\</span><br><span class="line">docker cp 容器id:/etc/nginx/conf.d D:\Software\docker\env\nginx\conf\</span><br><span class="line">docker cp 容器id:/usr/share/nginx/html D:\Software\docker\env\nginx\html\</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝完之后停止并删除容器</span></span><br><span class="line">docker stop 容器id</span><br><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新版本的docker desktop设置中设置后支持直接D:\ 如果不支持的则可以使用/d/ 代表D:\</p>
</blockquote>
<p><img src="docker-ps.png" alt="docker-ps"></p>
<p>可以看到我们在本地的conf文件夹中多了一个nginx.conf，这个就是nginx的核心配置文件了</p>
<blockquote>
<p>当然如果本地已经有了配置文件，则可以不用拷贝容器中默认的配置文件，直接进入下一步</p>
</blockquote>
<h3 id="挂载后运行"><a href="#挂载后运行" class="headerlink" title="挂载后运行"></a>挂载后运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run --name my-nginx -p 80:80 --restart=always -v /d/Software/docker/env/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /d/Software/docker/env/nginx/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/nginx -v /d/Software/docker/env/nginx/html:/usr/share/nginx/html -d nginx</span></span><br><span class="line"></span><br><span class="line">docker run --name my-nginx -p 80:80 --restart=always -v D:\Software\docker\env\nginx\conf\nginx.conf:/etc/nginx/nginx.conf -v D:\Software\docker\env\nginx\log:/var/log/nginx -v D:\Software\docker\env\nginx\html:/usr/share/nginx/html -d nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–restart=always 一直保持运行，自动启动 -d 表示在一直在后台运行容器</p>
</blockquote>
<p>打开浏览器输入localhost后看到如下页面，就说明nginx已经启动成功，后面就根据项目需要配置更改nginx.conf即可</p>
<p><img src="welcome-to-nginx.png" alt="welcome-to-nginx"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>修改配置后，我们可以重启镜像，或者进入镜像中 ./nginx -s reload，即可让修改生效:</p>
<p>查看nginx 运行的容器ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>进入容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>

<p>重新加载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -t 容器id nginx -s reload</span><br></pre></td></tr></table></figure>

<p>如果有需要则可以重启容器容器重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -t 容器id nginx -t</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
